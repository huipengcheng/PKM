---
tags: 📥️/📚️/🟥️
aliases:
type: book
status: 🟥️
created: 2022-05-05 16-00
updated: 2022-06-01 22-15
---

# Title: [[{ 2021-05 图解 HTTP]]

## Metadata
- `Topics:` [[Networking]] [[HTTP]]
- `Title:` [[{ 2021-05 图解 HTTP]]
- `Type:` [[{]]
- `Publish Date:` 
- `Reviewed Date:` [[2022-05-05]]

## Note

# 简单的 HTTP 协议

## URI & URL

### URI

统一资源标志符 Uniform Resource Identifier

### URL

统一资源定位符 Uniform Resource Locator

URL 是一种具体的 URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI 是理论或者说规范，URL 是按照规范的具体实现。

## HTTP 方法

![Screen Shot 2021-04-01 at 14.40.56](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-01%20at%2014.40.56.png)

LINK 和 UNLINK 已被 HTTP/1.1 废弃，不再支持。

### GET

GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。

### POST

POST 方法用来传输实体的主体。

虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。

### PUT

PUT 方法用来传输文件。

但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以 上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。

### HEAD

HEAD 方法和 GET 方法一样，只是不返回报文主体部分，只返回报文首部。用于确认 URI 的有效性及资源更新的日期时间等。

### DELETE

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。

但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

### OPTIONS

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

 请求  
 OPTIONS * HTTP/1.1   
 Host: www.hackr.jp  
 ​  
 响应  
 HTTP/1.1 200 OK  
 Allow: GET, POST, HEAD, OPTIONS

### Trace

TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 **200 OK** 的响应。

客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。

但是，TRACE 方法本来就不怎么常用，再加上它容易引发 XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了

### CONNECT

CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

 CONNECT 代理服务器名:端口号 HTTP版本  
 ​  
 请求  CONNECT proxy.hackr.jp:8080 HTTP/1.1   
              Host: proxy.hackr.jp  
 响应  HTTP/1.1 200 OK（之后进入网络隧道）

## 持久连接

HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse。只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。

### 管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。管线化技术则比持久连接还要快。请求数越多，时间差就越明显。

# HTTP 报文内的 HTTP 信息

## 结构

![Screen Shot 2021-03-31 at 20.06.40](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2020.06.40.png)

请求报文（上）和响应报文（下）的结构：

![Screen Shot 2021-03-31 at 20.06.51](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2020.06.51.png)

-   请求行：包含用于请求的方法，请求 URI 和 HTTP 版本；
    
-   状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本；
    
-   首部：一般有四种，通用首部、请求首部、响应首部和实体首部；
    
-   其他，可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）。
    

## 编码

### 报文主体和实体主体

-   报文（message）
    
    是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence， 其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。
    
-   实体（entity）
    
    作为请求或响应的有效载荷数据(补充项)被传输，其内容由实体首部和实体主体组成。
    

HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

### 压缩传输的内容编码

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收邴负责解码。

-   gzip（GNU zip）
    
-   compress（UNIX 系统的标准压缩）
    
-   deflate（zlib）
    
-   identity（不进行编码）
    

### 分块传输编码

把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用 “0(CR + LF)” 来标记。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。

HTTP/1.1 中存在一种称为传输编码（Transfer Coding，首部）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。

## 多部分对象集合

HTTP 协议中采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等**上传**时使用。

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上 Content-type。

还需使用 boundary 字符串来划分多部分对象集合指明的各类实体。在 boundary 字符串指定的各个实体的起始行**之前**插入“--”标记，而在多部分对象集合对应的字符串的**最后**插入“--”标记作为结束。

多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可以在某个部分中嵌套使用多部分对象集合。

### multipart/form-data

在 Web 表单文件上传时使用。

 Content-Type: multipart/form-data; boundary=AaB03x    
 --AaB03x  
 Content-Disposition: form-data; name="field1"  
    
 Joe Blow  
 --AaB03x  
 Content-Disposition: form-data; name="pics"; filename="file1.txt" Content-Type: text/plain  
    
 ...(file1.txt的数据)...  
 --AaB03x--

由于有 boundary 隔离，既可以上传键值对，也可以上传文件。Content-Disposition，用来说明字段的一些信息。当上传的字段是文件时，会有Content-Type 来表名文件类型。

上述代码上传了：

1.  键对值：field1: Joe Blow
    
2.  文件：file1.txt
    

> 最后一行似乎要再最后加上 "--"。

### multipart/byteranges

状态码 **206（Partial Content，部分内容）**响应报文包含了多个范围的内容时使用。

 HTTP/1.1 206 Partial Content  
 Date: Fri, 13 Jul 2012 02:45:26 GMT  
 Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT  
 Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES  
 ​  
 --THIS_STRING_SEPARATES  
 Content-Type: application/pdf   
 Content-Range: bytes 500-999/8000  
 ​  
 ...(范围指定的数据)...   
 --THIS_STRING_SEPARATES   
 Content-Type: application/pdf   
 Content-Range: bytes 7000-7999/8000  
 ​  
 ​  
 ...(范围指定的数据)...   
 --THIS_STRING_SEPARATES--

## 内容协商

Content Negotiation

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准，如下：

-   Accept
    
-   Accept-Charset
    
-   Accept-Encoding
    
-   Accept-Language
    
-   Content-Language
    

> 还有 Vary。

内容协商有三种类型：

-   服务器驱动协商（Server-driven Negotiation）。由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。
    
-   客户端驱动协商（Agent-driven Negotiation）。由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。
    
-   透明协商（Transparent Negotiation）。是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。
    

# HTTP 状态码

![Screen Shot 2021-03-30 at 20.31.00](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-30%20at%2020.31.00.png)

## 2XX 成功

### 200 OK

### 204 No Content

该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。

一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。

### 206 Partial Content

该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

## 3XX 重定向

### 301 Moved Permanently

永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。

### 302 Found

临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。

### 303 See Other

该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。

> 当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送。
> 
> 301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做。

### 304 Not Modified

该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系。

> 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。

### 307 Temporary Redirect

临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

## 4XX 客户端错误

### 400 Bad Request

该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

### 401 Unauthorized

该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。

返回含有 401 的响应必须包含一个适用于被请求资源的 WWW- Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收 到 401 响应，会弹出认证用的对话窗口。

### 403 Forbidden

该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。

未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。

### 404 Not Found

该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

## 5XX 服务器错误

### 500 Internal Server Error

该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。

### 503 Service Unavailable

该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

# 与 HTTP 协作的 Web 服务器

## 单台虚拟机实现多个域名

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

## 通信数据转发程序

### 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。

> 1.  每次通过代理服务器转发请求或响应时，会追加写入 **Via** 首部信息。
>     
> 2.  可以级联多台代理服务器。
>     

作用：使用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。

分类：

1.  缓存代理（Caching Proxy）。转发响应时会预先将资源等副本缓存在代理服务器上；
    
2.  透明代理（Transparent Proxy）。不对报文做任何加工的代理类型被称为透明代理，反之为非透明代理。
    

### 网关

网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。

![Screen Shot 2021-03-31 at 00.30.57](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2000.30.57.png)

利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL 语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。

### 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之 后的服务器。隧道会在通信双方断开连接时结束。

![Screen Shot 2021-03-31 at 00.32.02](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2000.32.02.png)

图：通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的。

## 缓存

1.  缓存服务器是代理服务器的一种；
    
2.  缓存还可以存在客户端浏览器中；
    
3.  缓存有有效期限。若判断浏览器缓存失效，浏览器会再次请求新资源。
    

# HTTP 首部

## 首部字段介绍

### **HTTP/1.1** 首部字段

-   通用首部字段 ![Screen Shot 2021-04-01 at 15.00.04](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-01%20at%2015.00.04.png)
    
-   请求首部字段 ![Screen Shot 2021-04-01 at 15.00.45](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-01%20at%2015.00.45.png)
    
-   响应首部字段 ![Screen Shot 2021-04-01 at 15.00.52](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-01%20at%2015.00.52.png)
    
-   实体首部字段 ![Screen Shot 2021-04-01 at 15.01.00](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-01%20at%2015.01.00.png)
    

### 非 HTTP/1.1 首部字段

不限于 RFC2616 中定 义的 47 种首部字段。还有 Cookie、Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。

### End-to-end 首部和 Hop-by-hop 首部

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。

端到端首部（End-to-end Header）

分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。

逐跳首部（Hop-by-hop Header）

分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再 转发。HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。

下面列举了 HTTP/1.1 中的逐跳首部字段。除这 8 个首部字段之外， 其他所有字段都属于端到端首部。

-   Connection
    
-   Keep-Alive
    
-   Proxy-Authenticate
    
-   Proxy-authorization
    
-   Trailer
    
-   TE
    
-   Transfer-Encoding
    
-   Upgrade
    

## **HTTP/1.1** 通用首部字段

General Header Fields

### Cache-Control

操作缓存的工作机制。

![Screen Shot 2021-03-31 at 00.42.10](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2000.42.10.png)

#### public

表面其他用户也可以利用缓存。

#### private

对特定用户提供资源缓存的服务，而其他用户发送过来的请求，代理服务器不会返回缓存。

> 最后一句指的是不会返回特定用户的缓存，所以 private 应该用于个人信息等的缓存。

![img](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/432a336e992d083bb39bf250a25c764e.jpg-wh_600x-s_1473915043.jpg)

#### no-cache

##### 请求

表示客户端不会接收缓存过的响应，让缓存服务器重新验证缓存。

##### 响应

1.  no-cache 没有指定参数值。缓存服务器不能对资源进行缓存；
    
2.  no-cache 指定参数。那么只有这个指定参数对应的首部字段不能被缓存。
    

#### no-store

暗示请求（和对应的响应）或响应中包含机密信息。

> no-cache 代表不缓存过期的资源，do not serve from cache without revalidation。
> 
> no-store 才是真正地不进行缓存。

#### s-maxage

功能与 max-age 相同，不同是 s-maxage 指令只适用于供多位用户使用的公共缓存服务器。

> 如果使用了 s-maxage 指令，则之间忽略 Expires 首部字段及 max-age 指令的处理。

#### max-age

##### 请求

判定缓存资源的缓存时间是否比指定时间更小。

##### 响应

代表资源保存为缓存的最长时间。

> HTTP/1.1 中 max-age 优先级高于 Expires 首部字段，HTTP/1.0 相反。

#### min-fresh

要求缓存服务器返回指定时间内的缓存数据，超过这个时间的资源都无法作为响应返回。

#### max-stale

如果缓存时间未超过 max-stale，即使过期了客户端也照常接受。如果未指定参数，则代表无论经过多久。

#### only-if-cached

要求缓存服务器不重新加载响应，也不会再次确认资源有效性，如果缓存未命中，则返回 **504 Gateway Timeout**。

> 表示不进行网络请求，完全只使用缓存。

#### must-revalidate

代理会向源服务器再次验证即将返回的响应缓存目前是否仍然有效。若代理无法连通源服务器，则返回 **504 Gateway Timeout**。

must-revalidate 会忽略掉 max-stale。

#### proxy-revalidate

[RFC 7234, section 5.2.2.7](https://tools.ietf.org/html/rfc7234#section-5.2.2.7)

The "proxy-revalidate" response directive has the same meaning as the must-revalidate response directive, except that it does not apply to **private caches**.

#### no-transform

规定无论是在请求还是响应中，缓存都不能改变实体主体的媒体类型。这样做可防止缓存或代理压缩图片等类似操作。

#### cache-extension token

可以拓展 Cache-Control 内的指令，如果缓存不能理解拓展的指令就会直接忽略。

### Connection

#### 控制不再转发给代理的首部字段

![Screen Shot 2021-03-31 at 11.24.50](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2011.24.50.png)

#### 管理持久连接

1.  当服务器端想明确断开连接时，则指定 Connection 首部字段的值为 Close。
    
2.  HTTP/1.1 默认都是长连接，如果想在 HTTP/1.0 中维持持续链接，需要指定 Connection 的值为 Keep-Alive。服务器收到后，会加上首部字段 Keep-Alive 和 Connection 后返回。
    
    ![Screen Shot 2021-03-31 at 11.31.24](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2011.31.24.png)
    

### Date

表明创建 HTTP 报文的日期和时间。

 Date: Tue, 03 Jul 2012 04:40:59 GMT

### Pragma

是 HTTP/1.1 之前的历史遗留字段，仅用来向前兼容。形式唯一，只用来要求中间服务器不返回缓存。

 Pragma: no-cache

虽然属于通用字段，但只用于请求中。

如果需要用到 Cache-Controle: no-cache 的时候，都会加上 Pragma: no-cache 来向前兼容。

### Trailer

用来说明报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

### Transfer-Encoding

规定了传输报文主体时采用的编码方式。HTTP/1.1 的传输编码方式仅对分块传输编码有效。

### Upgrade

用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

 Upgrade: TLS/1.0  
 Connection: Upgrade

Connection 和 Upgrade 有不同的语义和使用场景：

-   Connection: Upgrade 表示 Upgrade 是一个 hop-by-hop 的字段。这个头部是给 proxy 看的。
    
-   Upgrade: TLS/1.0 表示浏览器想要升级到 TLS/1.0 协议。这个头部是给最终处理请求的程序看的。
    
-   如果只有 Upgrade: TLS/1.0，说明 proxy 不支持 TLS/1.0 升级，按照标准应该视为普通 HTTP 请求。所以一般使用 Upgrad 时，需要额外指定 Connection: Upgrade。
    

对于附有首部字段 Upgrade 的请求，服务器可用 **101 Switching Protocols** 状态码作为响应返回。

### Via

追踪客户端与服务器之间的请求和响应报文的传输路径。

报文经过代理或网关时，会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。

可以避免请求回环的发生。

### Warning

HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。通常会告知用户一些与缓存相关的问题的警告。

格式：

 Warning: [警告码] [警告的主机:端口号] "[警告内容]" ([日期时间])

![Screen Shot 2021-03-31 at 13.34.58](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2013.34.58.png)

仅推荐参考，且未来可能会追加新的警告码。

## **HTTP/1.1** 请求首部字段

Request Header Fields

### Accept

通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。

-   文本文件
    
    -   text/html, text/plain, text/css ...
        
    -   application/xhtml+xml, application/xml ...
        
-   图片文件
    
    -   image/jpeg, image/gif, image/png ...
        
-   视频文件
    
    -   video/mpeg, video/quicktime ...
        
-   应用程序使用的二进制文件
    
    -   application/octet-stream, application/zip ...
        

使用 q= 来表示权重，用分号进行分割。q 的范围是 0～1，可以精确到小数点后三位。不指定 q 时默认为 1.0。

 Accept: text/plain; q=0.3, text/html

表示 HTML 权重 1，plain 权重 0.3。

### Accept-Charset

用来通知服务器用户代理支持的字符集及 字符集的相对优先顺序。也可以使用 q 来指定权重。

该首部字段应用于内容协商机制的服务器驱动协商。

### Accept-Encoding

用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序，也可以使用 q 来指定权重。另外也可以使用 * 作为通配符，指定任意的编码格式。

-   gzip
    
-   compress
    
-   deflate
    
-   identity
    

### Accept-Language

用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），也可以使用 q 来指定权重。

### Authorization

用来告知服务器，用户代理的认证信息（证书值）。用户在收到返回的 **401** 状态码后，会把首部字段 Authorization 加入请求中。

### Expect

客户端告知服务器期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 **417 Expectation Failed**。

HTTP/1.1 规范只定义了 100-continue（状态码 **100 Continue** 之意）。

### From

告知服务器使用用户代理的用户的电子邮件地址。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。

### Host

告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。

> 我们知道一个IP地址可以对应多个域名，比如假设我有这么几个域名 www.\qiniu.com，www.taobao.com和 www.jd.com 然后在域名提供商那让这些域名和虚拟机服务器IP 111.111.111.111 关联起来，那么我通过任何一个域名去访问最终解析到的都是IP 111.111.111.111。此时就会有一个问题，我们每次访问这些域名其实都是解析到服务器 IP 111.111.111.111，此时就必须要用 Host 来区分要访问的是哪个站点。

如果服务器未设定主机名，那 Host 设置为空即可。

### If-Match

形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

服务器会比对 If-Match 的字段值和服务器匹配资源的 ETag 值，仅当两者一致时，才会执行请求。反之，则返回状态码 **412 Precondition Failed** 的响应。这时的服务器无法使用弱 ETag 值。

当 If-Match 的值为 * 时，服务器就会忽略掉这个条件。

### If-Modified-Since

如果服务器上匹配的资源更新时间比 If- Modified-Since 指定的更新，则服务器能够处理请求。反之返回状态码 **304 Not Modified** 的响应。

> 资源的更新日期时间，可通过响应首部字段 Last-Modified 来确定。

### If-None-Match

和 If-Match 的作用相反。

### If-Range

告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

### If-Unmodified-Since

和首部字段 If-Modified-Since 的作用相反，不满足条件时返回状态码 **412 Precondition Failed**。

### Max-Forwards

通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。

客户端请求在由多台服务器转发的过程中

1.  可能由于某些原因导致请求转发失败，导致客户端等不到源服务器的响应；
    
2.  可能请求会陷入代理之间的循环。
    

### Proxy-Authorization

和 Authorization 类似，但 Proxy-Authorization 发生在客户端和代理之间，而 Authorization 发声在客户端和服务器之间。

### Range

 Range: bytes=5001-10000  
 Range: bytes=5001-  从 5001 字节之后全部的  
 Range: bytes=-3000, 5000-7000   0-3000, 5000-7000

接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 **206 Partial Content** 的响应。对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。

无法处理该范围请求时，则会返回状态码 **200 OK** 的响应和完整的实体内容。

### Referer

首部字段 Referer 会告知服务器请求的原始资源的 URI。

当浏览器向 web 服务器发送请求的时候，一般会带上 Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。

但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。因为原始资源的 URI 中的查询字符串可能含有 ID 和密码等保密信 息，要是写进 Referer 转发给其他服务器，则有可能导致保密信息的 泄露。

> 另外，Referer 的正确的拼写应该是 Referrer，但不知为何，大家一直沿用这个错误的拼写。

### TE

TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级，也可以使用 q 来指定权重。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。

> 个人理解：TE 是客户端告知服务器客户端能处理的传输编码，而 Transfer-Encoding 只能用来规定分块传输。

 TE: gzip, deflate;q=0.5

TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。

 TE: trailers

### User-Agent

User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。

## **HTTP/1.1** 响应首部字段

Response Header Fields

### Accept-Ranges

用来告知客户端服务器是否能处理范围请求。

-   能处理指定为 bytes；
    
-   反之指定为 none。
    

### Age

1.  如果响应的是源服务器，Age 代表源服务器在多久前创建了响应，字段值的单位为秒；
    
2.  如果响应的是缓存服务器，Age 代表缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段 Age。
    

### ETag

ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。

1.  强 ETag。不论实体发生多么细微的变化都会改变其值。
    
2.  弱 ETag。只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变 ETag 值。这时，会在字段值最开始处附加 W/。
    

### Location

Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。

基本上，该字段会配合 **3xx :Redirection** 的响应，提供重定向的 URI。

几乎所有的浏览器在接收到包含首部字段 Location 的响应后，都会强制性地尝试对已提示的重定向资源的访问。

![Screen Shot 2021-03-31 at 16.29.52](data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1698 1534"%3E%3C/svg%3E)

### Proxy-Authenticate

首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。

Proxy-Authenticate 和 WWW-Authorization 作用类似，前者是发生在客户端与代理之间，后者发生在客户端和服务器之前。

### Retry-After

首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。

主要配合状态码 **503 Service Unavailable** 响应，或 **3xx Redirect** 响应一起使用。

字段值可以指定为具体的日期时间（Wed, 04 Jul 2012 06:34:24 GMT 等格式），也可以是创建响应后的秒数。

### Server

告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。

### Vary

![Screen Shot 2021-03-31 at 16.56.08](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2016.56.08.png)

[https://imququ.com/post/vary-header-in-http.html](https://imququ.com/post/vary-header-in-http.html)

### WWW-Authenticate

告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 **401 Unauthorized** 响应中， 肯定带有首部字段 WWW-Authenticate。

 WWW-Authenticate: Basic realm="Usagidesign Auth"

realm 字段的字符串是为了辨别请求 URI 指定资源所受到的保护策略。

## **HTTP/1.1** 实体首部字段

Entity Header Fields

实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

### Allow

用于通知客户端能够支持的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 **405 Method Not Allowed** 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。

### Content-Encoding

告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行 的压缩。

编码的方式和 Accept-Encoding 相同。

### Content-Language

告知客户端，实体主体使用的自然语言。

### Content-Length

表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段。

### Content-Location

和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI。

> 比如，对于使用首部字段 Accept-Language 的服务器驱动型请求，当返回的页面内容与实际请求的对象不同时，首部字段 Content-Location 内会写明 URI。（访问 [http://www.hackr.jp/](http://www.hackr.jp/) 返回的对象却是 [http://www.hackr.jp/index-ja.html](http://www.hackr.jp/index-ja.html) 等类似情况）

### Content-MD5

目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。

> 无法检测出恶意篡改，因为：如果在传输过程中报文主体可以被恶意修改，那么同时意味着 Content-MD5 也可以被重新计算并修改。

### Content-Range

在返回范围请求响应时使用，能告知客户端作为响应返回的实体是哪个部分。字段值以字节为单位，表示当前发送部分及整个实体大小。

Content-Range: bytes 5001-10000/10000

### Content-Type

说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。

参数 charset 使用 iso-8859-1 或 euc-jp 等字符集进行赋值。

Content-Type: text/html; charset=UTF-8

### Expires

首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。

源服务器不希望缓存服务器对资源缓存时，最好在 Expires 字段内写 入与首部字段 Date 相同的时间值。

但是，当首部字段 Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。

### Last-Modified

首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。

## 为 Cookie 服务的首部字段

Cookie虽然没有被编入标准化 HTTP/1.1 的 RFC2616 中，但在 Web 网站方面得到了广泛的应用。

![Screen Shot 2021-03-31 at 19.42.13](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-03-31%20at%2019.42.13.png)

### Set-Cookie

#### expires

1.  指定浏览器可以发送 Cookie 的有效期；
    
2.  如果未指定，有效期仅限于维持浏览器会话（Session）时间段内。这通常限于浏览器应用程序被关闭之前。
    

一旦 Cookie 从服务器端发送至客户端，服务器端就不存在可以显式删除 Cookie 的方法。但可通过覆盖已过期的 Cookie，实现对客户端 Cookie 的实质性删除操作。

#### path

1.  用于限制指定 Cookie 的发送范围的文件目录。
    
2.  若不指定，则默认为文档所在的文件目录。
    

> 不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱 有期待。

#### domain

1.  作为 Cookie 适用对象的域名；
    
2.  不指定则默认为创建 Cookie 的服务器的域名。
    

#### secure

1.  用于限制 Web 页面仅在 HTTPS 安全连接时，才可以发送 Cookie。
    
2.  不指定则不论 HTTP 还是 HTTPS 都可以发送 Cookie。
    

#### HttpOnly

Cookie 的 HttpOnly 属性是 Cookie 的扩展功能，它使 JavaScript 脚本无法获得 Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS）对 Cookie 的信息窃取。

### Cookie

Cookie: status=enable

首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个 Cookie 时，同样可以以多个 Cookie 形式发送。

## 其他首部字段

HTTP 首部字段是可以自行拓展的，下面是一些最常用的首部字段。

### X-Frame-Options

首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。

有以下两个可指定的字段值：

-   **DENY** ：拒绝
    
-   **SAMEORIGIN** ：仅同源域名下的页面（Top-level-browsing- context）匹配时许可。（比如，当指定 [http://hackr.jp/sample.html](http://hackr.jp/sample.html) 页面为 SAMEORIGIN 时，那么 hackr.jp 上所有页面的 frame 都被允许可加载该页面，而 example.com 等其他域名的页面就不行了)
    

能在所有的 Web 服务器端预先设定好 X-Frame-Options 字段值是最理想的状态。

### X-XSS-Protection

首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。

首部字段 X-XSS-Protection 可指定的字段值如下。：

-   0：将 XSS 过滤设置成无效状；
    
-   1：将 XSS 过滤设置成有效状态。
    

### DNT

首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。

首部字段 DNT 可指定的字段值如下：

-   0：同意被追踪；
    
-   1：拒绝被追踪。
    

由于首部字段 DNT 的功能具备有效性，所以 Web 服务器需要对 DNT 做对应的支持。

### P3P

首部字段 P3P 属于 HTTP 响应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。

要进行 P3P 的设定，需按以下操作步骤进行。

步骤 1：创建 P3P 隐私

步骤 2：创建 P3P 隐私对照文件后，保存命名在 /w3c/p3p.xml

步骤 3：从 P3P 隐私中新建 Compact policies 后，输出到 HTTP 响应 中

有关 P3P 的详细规范标准请参看下方链接。

**The Platform for Privacy Preferences 1.0** (**P3P1.0**) **Specification** [http://www.w3.org/TR/P3P/](http://www.w3.org/TR/P3P/)

> 协议中对 **X-** 前缀的废除
> 
> 在 HTTP 等多种协议中，通过给非标准参数加上前缀 X-，来区别于标准参数，并使那些非标准的参数作为扩展变成可能。但是这种简单粗暴的做法有百害而无一益，因此在“RFC 6648 - Deprecating the "X-" Prefix and Similar Constructs in Application Protocols”中提议停止该做法。
> 
> 然而，对已经在使用中的 X- 前缀来说，不应该要求其变更。

# HTTPS

## HTTP 的缺点

### 通信使用明文可能会被窃听

HTTP 报文使用明文（指未经过加密的报文）方式发送。而 TCP/IP 是可能被窃听的网络。需要加密处理防止被窃听。

-   通信的加密
    
    HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。
    
    用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL。
    
-   内容的加密
    
    还有一种将参与通信的内容本身加密的方式，把 HTTP 报文主体进行加密处理。前提是要求客户端和服务器同时具备加密和解密机制。
    
    > 由于该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。
    

### 不验证通信方的身份就可能遭遇伪装

HTTP 协议中的请求和响应不会对通信方进行确认，这样就会存在以下各种隐患：

-   请求发送至目标的 Web 服务器有可能是已伪装的 Web 服务器。
    
-   响应返回到的客户端有可能是已伪装的客户端。
    
-   无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。
    
-   无法判定请求是来自何方、出自谁手。
    
-   即使是无意义的请求也会照单全收。无法阻止海量请求下的 **DoS** 攻击（Denial of Service，拒绝服务攻击）。
    

虽然使用 HTTP 协议无法确定通信方，但使用 SSL 则可以。 SSL 不仅提供加密处理，而且还使用了一种被称为**证书**的手段， 可用于确定方。

证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。

通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。

另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。

### 无法证明报文完整性，可能已遭篡改

由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack，MITM）。

虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。

提供文件下载服务的 Web 网站也会提供相应的以 PGP（Pretty Good Privacy，完美隐私）创建的数字签名及 MD5 算法生成的散列值。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。 浏览器无法自动帮用户检查。可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。

为了有效防止这些弊端，有必要使用 HTTPS。SSL 提供认证和加密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。

## HTTPS

### 介绍

HTTP + 加密 + 认证 + 完整性保护 = HTTPS

1.  加密：防止通信线路被窃听；
    
2.  认证：确认通信方。
    

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。通常，HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。

![Screen Shot 2021-04-03 at 13.21.24](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2013.21.24.png)

> 1.  SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。
>     
> 2.  TLS 是 SSL 的后续版本，SSL 在 1999 年被更名为 TLS。
>     

### 加密

#### 共享密钥加密

加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。

以共享密钥方式加密时必须将密钥也发给对方，而这样的话如果通信被监听那么密钥就可会落入攻击者之手。

#### 公开密钥加密

公开密钥加密使用一对非对称的密钥。一把叫做私有密钥 （private key），另一把叫做公开密钥（public key）。私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。

使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，就目前的技术来看是不太现实的。

#### 混合加密机制

HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若（共享）密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，处理速度要慢。

所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用**公开密钥**加密方式，之后的建立通信交换报文阶段则使用**共享密钥**加密方式。

![Screen Shot 2021-04-03 at 13.58.22](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2013.58.22.png)

### 证书

遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真正的公开密钥已经被攻击者替换掉了。

为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。

数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。我们来介绍一下数字证书认证机构的业务流程。首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。

服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。

接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。

> 1.  证书主要用于服务端（因为大多数情况下都是用户要确认访问的网站是否安全，而不是网站要确认用户是否安全，除了网上银行这种业务等），客户端在请求服务端的时候，因为要通过公开密钥的方式交换共享密钥，而为了使用公开密钥的方式，要交换双方公开密钥的公钥。服务端发送给客户端公钥证书，客户端从而判断服务端是否安全。
>     
> 2.  公钥加密，私钥解密；私钥签名，公钥验签。[https://zhuanlan.zhihu.com/p/31477508](https://zhuanlan.zhihu.com/p/31477508)
>     
> 3.  针对第一点，HTTPS 中也可以使用客户端证书，作用和服务器证书一样。但会有几个问题：
>     
>     -   用户得付费；
>         
>     -   对安全要求高的业务会替用户付费，比如网上银行。
>         

此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。

> 首先理解证书链，浏览器中存的只有顶层 CA，而顶层 CA 数量很少。在接受到 bilibili 发来的证书之后要向上回溯到最顶层来判断是否合法。如果 CA 的公开密钥不能安全转交给客户端，那么就可能有伪造顶层 CA 证书，然后签发给服务器端，客户端接受到这个服务器端的证书，以为是合法的。

![Screen Shot 2021-04-03 at 15.02.27](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2015.02.27.png)

### HTTPS 安全通信机制

![Screen Shot 2021-04-03 at 14.51.50](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2014.51.50.png)![Screen Shot 2021-04-03 at 14.52.06](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2014.52.06.png)

1.  客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
    
2.  服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
    
3.  之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
    
4.  最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。
    
5.  SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
    
6.  接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
    
7.  客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
    
8.  服务器同样发送 Change Cipher Spec 报文。
    
9.  服务器同样发送 Finished 报文。
    
10.  服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。
    
11.  应用层协议通信，即发送 HTTP 响应。
    
12.  最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。
    

在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的**完整性**。

下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。

![Screen Shot 2021-04-03 at 14.58.22](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2014.58.22.png)

> CBC 模式（Cipher Block Chaining）又名密码分组链接模式。在此模式下，将前一个明文块加密处理后和下一个明文块做 XOR 运算，使之重叠，然后再对运算结果做加密处理。对第一个明文块做加密时，要么使用前一段密文的最后一块， 要么利用外部生成的初始向量（initial vector，IV）。

### 摘要算法

摘要算法来验证数据完整性。

# 确认访问用户身份的认证

HTTP/1.1 使用的认证方式如下。

## BASIC 认证

BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。

![Screen Shot 2021-04-03 at 17.13.58](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-03%20at%2017.13.58.png)

1.  当请求的资源需要 BASIC 认证时，服务器会随状态码 **401 Authorization Required**，返回带 **WWW-Authenticate** 首部字段的响应。 该字段内包含认证的方式（BASIC）及 Request-URI 安全域字符串 （realm）。
    
2.  接收到状态码 401 的客户端为了通过 BASIC 认证，需要将用户 ID 及密码发送给服务器。发送的字符串内容是由用户 ID 和密码构成，两者中间以冒号（:）连接后，再经过 Base64 编码处理。
    
3.  接收到包含首部字段 Authorization 请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含 Request-URI 资源的响应。
    

BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。换言之，由于明文解码后就是用户 ID 和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程 中，如果被人窃听，被盗的可能性极高。另外，除此之外想再进行一次 BASIC 认证时，一般的浏览器却无法实现认证注销操作，这也是问题之一。

BASIC 认证使用上不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，因此它并不常用。

## DIGEST

为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式 （challenge/response），但不会像 BASIC 认证那样直接发送明文密码。

所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。

因为发送给对方的只是响应摘要及由质询码产生的计算结果，所以比起 BASIC 认证，密码泄露的可能性就降低了。

1.  请求需认证的资源时，服务器会随着状态码 **401 Authorization Required**，返回带 **WWW-Authenticate** 首部字段的响应。 该字段内包含质问响应方式认证所需的临时质询码（随机数， nonce）。首部字段 WWW-Authenticate 内必须包含 **realm** 和 **nonce** 这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。
    
    > nonce 是一种每次随返回的 401 响应生成的任意随机字符串。该字 串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。
    
2.  接收到 401 状态码的客户端，返回的响应中包含 DIGEST 认证必须的首部字段 **Authorization** 信息。
    
    首部字段 Authorization 内必须包含 **username**、**realm**、**nonce**、**uri** 和 **response** 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。
    
    -   username 是 realm 限定范围内可进行认证的用户名。
        
    -   uri（digest-uri）即 Request-URI 的值，但考虑到经代理转发后 Request-URI 的值可能被修改，因此事先会复制一份副本保存在 uri 内。
        
    -   response 也可叫做 **Request-Digest**，存放经过 MD5 运算后的密码字符串，形成响应码。
        
3.  接收到包含首部字段 Authorization 请求的服务器，会确认认证信息的正确性。认证通过后则返回包含 Request-URI 资源的响应。并且这时会在首部字段 **Authentication-Info** 写入一些认证成功的相关信息。
    

DIGEST 认证提供了高于 BASIC 认证的安全等级，但是和 HTTPS 的客户端认证相比仍旧很弱。DIGEST 认证提供防止密码被窃听的保护机制，但并不存在防止**用户伪装**的保护机制。

DIGEST 认证和 BASIC 认证一样，使用上不那么便捷灵活，且仍达不到多数 Web 网站对高度安全等级的追求标准。因此它的适用范围也有所受限。

## 基于表单认证

基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。

### 认证多半为基于表单认证

由于使用上的便利性及安全性问题，HTTP 协议标准提供的 BASIC 认证和 DIGEST 认证几乎不怎么使用。另外，SSL 客户端认证虽然具有高度的安全等级，但因为导入及维持费用等问题，还尚未普及。

比如 SSH 和 FTP 协议，服务器与客户端之间的认证是合乎标准规范的，并且满足了最基本的功能需求上的安全使用级别，因此这些协议的认证可以拿来直接使用。但是对于 Web 网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由 Web 应用程序各自实现基于表单的认证方式。

不具备共同标准规范的表单认证，在每个 Web 网站上都会有各不相同的实现方式。如果是全面考虑过安全性能而实现的表单认证，那么就能够具备高度的安全等级。但在表单认证的实现中存在问题的 Web 网站也是屡见不鲜。

### Session 管理及 Cookie 应用

基于表单认证的标准规范尚未有定论，一般会使用 Cookie 来管理 Session。

但鉴于 HTTP 是无状态协议，之前已认证成功的用户状态无法通过协议层面保存下来。即无法实现状态管理，因此即使当该用户下一次 续访问，也无法区分他与其他的用户。于是我们会使用 Cookie 来 管理 Session，以弥补 HTTP 协议中不存在的状态管理功能。

1.  客户端把用户 ID 和密码等登录信息放入报文的实体部分， 通常是以 POST 方法把请求发送给服务器。而这时，会使用 HTTPS 通信来进行 HTML 表单画面的显示和用户输入数据的发送。
    
2.  服务器会发放用以识别用户的 Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与 Session ID 绑定后记录在服务器端。向客户端返回响应时，会在首部字段 **Set-Cookie** 内写入 Session ID（如 PHPSESSID=028a8c...）。
    
    > 然而，如果 Session ID 被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止 Session ID 被盗，或被猜出。为了做到这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。
    > 
    > 另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在 Cookie 内加上 httponly 属性。
    
3.  客户端接收到从服务器端发来的 Session ID 后，会将其作为 Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送 Cookie，所以 Session ID 也随之发送到服务器。服务器端可通过验证接收到的 Session ID 识别用户和其认证状态。
    

## SSL 客户端认证

从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确， 即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。

SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

### 认证步骤

为达到 SSL 客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

1.  接收到需要认证资源的请求，服务器会发送 **Certificate Request** 报文，要求客户端提供客户端证书。
    
2.  用户选择将发送的客户端证书后，客户端会把客户端证书信息以 **Client Certificate** 报文方式发送给服务器。
    
3.  服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信。
    

步骤和服务端证书类似。

### SSL 客户端认证采用双因素认证

在多数情况下，SSL 客户端认证不会仅依靠证书完成认证，一般会和基于表单认证组合形成一种双因素认证（Two-factor authentication）来使用。第一个认证因素的 SSL 客户端证书用来认证客户端计算机， 另一个认证因素的密码则用来确定这是用户本人的行为。

# 基于 HTTP 的功能追加协议

## HTTP 的瓶颈

-   一条连接上只可发送一个请求。
    
-   请求只能从客户端开始。客户端不可以接收除响应以外的指令。
    
-   请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。
    
-   发送冗长的首部。每次互相发送相同的首部造成的浪费较多。
    
-   可任意选择数据压缩格式。非强制压缩发送。
    

![Screen Shot 2021-04-07 at 14.21.32](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-07%20at%2014.21.32.png)

### AJAX 的解决方法

Asynchronous JavaScript and XML， 异步 JavaScript 与 XML 技术是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作，以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比，由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

Ajax 的核心技术是名为 XMLHttpRequest 的 API，通过 JavaScript 脚本语言的调用就能和服务器进行 HTTP 通信。借由这种手段，就能从已加载完毕的 Web 页面上发起请求，只更新局部页面。

而利用 Ajax 实时地从服务器获取内容，有可能会导致大量请求产 生。另外，Ajax 仍**未解决** HTTP 协议本身存在的问题。

### Comet 的解决方法

一旦服务器端有内容更新了，Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。

通常，服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet 会先将响应置于**挂起**状态，当服务器端有内容更新时，再返回该响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。

内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。另外，Comet 也仍**未解决** HTTP 协议本身存在的问题。

![Screen Shot 2021-04-07 at 14.24.45](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-07%20at%2014.24.45.png)

## SPDY

Google 在 2010 年发布了 SPDY（取自 SPeeDY，发音同 speedy），其开发目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间 （50%）。

### 设计

SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。

SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方法、 Cookie 以及 HTTP 报文等。

### 功能

-   多路复用流
    
    通过单一的 TCP 连接，可以无限制处理多个 HTTP 请求。所有请求的处理都在一条 TCP 连接上完成，因此 TCP 的处理效率得到提高。
    
-   赋予请求优先级
    
    SPDY 不仅可以无限制地并发处理请求，还可以给请求逐个分配优先级顺序。这样主要是为了在发送多个请求时，解决因带宽低而导致响应变慢的问题。
    
-   压缩 HTTP 首部
    
    压缩 HTTP 请求和响应的首部，通信产生的数据包数量和发送的字节数就更少了。
    
-   推送功能
    
    支持服务器主动向客户端推送数据的功能。服务器可直接发送数据，而不必等待客户端的请求。
    
-   服务器提示功能
    
    服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求。
    

### SPDY 消除 Web 瓶颈了吗

希望使用 SPDY 时，Web 的内容端不必做什么特别改动，而 Web 浏览器及 Web 服务器都要为对应 SPDY 做出一定程度上的改动。有好几家 Web 浏览器已经针对 SPDY 做出了相应的调整。另外，Web 服务器也进行了实验性质的应用，但把该技术导入实际的 Web 网站却进展不佳。

因为 SPDY 基本上只是将**单个域名**（ IP 地址）的通信多路复用，所以当一个 Web 网站上使用多个域名下的资源，改善效果就会受到限制。

SPDY 的确是一种可**有效消除** HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致。对 Web 本身的速度提升，还应该从其他可细致钻研的地方入手，比如改善 Web 内容的编写方式等。

## 使用浏览器进行全双工通信的 WebSocket

利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度。但问题在于通信若使用 HTTP 协议，就无法彻底解决瓶颈问题。WebSocket 网络技术正是为解决这些问题而实现的一套新协议及 API。

当时筹划将 WebSocket 作为 HTML5 标准的一部分，而现在它却逐渐变成了独立的协议标准。WebSocket 通信协议在 2011 年 12 月 11 日， 被 RFC 6455 - The WebSocket Protocol 定为标准。

### WebSocket 的设计与功能

WebSocket，即 Web 浏览器与 Web 服务器之间全双工通信标准。其中，WebSocket 协议由 IETF 定为标准，WebSocket API 由 W3C 定为标准。仍在开发中的 WebSocket 技术主要是为了解决 Ajax 和 Comet 里 XMLHttpRequest 附带的缺陷所引起的问题。

### WebSocket 协议

一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送 JSON、XML、HTML 或图片等任意格式的数据。由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端， 而一旦确立 WebSocket 通信连接，不论服务器还是客户端，**任意一方**都可直接向对方发送报文。

下面列举 WebSocket 协议的主要特点。

#### 推送功能

支持由服务器向客户端推送数据的推送功能。服务器可直接发送数据，而不必等待客户端的请求。

#### 减少通信量

只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相 比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。

为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一 次 “握手” （Handshaking）的步骤。

##### 握手**·**请求

为了实现 WebSocket 通信，需要用到 HTTP 的 **Upgrade** 首部字段，告知服务器通信协议发生改变，以达到握手的目的。

GET /chat HTTP/1.1  
Host: server.example.com  
Upgrade: websocket  
Connection: Upgrade  
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==   
Origin: http://example.com   
Sec-WebSocket-Protocol: chat, superchat   
Sec-WebSocket-Version: 13

**Sec-WebSocket-Key** 字段内记录着握手过程中必不可少的键值。**Sec-WebSocket-Protocol** 字段内记录使用的子协议。

子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。

##### 握手**·**响应

对于之前的请求，返回状态码 **101 Switching Protocols** 的响应。

HTTP/1.1 101 Switching Protocols  
Upgrade: websocket  
Connection: Upgrade  
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=   
Sec-WebSocket-Protocol: chat

**Sec-WebSocket-Accept** 的字段值是由握手请求中的 **Sec-WebSocket-Key** 的字段值生成的。

成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。

![Screen Shot 2021-04-07 at 14.44.49](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-07%20at%2014.44.49.png)

##### WebSocket API

JavaScript 可调用“The WebSocket API”（[http://www.w3.org/TR/websockets/](http://www.w3.org/TR/websockets/)，由 W3C 标准制定）内提供的 WebSocket 程序接口，以实现 WebSocket 协议下全双工通信。

以下为调用 WebSocket API，每 50ms 发送一次数据的实例。

var socket = new WebSocket('ws://game.example.com:12010 socket.onopen = function () {  
    setInterval(function() {  
        if (socket.bufferedAmount == 0)  
        socket.send(getUpdateData());   
		}, 50);  
};

## HTTP/2.0

目前主流的 HTTP/1.1 标准，自 1999 年发布的 RFC2616 之后再未进行过改订。SPDY 和 WebSocket 等技术纷纷出现，很难断言 HTTP/1.1 仍是适用于当下的 Web 的协议。

负责互联网技术标准的 IETF（Internet Engineering Task Force，互联网工程任务组）创立 httpbis（Hypertext Transfer Protocol Bis，[http://datatracker.ietf.org/wg/httpbis/](http://datatracker.ietf.org/wg/httpbis/)）工作组，其目标是推进下一代 HTTP——HTTP/2.0 在 2014 年 11 月实现标准化。

HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。由于基本上都会先通过 HTTP/1.1 与 TCP 连接，现在我们以下面的这些协议为基础，探讨一下它们的实现方法。

-   SPDY
    
-   HTTPSpeed+Mobility
    
    由微软公司起草，是用于改善并提高移动端 通信时的通信速度和性能的标准。它建立在 SPDY 与 WebSocket 的基础之上。
    
-   Network-Friendly HTTP Upgrade
    
    主要是在移动端通信时改善 HTTP 性 能的标准。
    

HTTP/2.0 围绕着主要的 7 项技术进行讨论，现阶段（2012 年 8 月 13 日），大都倾向于采用以下协议的技术。但是，讨论仍在持续，所以不能排除会发生重大改变的可能性。

![Screen Shot 2021-04-07 at 15.19.30](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-07%20at%2015.19.30.png)

> HTTP Speed + Mobility 简写为 Speed + Mobility，Network-Friendly HTTP Upgrade 简写为 Friendly。

## Web 服务器管理文件的 WebDAV

WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1 的协议定义在 RFC4918。

除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。

![Screen Shot 2021-04-07 at 15.20.43](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-04-07%20at%2015.20.43.png)

使用 HTTP/1.1 的 PUT 方法和 DELETE 方法，就可以对 Web 服务器上的文件进行创建和删除操作。可是出于安全性及便捷性等考虑，一 般不使用。

针对服务器上的资源，WebDAV 新增加了一些概念：

-   集合（Collection）：是一种统一管理多个资源的概念。以集合为单位可进行各种操作。也可实现类似集合的集合这样的叠加。
    
-   资源（Resource）：把文件或集合称为资源。
    
-   属性（Property）：定义资源的属性。定义以 “名称 **=** 值” 的格式执行。
    
-   锁（Lock）：把文件设置成无法编辑状态。多人同时编辑时，可防止在同一时间进行内容写入。
    

### 新增的方法及状态码

WebDAV为实现远程文件管理，向HTTP/1.1中追加了以下这些方法。

-   PROPFIND：获取属性
    
-   PROPPATCH：修改属性
    
-   MKCOL：创建集合
    
-   COPY：复制资源及属性
    
-   MOVE：移动资源
    
-   LOCK：资源加锁
    
-   UNLOCK：资源解锁
    

为配合扩展的方法，状态码也随之扩展。

-   102 Processing：可正常处理请求，但目前是处理中状态
    
-   207 Multi-Status：存在多种状态
    
-   422 Unprocessible Entity：格式正确，内容有误
    
-   423 Locked：资源已被加锁
    
-   424 Failed Dependency：处理与某请求关联的请求失败，因此不再维持依赖关系
    
-   507 Insufficient Storage：保存空间不足
    

### 实例

#### 请求实例

下面是使用 PROPFIND 方法对 [http://www.example.com/file](http://www.example.com/file) 发起获取属性的请求。

PROPFIND /file HTTP/1.1  
Host: www.example.com  
Content-Type: application/xml; charset="utf-8"   
Content-Length: 219  
   
<?xml version="1.0" encoding="utf-8" ?>   
<D:propfind xmlns:D="DAV:">  
	<D:prop xmlns:R="http://ns.example.com/boxschema/">   
		<R:bigbox/>  
		<R:author/>  
		<R:DingALing/>  
    <R:Random/>  
  </D:prop>  
</D:propfind>

#### 响应实例

下面是针对之前的 PROPFIND 方法，返回 [http://www.example.com/file](http://www.example.com/file) 的属性的响应。

HTTP/1.1 207 Multi-Status  
Content-Type: application/xml; charset="utf-8"   
Content-Length: 831  
   
<?xml version="1.0" encoding="utf-8" ?>   
<D:multistatus xmlns:D="DAV:">  
	<D:response xmlns:R="http://ns.example.com/boxschema/">  
		<D:href>http://www.example.com/file</D:href>   
			<D:propstat>  
        <D:prop>  
          <R:bigbox>  
          	<R:BoxType>Box type A</R:BoxType>   
          </R:bigbox>  
          <R:author>  
						<R:Name>J.J. Johnson</R:Name>   
					</R:author>  
			</D:prop>  
			<D:status>HTTP/1.1 200 OK</D:status>   
		</D:propstat>  
		<D:propstat>  
			<D:prop><R:DingALing/><R:Random/></D:prop>   
			<D:status>HTTP/1.1 403 Forbidden</D:status>   
			<D:responsedescription> The user does not have access to th...  
			</D:responsedescription>  
		</D:propstat>  
	</D:response>  
	<D:responsedescription> There has been an access violation erro...   
	</D:responsedescription>  
</D:multistatus>

# C 10 + C 11
