---
tags: 📥️/📚️/🟥️
aliases:
type: book
status: 🟥️
created: 2022-05-05 15-54
updated: 2022-06-01 22-15
---

# Title: [[{ 2021-08 Java 并发编程之美]]

## Metadata
- `Topics:` [[Java]] [[Concurrency]]
- `Title:` [[{ 2021-08 Java 并发编程之美]]
- `Type:` [[{]]
- `Publish Date:` 
- `Reviewed Date:` [[2022-05-05]]

## Note

# 1. 并发编程线程基础

## 1.1 什么是线程

## 1.2 线程创建与运行

### 继承 Thread

1

    public static class MyThread extends Thread {

2

        @Override

3

        public void run() {

4

            System.out.println("I am a child thread");

5

        }

6

    }

7

    public static void main(String[] args){

8

        MyThread thread = new MyThread();

9

        thread.start();

10

    }

调用 start 方法后，线程处于就绪态。

-   使用继承方式的好处是，在 `run()` 方法内获取当前线程直接使用 `this` 就可以了，无须使用 `Thread.currentThread()` 方法；
    
-   不好的地方是 Java 不支持多继承。另外任务与代码没有分离 ， 当多个线程执行一样的任务时需要多份任务代码，而 `Runnable` 则没有这个限制。
    

### 实现 Runnable 接口的 run 方法

1

    public static class RunnableTask implements Runnable {

2

        @Override

3

        public void run() {

4

            System.out.println("I am a child thread");

5

        }

6

    }

7

    public static void main(String[] args){

8

        RunnableTask task = new RunnableTask();

9

        new Thread(task).start();

10

        new Thread(task).start();

11

    }

-   两个线程共用一个 task 代码逻辑，如果需要 ，可以给 RunableTask 添加参数进行任务区分。
    
-   RunableTask 可以继承其他类。
    

### FutureTask

上述两种方法都有一个缺点，任务没有返回值。

	public static class CallerTask implements Callable<String> {  
        @Override  
        public String call() throws Exception {  
            return "hello";  
        }  
    }  
  
    public static void main(String[] args) {  
        // 创建异步任务  
        FutureTask<String> futureTask = new FutureTask<>(new CallerTask());  
        new Thread(futureTask).start();  
        try {  
            // 等待任务执行完毕返回记过  
            String result = futureTask.get();  
            System.out.println(result);  
        } catch (InterruptedException | ExecutionException e) {  
            e.printStackTrace();  
        }  
    }

## 1.3 线程通知与等待

### wait()

调用 `wait()` 方法的线程会被阻塞挂起，直到发生了下面事件之一：

-   其他线程调用了该对象的 notify() 或者 notifyAll() 方法；
    
-   其他线程调用了该线程的 interrupt() 方法，该线程抛出 `InterruptedException` 异常返回。
    
    	static Object obj = new Object();  
      
        public static void main(String[] args) throws InterruptedException {  
            Thread thread = new Thread(() -> {  
                try {  
                    System.out.println("---begin---");  
                    synchronized (obj) {  
                        obj.wait();  
                    }  
                    System.out.println("---end---");  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            });  
            thread.start();  
            Thread.sleep(1000);  
      
            System.out.println("---begin interrupt thread");  
            thread.interrupt();  
            System.out.println("---end interrupt thread");  
        }  
    输出：  
    ---begin---  
    ---begin interrupt thread  
    ---end interrupt thread  
    java.lang.InterruptedException  
    	at java.lang.Object.wait(Native Method)  
    	at java.lang.Object.wait(Object.java:502)  
    	at com.chenghuipeng.learning.ProducerAndCustomer.lambda$main$0(ProducerAndCustomer.java:16)  
    	at java.lang.Thread.run(Thread.java:748)
    

如果调用 wait() 方法的线程没有事先获取该对象的监视器锁，则调用 wait() 方法时调用线程会抛出 `IllegalMonitorStateException` 异常。

获取共享变量监视器锁的方法：

1.  synchronized (共享变量) { doSomething() }
    
2.  调用该共享变量的 synchronized 方法。
    

**虚假唤醒**：一个线程可以从挂起状态变为可以运行状态，即使该线程没有被其他线程调用 notify()、notifyAll() 方法进行通知，或者被中断，或者等待超时。虽然很少发生，但必须要防患于未然：

// 标准形式  
synchronized (obj) {  
    while (被唤醒条件不满足) {  
        obj.wait();  
    }  
}

生产者和消费者的简单例子：

// 生产线程  
synchronized (queue) {  
	//消费队列满，贝1J等待队列空闲  
	while (queue.size() == MAX SIZE) {  
		try {  
			//挂起当前线程， 并释放通过同步块获取的 queue 上的锁，让消费者线程可以获取该锁，然后获取队列里面的元素  
			queue .wait() ;  
		} catch (Exception ex) {  
			ex.pr工ntStackTrace() ;  
        }  
    }  
	//空闲则生成元素 ， 并通知消费者线程  
	queue.add(ele);  
    queue.notifyAll();  
}  
  
// 消费者线程  
synchronized (queue) {  
	//消费队列为空  
	while (queue.size() == 0) {  
		try {  
			//挂起当前线程， 并释放通过同步块获取的 queue 上的锁，让生产者线程可以获取该锁，将生产元素放入队列  
			queue.wait() ;  
		} catch (Exception ex) {  
			ex.pr工ntStackTrace() ;  
        }  
    }  
	//消费元素，并通知唤醒生产者线程  
	queue.take();  
    queue.notifyAll();  
}

线程调用共享变量的 wait() 方法后只会释放当前共享变量上的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放的。

### wait(long timeout)

如果一个线程调用共享对象的该方法挂起后，没有在指定的 `timeout` ms 时间内被其他线程调用该共享变量的 notify() 或者 notifyAll() 方法唤醒，那么该函数还是会因为超时而返回。如果将 timeout 设 置为 0 则和 wait 方法效果 一 样，因为在 wait 方法内部就是调用了 wait(0)。需要注意的是，如果在调用该函数时， 传递了一个负的 timeout 则会抛出 `IllegalArgumentException` 异常。

### wait(long timeout, int nanos)

在其内部调用的是 wait(long timeout) 函数，如下源码只有在 nanos>0 时才使参数 timeout 递增 1。

	public final void wait(long timeout, int nanos) throws InterruptedException {  
        if (timeout < 0) {  
            throw new IllegalArgumentException("timeout value is negative");  
        }  
  
        if (nanos < 0 || nanos > 999999) {  
            throw new IllegalArgumentException("nanosecond timeout value out of range");  
        }  
  
        if (nanos > 0) {  
            timeout++;  
        }  
  
        wait(timeout);  
    }

### notify()

一个线程调用共享对象的 notify() 方法后，会**随机**唤醒一个在该共享变量上调用 wait 系列方法后被挂起的线程。

此外，被唤醒的线程不能马上从 wait 方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回，也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，只有该线程竞争到了共享变量的监视器锁后才可以继续执行。

类似 wait 系列方法，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的 notify() 方法，否则会抛出 `IllegalMonitorStateException` 异常。

### notifyAll()

notifyAll() 方法会唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。

notify() 和 notifyAll() 区别如下。

private static volatile Object resourceA = new Object();    public static void main(String[] args) throws InterruptedException {        Thread threadA = new Thread(() -> {            synchronized (resourceA) {                System.out.println("threadA get resourceA lock");                try {                    System.out.println("threadA begin wait");                    resourceA.wait();                    System.out.println("threadA end wait");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        Thread threadB = new Thread(() -> {            synchronized (resourceA) {                System.out.println("threadB get resourceA lock");                try {                    System.out.println("threadB begin wait");                    resourceA.wait();                    System.out.println("threadB end wait");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        Thread threadC = new Thread(() -> {            synchronized (resourceA) {                System.out.println("threadC begin notify");                resourceA.notify();            }        });        threadA.start();        threadB.start();        Thread.sleep(1000);        threadC.start();        threadA.join();        threadB.join();        threadC.join();        System.out.println("main over");    }输出：threadA get resourceA lockthreadA begin waitthreadB get resourceA lockthreadB begin waitthreadC begin notifythreadA end wait

threadC 的 notify() 随机唤醒了 threadA，threadA 从阻塞转成就绪，并在 threadC 释放锁之后 threadA 获得锁并执行，threadA 释放锁之后，因为 threadB 挂起，所以并不能获得锁。改成 notifyAll() 之后：

输出：threadA get resourceA lockthreadA begin waitthreadB get resourceA lockthreadB begin waitthreadC begin notifythreadB end waitthreadA end waitmain over

需要注意的是，notifyAll() 只能唤醒这个方法被被调用之前因 wait 阻塞的线程。

## 1.4 等待线程执行终止的 join 方法

join 方法可以等待线程执行完毕，该方法是 Thread 类直接提供的无参 void 方法。

	public static void main(String[] args) throws InterruptedException {        Thread threadA = new Thread(() -> {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("threadA over");        });        Thread threadB = new Thread(() -> {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("threadB over");        });        threadA.start();        threadB.start();        System.out.println("wait all child thread over");        threadA.join();        threadB.join();        System.out.println("all child thread over");    }输出：wait all child thread overthreadA overthreadB overall child thread over

主线程调用 threadA.join 之后会被阻塞，等到 threadA 执行完后才会返回。之后调用 threadB.join 再次被阻塞，等待 threadB 执行完成后返回。

> 这里只是为了演示 join 的用法，后面讲到的 CountDownLatch 会更好用。

另外，线程 A 调用线程 B 的 join 方法后会被阻塞，当其他线程调用了线程 A 的 interrupt() 方法中断了线程 A 时，线程 A 会抛出 `InterruptedException` 异常而返回：

	public static void main(String[] args) {        Thread threadA = new Thread(() -> {            System.out.println("threadA run");            while (true) { }        });        Thread mainThread = Thread.currentThread();        Thread threadB = new Thread(() -> {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            mainThread.interrupt();        });        threadA.start();        threadB.start();        try {            threadA.join();        } catch (InterruptedException e) {            System.out.println("main thread: " + e);        }    }

## 1.5 让线程睡眠的 sleep 方法

Thread 类中有一个静态的 sleep方法，当一个执行中的线程调用了 Thread 的 sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与 CPU 的调度，但是该线程所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与 CPU 的调度，获取到 CPU 资源后就可以继续运行了。

如果在睡眠期间其他线程调用了该线程的 interrupt() 方法中断了该线程，则该线程会在调用 sleep 方法的地方抛出 `InterruptedException` 异常而返回 。

> sleep 是阻塞，但没有释放锁；wait 是释放锁才阻塞。

## 1.6 让出 CPU 执行权的 yield 方法

Thread 类中有一个静态的 yield 方法，当一个线程调用 yield 方法时，实际就是在暗示线程调度器当前线程请求让出自己的 CPU 使用，但是线程调度器可以无条件忽略这个暗示。当一个线程调用 yield 方法时，当前线程会让出 CPU 使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出 CPU 的那个线程来获取 CPU 执行权。

一般很少使用这个方法，在调试或者测试时这个方法或许可以帮助复现由于并发竞争条件导致的问题，其在设计并发控制时或许会有用途，后面在讲解 java.util.concurrent.locks 包里面的锁时会看到该方法的使用。

## 1.7 线程中断

Java 中的线程中断是一种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行，而是被中断的线程根据中断状态自行处理。

-   `void interrupt()`：中断线程。只是将线程的中断标志设为 true，线程并没有实际中断，它会继续执行。 如果线程因为调用了 wait 系列函数、 join 方法或者 sleep 方法而被阻塞挂起，这时如果被调用 interrupt() 方法，则该线程会在调用这些方法的地方抛出 InterruptedException 异常。
    
    > 只是设置了中断标志，线程内部实现会根据这个标志来决定做什么，比如下面的两个例子，线程会通过判断中断标志来决定是否退出 while 循环。
    
-   `boolean isInterrupted()`：返回当前线程是否被中断。
    
    // 源码public boolean isInterrupted() {    // 传递 false，表示不清除中断标志。	return isInterrupted(false);}private native boolean isInterrupted(boolean ClearInterrupted);
    
-   `static boolean interrupted()`：返回当前线程是否被中断，如果被中断，则清除中断标志。需要注意的是，该方法是静态方法，内部通过 currentThread() 方法来获取当前调用方法的线程的中断标志，而不是调用方法的实例对象的。
    
    public static boolean interrupted() {    // 传递 true，表示清除中断标志。	return currentThread().isInterrupted(true);}
    

使用 interrupted 退出的例子：

public void run() {	try {        // 书上这里用的是 isInterrupted 方法，感觉不对		while (!Thread.currentThread().interrupted() && more work to do){			// do more work		}	} catch (InterruptedException e) {		// thread was interrupted during sleep or wait	} finally {		// cleanup if required	}}

1.  如果线程被中断，interrupted() 返回 true，第一个条件为 false，跳出循环（interrupted() 也会清除线程的中断标志）；
    
2.  否则，第一个条件返回 true，循环是否继续需要看第二个条件。
    

> `!Thread.currentThread().interrupted()` 其实就是 `!Thread.interrupted()`。
> 
> 看到 `while(!Thread.interrupted())` 就要想到，它的作用是：当前线程中断标志为 true 的时候退出循环，并清除中断标志。

根据中断标志判断线程是否终止的例子：

	public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(() -> {  
            // 如果当前线程没有被设置中断标志  
            while (!Thread.currentThread().isInterrupted()) {  
                System.out.println(Thread.currentThread() + " hello");  
            }  
        });  
  
        thread.start();  
        Thread.sleep(1000);  
        System.out.println("main thread interrupt thread");  
        thread.interrupt();  
  
        thread.join();  
        System.out.println("main is over");  
    }  
输出：  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
main thread interrupt thread  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
main is over

还有一种情况，当线程为了等待一些特定条件的到来时，一般会调用 sleep 函数 、 wait 系列函数或者 join 函数来阻塞挂起当前线程。比如一 个线程调用了 Thread. sleep(3000)，那么调用线程会被阻塞， 直到 3s 后才会从阻塞状态变为激活状态。 但是有可能在 3s 内条件己被满足，如果一 直等到 3s 后 再返回有点浪费时间，这时候可以调用该线程的 interrupt() 方法， 强制 sleep 方法抛出 `InterruptedException` 异常而返回，线程恢复到激活状态。

	public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(() -> {  
            synchronized (resourceA) {  
                try {  
                    System.out.println("enter");  
                    resourceA.wait();  
                } catch (InterruptedException e) {  
                    System.out.println("leave");  
                }  
            }  
        });  
        thread.start();  
        Thread.sleep(1000);  
        thread.interrupt();  
    }  
输出：  
enter  
leave

理解 isInterrupted() 和 interrupted()：

public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(() -> {  
            while (true);  
        });  
        thread.start();  
        thread.interrupt();  
        System.out.println("isInterrupted: " + thread.isInterrupted());  
        System.out.println("isInterrupted: " + thread.interrupted());  
        System.out.println("isInterrupted: " + Thread.interrupted());  
        System.out.println("isInterrupted: " + thread.isInterrupted());  
        thread.join();  
}  
输出：  
isInterrupted: true  
isInterrupted: false  
isInterrupted: false  
isInterrupted: true

## 1.8 理解线程上下文切换

线程上下文切换时机有：

-   当前线程的 CPU 时间使用完处于就绪状态时。
    
-   当前线程被其他线程中断时 。
    

## 1.9 线程死锁

// TODO

## 1.10 守护线程与用户线程

Java 中的线程分为两类，分别为 daemon 线程（守护线程）和 user 线程（用户线程）。在 JVM 启动时会调用 main 函数， main 函数所在的钱程就是一个用户线程，其实在 JVM 内部同时还启动了好多守护线程，比如垃圾回收线程。守护线程和用户线程区别之一是当最后一个非守护线程结束时，JVM 会 正常退出，而不管当前是否有守护线程，就是说守护线程是否结束并不影响 JVM 的退出。换言之，只要有一个用户线程还在运行，JVM 就不会退出。

通过 Thread 的 setDaemon(true) 来创建守护线程。

> main 线程运行结束后，JVM 会自动启动一 个叫作 DestroyJavaVM 的线程，该线程会等待所有用户线程结束后终止 JVM 进程。

## 1.11 ThreadLocal

多钱程访问同一个共享变量时特别容易出现并发问题。为了保证线程安全，一般使用者在访问共享变量时需要进行适当的同步。同步的措施一般是加锁，还有一种方式就是 ThreadLocal，虽然 ThreadLocal 并不是为了解决这个问题而出现的 。

创建一个 ThreadLocal变量后，每个线程都会复制一个变量到自己的本地内存。

### 使用示例

	static void print(String str) {  
        System.out.println(str + ": " + localVar.get());  
	//  localVar.remove();  
    }  
  
    static ThreadLocal<String> localVar = new ThreadLocal<>();  
  
    public static void main(String[] args){  
        Thread threadA = new Thread(()->{  
            localVar.set("threadA local var");  
            print("threadA");		// 1  
            System.out.println("threadA remove after: " + localVar.get());  
        });  
        Thread threadB = new Thread(()->{  
            localVar.set("threadB local var");  
            print("threadB");  
            System.out.println("threadB remove after: " + localVar.get());  
        });  
          
        threadA.start();  
        threadB.start();  
    }  
输出：  
threadA: threadA local var  
threadB: threadB local var  
threadA remove after: threadA local var  
threadB remove after: threadB local var

threadA 和 threadB 都在自己线程内部创建了本地变量，注释 1 的地方，threadA 调用 print 方法，这个方法执行的时候当前线程是 threadA。

打开注释后：

输出：  
threadA: threadA local var  
threadA remove after: null  
threadB: threadB local var  
threadB remove after: null

### 实现原理

![Screen Shot 2021-05-30 at 11.52.00](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-05-30%20at%2011.52.00.png)

`Thread` 类中有一个 `threadLocals` 和一个 `inheritableThreadLocals`，它们都是 `ThreadLocalMap` 类型的变量，而 `ThreadLocalMap` 是一个定制化的 `Hashmap`。在默认情况下，每个线程中的这两个变量都为 `null`，只有当前线程第一次调用 `ThreadLocal` 的 `set` 或者 `get` 方法时才会创建它们。其实每个线程的本地变量不是存放在 `ThreadLocal` 实例里面，而是存放在调用线程的 `threadLocals` 变量里面。也就是说，`ThreadLocal` 类型的本地变量存放在具体的线程内存空间中。`ThreadLocal` 就是一个工具壳，它通过 `set` 方法把 `value` 值放 入调用线程的 `threadLocals` 里面并存放起来，当调用线程调用它的 `get` 方法时，再从当前线程的 `threadLocals` 变量里面将其拿出来使用。如果调用线程一直不终止，那么这个本地变量会一直存放在调用线程的 `threadLocals` 变量里面，所以当不需要使用本地变量时可以通过调用 `ThreadLocal` 变量的 `remove` 方法，从当前线程的`threadLocals` 里面删除该本地变量。另外，`Thread` 里面的 `threadLocals` 为何被设计为 `map` 结构？很明显是因为每个线程可以关联多个 `ThreadLocal` 变量。

> `ThreadLocal` 只是一个工具类，虽然可能多个线程看似都是调用同一个 `ThreadLocal` 变量的 `set()`、`get()` 等方法，但是这些方法内部第一步就是获得当前线程，然后返回当前线程的 `ThreadLocalMap`。

下面是 ThreadLocal 类的源码：

#### void set(T value)

public void set(T value) {  
    // 1. 获取当前线程  
	Thread t = Thread.currentThread();  
    // 2. 将当前线程作为 key，去查找对应的线程变量，找到则设置  
	ThreadLocalMap map = getMap(t);  
	if (map != null)  
		map.set(this, value);  
	else  
        // 3. 第一次调用就创建当前线程对应的 HashMap  
		createMap(t, value);  
}  
  
ThreadLocalMap getMap(Thread t) {  
    // 返回 Thread 类的 threadLocals 变量  
	return t.threadLocals;  
}  
  
void createMap(Thread t, T firstValue) {  
	t.threadLocals = new ThreadLocalMap(this, firstValue);  
}

#### T get()

public T get() {  
	Thread t = Thread.currentThread();  
	ThreadLocalMap map = getMap(t);  
	if (map != null) {  
        // TODO  
		ThreadLocalMap.Entry e = map.getEntry(this);  
		if (e != null) {  
            @SuppressWarnings("unchecked")  
            T result = (T)e.value;  
            return result;  
		}  
	}  
    // threadLocals 为空则初始化当前线程的 threadLocals 成员交量  
	return setInitialValue();  
}  
  
private T setInitialValue() {  
	T value = initialValue();  
	Thread t = Thread.currentThread();  
	ThreadLocalMap map = getMap(t);  
	if (map != null)  
		map.set(this, value);  
	else  
		createMap(t, value);  
	return value;  
}  
  
// 这个方法存在的目的就是统一管理初始值？  
protected T initialValue() {  
	return null;  
}

#### void remove()

public void remove() {  
	ThreadLocalMap m = getMap(Thread.currentThread());  
	if (m != null)  
		m.remove(this);  
}

总结：在每个线程内部都有一个名为 `threadLocals` 的成员变量，该变量的类型为 `HashMap`，其中 `key` 为我们定义的 `ThreadLocal` 变量的 `this` 引用，`value` 则为我们使用 `set` 方法设置的值。每个线程的本地变量存放在线程自己的内存变量 `threadLocals` 中，如果当前线程一直不消亡，那么这些本地变量会一直存在，所以可能会造成内存溢出，因此使用完毕后要记得调用 `ThreadLocal` 的 `remove` 方法删除对应线程的 `threadLocals` 中的本地变量。

### ThreadLocal 不支持继承性

	static ThreadLocal<String> threadLocal = new ThreadLocal<>();  
  
    public static void main(String[] args){  
        threadLocal.set("hello world");  
        Thread thread = new Thread(()->{  
            System.out.println("thread: " + threadLocal.get());  
        });  
        thread.start();  
        System.out.println("main: " + threadLocal.get());  
    }  
输出：  
main: hello world  
thread: null

### InheritableThreadLocal 类

这个类继承自 ThreadLocal，可以让子线程可以访问在父线程中设置的本地变量。

public class InheritableThreadLocal<T> extends ThreadLocal<T> {  
    protected T childValue(T parentValue) {  
        return parentValue;  
    }  
  
    ThreadLocalMap getMap(Thread t) {  
       return t.inheritableThreadLocals;  
    }  
  
    void createMap(Thread t, T firstValue) {  
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);  
    }  
}

重写了 ThreadLocal 的三个方法，主要就是在 Thread 内部用 inheritableThreadLocals 代替 threadLocals。

// Thread 源码  
public Thread(Runnable target) {  
	init(null, target, "Thread-" + nextThreadNum(), 0);  
}  
  
private void init(ThreadGroup g, Runnable target, String name, long stackSize) {  
	init(g, target, name, stackSize, null, true);  
}  
  
private void init(ThreadGroup g, Runnable target, String name, long stackSize,   
                  AccessControlContext acc, boolean inheritThreadLocals) {  
    ...  
    // 在当前线程中创建子线程的时候，将当前线程作为父线程中  
	Thread parent = currentThread();  
	...  
    // inheritThreadLocals 在这里默认为 true  
    // 如果父线程中 inheritableThreadLocals 不为空，则为子线程也创建 inheritableThreadLocals，  
	if (inheritThreadLocals && parent.inheritableThreadLocals != null)  
		this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);  
      
	this.stackSize = stackSize;  
	tid = nextThreadID();  
}  
  
  
// ThreadLocal 源码  
static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {  
	return new ThreadLocalMap(parentMap);  
}  
  
  
// Thread 内部类 ThreadLocalMap 源码  
private ThreadLocalMap(ThreadLocalMap parentMap) {  
	Entry[] parentTable = parentMap.table;  
	int len = parentTable.length;  
	setThreshold(len);  
	table = new Entry[len];  
  
	for (int j = 0; j < len; j++) {  
		Entry e = parentTable[j];  
		if (e != null) {  
			@SuppressWarnings("unchecked")  
			ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();  
			if (key != null) {  
                // 调用了 InheritableThreadLocal 的 childValue 方法，直接返回 e.value  
                Object value = key.childValue(e.value);  
				Entry c = new Entry(key, value);  
				int h = key.threadLocalHashCode & (len - 1);  
				while (table[h] != null)  
					h = nextIndex(h, len);  
                table[h] = c;  
                size++;  
			}  
		}  
	}  
}

总结：

-   InheritableThreadLocal 类通过重写 ThreadLocal 的 getMap 和 createMap 方法让本地变量保存到了具体线程的 inheritableThreadLocals 变量里，那么线程在通过 InheritableThreadLocal 类实例的 set 或者 get 方法设置变量时，就会创建当前线程的 inheritableThreadLocals 变量。
    
-   当父线程创建子线程时，构造函数会把父线程中 inheritableThreadLocals 变量里面的本地变量复制一份保存到子线程的 inheritableThreadLocals 变量里面。
    

那么在什么情况下需要子线程可以获取父线程的 threadlocal 变量呢？比如子线程需要使用存放在 threadlocal 变量中的用户登录信息，再比如一些中间件需要把统一的 id 追踪的整个调用链路记录下来。其实子线程使用父线程中的 threadlocal 方法有多种方式， 比如创建线程时传入父线程中的变量，并将其复制到子线程中，或者在父线程中构造一个 map 作为参数传递给子线程，但是这些都改变了我们的使用习惯，所以在这些情况下 InheritabIeThreadLocal 就显得比较有用 。

# 2. 并发编程的其他基础知识

## 2.1 什么是多线程并发编程

## 2.2 为什么要进行多线程并发编程

## 2.3 Java 中的线程安全问题

线程安全问题是指当多个线程同时读写一个共享资源并且没有任何同步措施时，导致出现脏数据或者其他不可预见的结果的问题。

## 2.4 Java 中共享变量的内存可见性问题

### Java 内存模型

![Screen Shot 2021-06-01 at 23.30.57](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-01%20at%2023.30.57.png)

Java 内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量。Java 内存模型是一个抽象的概念，实际实现中线程的工作内存如下图：

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-01%20at%2023.33.10.png" alt="Screen Shot 2021-06-01 at 23.33.10" style="zoom: 50%;" />

图中所示是一个双核 CPU 系统架构，每个核有自己的控制器和运算器，其中控制器包含 一组寄存器和操作控制器，运算器执行算术逻辅运算。每个核都有自己的一级缓存，在有些架构里面还有一个所有 CPU 都共享的二级缓存。那么 Java 内存模型里面的工作内存，就对应这里的 Ll 或者 L2 缓存或者 CPU 的寄存器。

当一个线程操作共享变量时，它首先从主内存复制共享变量到自己的工作内存，然后对工作内存里的变量进行处理，处理完后将变量值更新到主内存。

那么假如线程 A 和线程 B 同时处理一个共享变量，会出现什么情况？我们使用图 2-5 所示 CPU 架构，假设线程 A 和线程 B 使用不同CPU 执行，并且当前两级 Cache 都为空， 那么这时候由于 Cache 的存在，将会导致内存不可见问题 ， 具体看下面的分析：

1.  线程 A 首先获取共享变量 X 的值，由于两级 Cache 都没有命中，所以加载主内存中 X 的值，假如为 0。然后把 X=0 的值缓存到两级缓存，线程 A 修改 X 的值为 1，然后将其写入两级 Cache，并且刷新到主内存。线程 A 操作完毕后，线程 A 所在的 CPU 的两级 Cache 内和主内存里面的 X 的值都是 1。
    
2.  线程 B 获取 X 的值，首先一级缓存没有命中，然后看二级缓存，二级缓存命中了，所以返回 X=1。到这里一切都是正常的，因为这时候主内存中也是 X=1。然后线程 B 修改 X 的值为 2， 并将其存放到线程 2 所在的一级 Cache 和共享二级 Cache 中，最后更新主内存中 X 的值为 2；到这里一切都是好的。
    
3.  线程 A 这次又需要修改 X 的值，获取时一级缓存命中，并且 X=1，到这里问题就出现了，明明线程 B 已经把 X 的值修改为了 2，为何线程 A 获取的还是 1 呢？这就是共享变量的内存不可见问题，也就是线程 B 写入的值对线程 A 不可见。
    

## 2.5 Java 中的 synchronized 关键字

### 介绍

synchronized 块是 Java 提供的一种原子性内置锁，Java 中的每个对象都可以把它当作一个同步锁来使用，这些 Java 内置的使用者看不到的锁被称为内部锁，也叫作监视器锁。线程的执行代码在进入 synchronized 代码块前会自动获取内部锁，这时候其他线程访问该同步代码块时会被阻塞挂起。拿到内部锁的线程会在正常退出同步代码块或者抛出异常后或者在同步块内调用了该内置锁资源的 wait 系列方法时释放该内置锁。内置锁是排它锁，也就是当一个线程获取这个锁后，其他线程必须等待该线程释放锁后才能获取该锁。

另外，由于 Java 中的线程是与操作系统的原生线程一一对应的，所以当阻塞一个线程时，需要从用户态切换到内核态执行阻塞操作，这是很耗时的操作，而 synchronized 的使用就会导致上下文切换。

### 内存语义

前面介绍了共享变量内存可见性问题主要是由于线程的工作内存导致的，synchronized 的内存语义就可以解决共享变量内存可见性问题。

进入 synchronized 块的内存语义是**把在 synchronized 块内使用到的变量从线程的工作内存中清除**，这样在 synchronized 块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出 synchronized 块的内存语义是**把在 synchronized 块内对共享变量的修改刷新到主内存** 。

其实这也是**加锁和释放锁的语义**，当获取锁后会清空锁块内本地内存中将会被用到的共享变量，在使用这些共享变量时从主内存进行加载，在释放锁时将本地内存中修改的共享变量刷新到主内存。

除可以解决共享变量内存可见性问题外， synchronized 经常被用来实现原子性操作。

## 2.6 Java 中的 volatile 关键字

上面介绍了使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太笨重，因为它会带来线程上下文的切换开销。对于解决内存可见性问题， Java 还提供了一种弱形式的同步，也就是使用 volatile 关键字。该关键字可以确保对一个变量的更新对其他线程马上可见。当一个变量被声明为 volatile 时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。volatile 的内存语义和 synchronized 有相似之处，具体来说就是，当线程写入了 volatile 变量值时就等价于线程退出 synchronized 同步块（把写入工作内存的变量值同步到主内存），读取 volatile 变量值时就相当于进入同步块（先清空本地内存变量值，再从主内存获取最新值）。

如下代码中的共享变量 value 是线程不安全的：

publlc class ThreadNotSafeinteger {  
	private int value;   
      
    public int get() {  
		return value;  
    }  
	public void set(int value) {   
        this.value =value;  
    }  
}

synchronized 关键宇进行同步的方式：

publlc class ThreadNotSafeinteger {  
	private int value;   
      
    public synchronized int get() {  
		return value;  
    }  
	public void set(int value) {   
        this.value =value;  
    }  
}

volatiel 同步的方式：

publlc class ThreadNotSafeinteger {  
	private volatile int value;   
      
    public int get() {  
		return value;  
    }  
	public void set(int value) {   
        this.value =value;  
    }  
}

synchronized 是独占锁，同时只能有一个线程调用 get() 方法，其他调用线程会被阻塞，同时会存在线程上下文切换和线程重新调度的开销，这也是使用锁方式不好的地方。 而 volatie 是非阻塞算法，不会造成线程上下文切换的开销。

但并非在所有情况下使用它们都是等价的，volatile 虽然提供了可见性保证，但并不保证操作的原子性。

那么一般在什么时候才使用 volatile 关键字呢：

-   写入变量值不依赖变量的当前值时。因为如果依赖当前值，将是获取——计算——写入三步操作，这三步操作不是原子性的，而 volatile 不保证原子性。
    
-   读写变量值时没有加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为 volatile 的 。
    

## 2.7 Java 中的原子性操作

所谓原子性操作，是指执行一系列操作时，这些操作要么全部执行，要么全部不执行，不存在只执行其中一部分的情况。 在设计计数器时一般都先读取当前值，然后 +l，再更新。这个过程是读——改——写的过程，如果不能保证这个过程是原子性的，那么就会出现线程安 全问题。如下代码是线程不安全的，因为不能保证 ++value 是原子性操作。

public class ThreadNotSafeCount {  
	private Long value ;  
	publiC Long getCount () {   
        return value ;  
    }  
    public void inc() {  
        ++value ;  
    }  
}

java -c 命令查看汇编代码

public void inc();  
  Code:  
	0: aload 0  
	1: dup  
	2: getfield 		#2  Field value: J  
    5: lconst 1  
	6: ladd  
	7: putfield 		#2  Field value: J  
  10 : return

由此可见，简单的 ++value 由 2、 5、 6、7 四步组成，其中第 2 步是获取当前 value 的值并放入栈顶，第 5 步把常量 1 放入战顶，第 6 步把当前栈顶中两个值相加并把结果放入栈顶，第 7 步则把栈顶的结果赋给 value 变量。因此， Java 中简单的一句 ++value 被转换为汇编后就不具有原子性了 。

那么如何才能保证多个操作的原子性呢?最简单的方法就是使用 synchronized 关键字进行同步，修改代码如下：

public class ThreadNotSafeCount {  
	private Long value ;  
	publiC synchronized Long getCount () {   
        return value ;  
    }  
    public synchronized void inc() {  
        ++value ;  
    }  
}

使用 synchronized 关键宇的确可以实现线程安全性，synchronized 是独占锁，没有获取内部锁的线程会被阻塞掉，而这里的 getCount 方法只是读操作，多个线程同时调用不会存在线程安全问题。但是加了关键宇 synchronized 后，同 一时间就只能有一个线程可以调用，这显然大大降低了并发性。你也许会间，既然是只读 操作，那为何不去掉 getCount 方法上的 synchronized 关键字呢？其实是不能去掉的，因为**这里要靠 synchronized 来实现 value 的内存可见性**。下面讲到的在内部使用非阻塞 CAS 算法实现的原子性操作类 AtomicLong 就是 一个更好的选择。

## 2.8 Java 中的 CAS 操作

使用锁有一个不好的地方，就是当一个线程没有获取到锁时会被阻塞挂起，这会导致线程上下文的切换和重新调度开销。Java 提供了非阻塞的 volatile 关键字来解决共享变量的可见性问题，这在一 定程度上弥补了锁带来的开销问题，但是 volatile 只能保证共享变量的可见性，不能解决读改一写等的原子性问题。 CAS 即 Compare and Swap，是 JDK 提供的非阻塞原子性操作，它通过硬件保证了比较更新操作的原子性。JDK 里面的 Unsafe 类提供了一系列的 compareAndSwap* 方法，下面以 compareAndSwapLong 方法为例进行简单介绍 。

boolean compareAndSwapLong(Object obj, long valueOffset, long expect, long update) 方法：其中 compareAndSwap 的意思是比较并交换。CAS有四个操作数，分别为：对象内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是，如果对象 obj 中内存偏移量为 valueOffset 的变量值为 expect，则使用新的值 update 替换旧的值 expect。这是处理器提供的一个原子性指令。

关于 CAS 操作有个经典的 ABA 问题，具体如下：假如线程 I 使用 CAS 修改初始值为 A 的变量 X，那么线程 I 会首先去获取当前变量 X 的值（为A），然后使用 CAS 操作尝试修改 X 的值为 B，如果使用 CAS 操作成功了，那么程序运行一定是正确的吗？其实未必，这是因为有可能在线程 I 获取变量 X 的值 A 后，在执行 CAS 前，线程 II 使用 CAS 修改了变量 X 的值为 B，然后又使用 CAS 修改了变量 X 的值为 A。 所以虽然线程 I 执行 CAS 时 X 的值是 A，但是这个 A 己经不是线程 I 获取时的 A 了。 这就是 ABA 问题。

ABA 问题的产生是因为变量的状态值产生了环形转换，就是变量的值可以从 A 到 B，然后再从 B 到 A。如果变量的值只能朝着一个方向转换，比如 A 到 B，B 到 C，不构成环 形，就不会存在问题。JDK 中的 AtomicStampedReference 类给每个变量的状态值都配备了一个时间戳， 从而避免了ABA 问题的产生。

## 2.9 Unsafe 类

### Unsafe 类的重要方法

JDK 的 rt.jar 包中的 Unsafe 类提供了硬件级别的原子性操作，Unsafe类中的方法都是 native 方法，它们使用 JNI 的方式访问本地 C++ 实现库。

-   long objectFieldOffset(Field field)：返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该 Unsafe 函数中访问指定字段时使用。如下代码使用 Unsafe 类获取变量 value 在 AtomicLong 对象中的内存偏移。
    
    static{   
        try {  
    		valueOffset = unsafe.obbectFieldOffset  
                (AtomicLong.class.getDeclaredField(”value")) ;  
    	}   
    	catch (Exception ex) {   
            throw new Error(ex);   
    	}  
    }
    
-   int arrayBaseOffset(Class arrayClass)：获取数组中第一个元素的地址。
    
-   int arraylndexScale(Class arrayClass)：获取数组中一个元素占用的字节。
    
-   boolean compareAndSwapLong(Object obj, long offset, long expect, long update)：比较对象 obj 中偏移量为 offset 的变量的值是否与 expect 相等，相等则使用 update 值更新，然后返回 true，否则返回 false。
    
-   public native long getLongvolatile(Object obj, long offset)：获取对象 obj 中偏移量为 offset 的变量对应 volatile 语义的值。
    
-   void putLongVolatile(Object obj, long offset, long value)：设置 obj 对象中 offset 偏移的类型为 long 的 field 的值为 value，支持 volatile 语义。
    
-   void putOrderedLong(Object obj, long offset, long value)：设置 obj 对象中 offset 偏移地址对应的 long 型 field 的值为 value。这是一个有延迟的 putLongVolatile 方法，并且不保证值修改对其他线程立刻可见。只有在变量使用 volatile 修饰并且预计会被意外修改时才使用该方法。
    
-   void park(boolean isAbsolute, long time)：阻塞当前线程，其中参数 isAbsolute 等于 false 且 time 等于 0 表示一直阻塞。time 大于 0 表示等待指定的 time 后阻塞线程会被唤醒，此时这个 time 是个相对时间。如果 isAbsolute 等于 true，并且 time 大于 0，则表示阻塞 的线程到指定的时间点后会被唤醒，这里 time 是个绝对时间，是将某个时间点换算为 ms 后的值。另外，当其他线程调用了当前阻塞线程的 interrupt 方法而中断了当前线程时，当前线程也会返回，而当其他线程调用了 unPark 方法并且把当前线程作为参数时当 前线程也会返回。
    
-   void unpark(Object thread)：唤醒调用 park 后阻塞的线程。
    

下面是 JDK8 新增的函数 ， 这里只列出 Long 类型操作。

-   long getAndSetLong(Object obj, long offset, long update)：获取对象 obj 中偏移量为 offset 的变量 volatile 语义的当前值，并设置变量 volatile 语义的值为 update。
    
    public final long getAndSetLong(Object obj, long offset, long update) {  
        long l;  
        do {  
            l = getLongvolatile(obj, offset); //(1)  
        } while (!compareAndSwapLong(obj , offset , l, update);  
        return l;  
    }
    
    由以上代码可知，首先 (1) 处的 getLongvolatile 获取当前变量的值，然后使用 CAS 原子操作设置新值。这里使用 while 循环是考虑到，在多个线程同时调用的情况下 CAS 失败时需要重试。
    
-   long getAndAddLong(Object obj, long offset, long addValue)：获取对象 obj 中偏移量为 offset 的变量 volatile 语义的当前值，并设置变量值为原始值 +addValue。
    
    public final long getAndAddLong(Object obj, long offset, long addValue) {  
        long l;  
        do {  
            l = getLongvolatile(obj, offset);   
        } while (!compareAndSwapLong(obj , offset , l, l + addValue);  
        return l;  
    }
    

### 如何使用 Unsafe 类

public class TestUnsafe {  
    static final Unsafe unsafe = Unsafe.getUnsafe();  
    static final long stateOffset;  
    private volatile long state = 0;  
  
    static {  
        try {  
            stateOffset = unsafe.objectFieldOffset  
                	(TestUnsafe.class.getDeclaredField("state"));  
        } catch (Exception e) {  
            System.out.println(e.getLocalizedMessage());  
            throw new Error(e);  
        }  
    }  
  
    public static void main(String[] args) {  
        TestUnsafe test = new TestUnsafe();  
        Boolean success = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);  
        System.out.println(success);  
    }  
}  
  
输出：  
Exception in thread "main" java.lang.ExceptionInInitializerError  
Caused by: java.lang.SecurityException: Unsafe  
	at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)  
	at com.chenghuipeng.learning.TestUnsafe.<clinit>(TestUnsafe.java:7)

getUnsafe() 方法报错，查看源码：

 	@CallerSensitive  
    public static Unsafe getUnsafe() {  
        Class var0 = Reflection.getCallerClass();		// 1  
        if (!VM.isSystemDomainLoader(var0.getClassLoader())) {		// 2  
            throw new SecurityException("Unsafe");  
        } else {  
            return theUnsafe;  
        }  
    }  
	  
	// 3. 判断 paramClassLoader 是不是 Bootstrap 类加载器  
	public static boolean isSystemDomainLoader  
        					(ClassLoader paramClassLoader) {  
        return paramClassLoader == null;  
    }

1.  获取调用 getUnsafe 这个方法的对象的 Class 对象；
    
2.  判断是不是 Bootstrap 类加载器加载的 localClass，在这里是看是不是 Bootstrap 加载器加载了 TestUnSafe.class。很明显由于 TestUnSafe.class 是使用 AppClassLoader 加载的 ，所以这里直接抛出了异常。
    
    > Unsafe 类是 rt.jar 包提供的，rt.jar 包里面的类是使用 Bootstrap 类加载器加载的，而我们的启动 main 函数所在的类是使用 AppC!assLoader 加载的，所以在 main 函数里面加载 Unsafe 类时，根据委托机制，会委托给 Bootstrap 去加载 Unsafe 类。
    > 
    > 因为 Unsafe 类可以直接操作内存，所以做了此限制。
    

可以通过反射来获取 Unsafe 实例：

  
public class TestUnsafe {  
    static final Unsafe unsafe;  
    static final long stateOffset;  
    private volatile long state = 0;  
  
    static {  
        try {  
            Field field = Unsafe.class.getDeclaredField("theUnsafe");  
            field.setAccessible(true);  
            unsafe = (Unsafe) field.get(null);  
            stateOffset = unsafe.objectFieldOffset  
                		(TestUnsafe.class.getDeclaredField("state"));  
        } catch (Exception e) {  
            System.out.println(e.getLocalizedMessage());  
            throw new Error(e);  
        }  
    }  
  
    public static void main(String[] args) {  
        TestUnsafe test = new TestUnsafe();  
        Boolean success = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);  
        System.out.println(success);  
    }  
}  

## 2.10 Java 指令重排序

Java 内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。在单线程下重排序可以保证最终执行的结果与程序顺序执行的结果一致，但是在多线程下就会存在问题。

int a = 1;		(1)  
int b = 2;		(2)  
int c = a + b;	(3)

在如上代码中，变量 c 的值依赖 a 和 b 的值，所以重排序后能够保证 (3) 的操作在 (2) (1) 之后，但是 (1) (2) 谁先执行就不一定了，这在单线程下不会存在问题。

	private static int num = 0;  
    private static boolean ready = false;  
  
	public static class ReadThread extends Thread{  
        @Override  
        public void run() {  
            while (!Thread.currentThread().isInterrupted()) {  
                if (ready) {		// (1)  
                    System.out.println(num + num);		// (2)  
                }  
                System.out.println("read thread...");  
            }  
        }  
    }  
    public static class WriteThread extends Thread {  
        @Override  
        public void run() {  
            num = 2;				// (3)  
            ready = true;			// (4)  
            System.out.println("write thread set over...");  
        }  
    }  
  
    public static void main(String[] args) throws InterruptedException {  
        ReadThread rt = new ReadThread();  
        rt.start();  
        WriteThread wt = new WriteThread();  
        wt.start();  
  
        Thread.sleep(10);  
        rt.interrupt();  
        System.out.println("main exit");  
    }

首先这段代码里面的变量没有被声明为 volatile 的，也没有使用任何同步措施，所以在多线程下存在共享变量内存可见性问题。这里先不谈内存可见性问题，因为通过把变量声明为 volatile 的本身就可以避免指令重排序问题。

这里先看看指令重排序会造成什么影响，如上代码在不考虑内存可见性问题的情况下一定会输出 4？答案是不一定，由于代码 (1) (2) (3) (4) 之间不存在依赖关系，所以写线程的代码 (3) (4) 可能被重排序为先执行 (4) 再执行 (3)，那么执行 (4) 后，读线程可能已经执行了 (1) 操作，并且在 (3) 执行前开始执行 (2) 操作，这时候输出结果为 0 而不是 4。

重排序在多线程下会导致非预期的程序执行结果，而使用 volatile 修饰 ready 就可以避免重排序和内存可见性问题：

-   写 volatile 变量时，可以确保 volatile 写之前的操作不会被编译器重排序到 volatile 写之后。
    
-   读 volatile 变量时，可以确保 volatile 读之后的操作不会被编译器重排序到 volatile 读之前。
    

## 2.11 伪共享

### 什么是伪共享

为了解决计算机系统中主内存与 CPU 之间运行速度差问题，会在 CPU 与主内存之间添加一级或者多级高速缓冲存储器（Cache）。这个 Cache 一般是被集成到 CPU 内部的，所以也叫 CPU Cache，下图所示是两级 Cache 结构。

![Screen Shot 2021-06-04 at 23.42.54](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-04%20at%2023.42.54.png)

在 Cache 内部是按行存储的，其中每一行称为一个 Cache 行。Cache行（如下图所示）是 Cache 与主内存进行数据交换的单位，Cache 行的大小一般为 2 的幂次数字节。

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-04%20at%2023.43.44.png" alt="Screen Shot 2021-06-04 at 23.43.44" style="zoom:50%;" />

当 CPU 访问某个变量时，首先会去看 CPU Cache 内是否有该变量，如果有则直接从中获取，否则就去主内存里面获取该变量，然后把该变量所在内存区域的**一个 Cache 行大小的内存**复制到 Cache 中。由于存放到 Cache 行的是内存块而不是单个变量，所以可能会把多个变量存放到一个 Cache 行中。当多个线程同时修改一个缓存行里面的多个变量时，由于同时只能有 一个线程操作缓存行，所以相比将每个变量放到一个缓存行，性能会有所下降，这就是伪共享，如下图所示。

![Screen Shot 2021-06-04 at 23.46.01](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-04%20at%2023.46.01.png)

在该图中，变量 x 和 y **同时**被放到了 CPU 的一级和二级缓存，对变量 x 进行更新时，首先会修改 CPU1 的一级缓存变量 x 所在的缓存行，这时候在缓存一致性协议下，CPU2 中变量 x 对应的缓存行失效。那么线程 2 在写入变量 x 时就只能去二级缓存里查找，这就破坏了一级缓存。而一级缓存比二级缓存更快，这也说明了多个线程不可能同时去修改自己所使用的 CPU 中相同缓存行里面的变量。更坏的情况是，如果 CPU 只有一级缓存，则会导致频繁地访问主内存 。

### 为何出现伪共享

伪共享的产生是因为多个变量被放入了一个缓存行中，并且多个线程同时去写入缓存行中不同的变量。那么为何多个变量会被放入一个缓存行呢？其实是因为缓存与内存交换数据的单位就是缓存行，当 CPU 要访问的变量没有在缓存中找到时，根据程序运行的局部性原理，会把该变量所在内存中大小为缓存行的内存放入缓存行。

long a;	long b;	long c;	long d;

如上代码声明了四个 long 变量，假设缓存行的大小为 32 字节，那么当 CPU 访问变量 a 时， 发现该变量没有在缓存中，就会去主内存把变量 a 以及内存地址附近的 b、c、d 放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中。当创建数组时，数组里面的多个元素就会被放入同一 个缓存行。那么在单线程下多个变量被放入同一个缓存行对性能有影响吗？其实在正常情况下单线程访问时将数组元素放入一个或者多个缓存行对代码执行是有利的，因为数据都在缓存中，代码执行会更快，请对比下面代码的执行。

public class TestForContent {  
	static final int LINE NUM = 1024;  
	static final int COLUM NUM = 1024;  
      
	public static VOid main (String [] args) {  
		long [][] array = new long [LINE_NUM][COLUM_NUM);  
		long startTime = System.currentTimeMillis();   
        for(int i = 0; i< LINE_NUM; ++i){  
			for(int j = 0; j < COLUM_NUM; ++j){   
                array[i][j] = i * 2 + j;  
            }  
        }  
		long endTime = System.currentTimeMillis();   
		long cacheTime = endTime - startTime;  
		System.out.println("cache time :” + cacheTime);  
	}  
}

public class TestForContent2 {  
	static final int LINE NUM = 1024;  
	static final int COLUM NUM = 1024;  
      
	public static VOid main (String [] args) {  
		long [][] array = new long [LINE_NUM][COLUM_NUM);  
		long startTime = System.currentTimeMillis();   
        for(int i = 0; i < COLUM_NUM; ++i){  
			for(int j = 0; j < System; ++j){   
                array[j][i] = i * 2 + j;  
            }  
        }  
		long endTime = System.currentTimeMillis();   
		long cacheTime = endTime - startTime;  
		System.out.println("cache time :” + cacheTime);  
	}  
}

代码 (1) 比代码 (2) 执行得快，这是因为数组内数组元素的内存地址是连续的，当访问数组第一个元素时，会把第一个元素后的若干元素一块放入缓存行，这样顺序访问数组元素时会在缓存中直接命中，因而就不会去主内存读取了，后续访问也是这样。也就是说，当顺序访问数组里面元素时，如果当前元素在缓存没有命中，那么会从主内存一下子读取后续若干个元素到缓存，也就是一次内存访问可以让后面多次 访问直接在缓存中命中。而代码 (2) 是跳跃式访问数组元素的，不是顺序的，这破坏了程序访问的局部性原则，并且缓存是有容量控制的，当缓存满了时会根据一定淘汰算法替换缓存行，这会导致从内存置换过来的缓存行的元素还没等到被读取就被替换掉了。

所以在单个线程下顺序修改一个缓存行中的多个变量，会充分利用程序运行的局部性原则，从而加速了程序的运行。而在多线程下并发修改一个缓存行中的多个变量时就会竞争缓存行，从而降低程序运行性能 。

### 如何避免伪共享

#### 字节填充

JDK 8 之前一般都是使用字节填充的方式。创建一个变量时使用填充字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同一个缓存行中，例如如下代码：

public final static class FilledLong {  
    public volatile long value = 0L;  
    public long p1, p2, p3, p4, p5, p6;  
}

假如缓存行为 64 宇节，那么我们在 FilledLong 类里面填充了 6 个 long 类型的变量，每个 long 类型变量占用 8 字节，加上 value 变量的 8 字节总共 56 字节。另外，这里 FilledLong 是一个类对象，而类对象的**字节码的对象头占用 8 字节**，所以一个 FilledLong 对象实际会占用 64 字节的内存，这正好可以放入一个缓存行。

#### 注解

JDK 8 提供了一个 sun.misc.Contended 注解，用来解决伪共享问题。将上面代码修改为如下。

@sum.misc.Contended  
public final static class FilledLong {  
    public volatile long value = 0L;  
}

在这里注解用来修饰类，也可以修饰变量，比如在 Thread类中。

/** The current seed for a ThreadLocalRandom */  
@sun.misc.Contended("tlr")  
long threadLocalRandomSeed;  
  
/** Probe hash value; nonzero if threadLocalRandomSeed initialized */  
@sun.misc.Contended("tlr")  
int threadLocalRandomProbe;  
  
/** Secondary seed isolated from public ThreadLocalRandom sequence */  
@sun.misc.Contended("tlr")  
int threadLocalRandomSecondarySeed;

> Thread 类里面这三个变量默认被初始化为 0，并会在 ThreadLocalRandom 类中使用。

需要注意的是，在默认情况下，@Contended 注解只用于 Java 核心类， 比如此包下的 类。如果用户类路径下的类需要使用这个注解，则需要添加 JVM 参数：`-XX:-RestrictContended`。填充的宽度默认为 128，要自定义宽度则可以设置 `-XX:ContendPaddingWidth` 参数

## 2.12 锁的概述

### 悲观锁和乐观锁

悲观锁和乐观锁是在数据库中引入的名词，并发包锁里也引入了类似的思想。

-   悲观锁的实现一般依靠数据库提供的锁机制。
    
-   乐观锁并不会使用数据库提供的锁机制，一般在表中添加 version 字段或使用业务状态来实现。乐观锁直到提交时才锁定，所以不会产生任何死锁。
    

### 公平锁和非公平锁

-   公平锁：ReentrantLock pairLock = new ReentrantLock(true)。
    
-   非公平锁：ReentrantLock pairLock = new ReentrantLock(false)。默认构造函数是非公平锁。
    

没有公平性需求的情况尽量使用非公平锁，因为公平锁会带来性能开销。

### 独占锁和共享锁

-   独占锁：ReentrantLock。
    
-   非独占锁：ReadWriteLock。
    

独占锁是一种悲观锁，而共享锁是一种乐观锁，允许多个线程同时进行读操作。

### 可重入锁

synchronized 内部锁是可重入锁。可重入锁的原理是在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为 0，说明该锁没有被任何线程占用。当一个钱程获取了该锁时，计数器的值会变成 1，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。

但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加 +1，当释放锁后计数器值 -1。当计数器值为 0 时，锁里面的线程标示被重置为 null，这时候被阻塞的线程会被唤醒来竞争获取该锁 。

### 自旋锁

由于 Java 中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。

自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃 CPU 使用权的情况下，多次尝试获取（默认次数是 10，可以使用 -XX:PreBlockSpinsh 参数设置该值），很有可能在后面几次尝试中其他线程已经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来自旋锁是使用 CPU 时间换取线程阻塞与调度的开销，但是很有可能这些 CPU 时间白白浪费了。

# 3. ThreadLocalRandom 类

## 3.1 Random 类及其局限性

随机数的生成需要一个默认的种子，这个种子其实是一个 long 类型的数字，可以在创建 Random 对象时通过构造函数指定，如果不指定则在默认构造函数内部生成一个默认的值。 有了默认的种子后，如何生成随机数呢？

	public int nextInt(int bound) {  
        if (bound <= 0)  
            throw new IllegalArgumentException(BadBound);  
		  
        // 1. 根据老的种子生成新的种子  
        int r = next(31);  
        int m = bound - 1;  
          
        // 2. 下面所有是根据新的种子计算随机数  
        if ((bound & m) == 0)  // i.e., bound is a power of 2  
            r = (int)((bound * (long)r) >> 31);  
        else {  
            for (int u = r;  
                 u - (r = u % bound) + m < 0;  
                 u = next(31));  
        }  
        return r;  
    }

在单线程情况下每次调用 nextInt 都是根据老的种子计算出新的种子，这是可以保证随机数产生的随机性的。但是在多线程下多个线程可能都拿同一个老的种子去执行步骤 (1) 以计算新的种子，这会导致多个线程产生的新种子是一样的，由于步骤 (2) 的算法是固定的，所以会导致多个线程产生**相同的随机值**。所以步骤 (1) 要保证原子性，也就是说当多个线程根据同一个老种子计算新种子时，第一个线程的新种子被计算出来后，第二个线程要丢弃自己老的种子，而使用第 一 个线程的新种子来计算自己的新种子，这样才能保证在多线程下产生的随机数是随机的。

Random 函数使用一个原子变量达到了这个效果，在创建 Random 对象时初始化的种子就被保存到了种子原子变量里面，下面看 next() 的代码。

	protected int next(int bits) {  
        long oldseed, nextseed;  
        AtomicLong seed = this.seed;  
        do {  
            // 3.   
            oldseed = seed.get();  
            // 4.   
            nextseed = (oldseed * multiplier + addend) & mask;  
            // 5.    
        } while (!seed.compareAndSet(oldseed, nextseed));  
        // 6.  
        return (int)(nextseed >>> (48 - bits));  
    }

代码 (3) 获取当前原子变量种子的值。

代码 (4) 根据当前种子值计算新的种子。

代码 (5) 使用 CAS 操作，它使用新的种子去更新老的种子，在多线程下可能多个线程都同时执行到了代码 (3)，那么可能多个线程拿到的当前种子的值是同一个，然后执行步骤 (4) 计算的新种子也都是一样的，但是步骤 (5) 的 CAS 操作会保证只有一个线程可以更新老的种子为新的 ，失败的线程会通过循环重新获取更新后的种子作为当前种子去计算老的种子，这就解决了上面提到的问题，保证了随机数的随机性。

代码 (6) 使用固定算法根据新的种子计算随机数。

总结：每个 Random 实例里面都有一个原子性的种子变量用来记录当前的种子值，当要生成新的随机数时需要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个 Random 实例生成随机数时，当多个线程同时计算随机数来计算新的种子时，多个线程会竞争同一个原子变量的更新操作，由于原子变量的更新是 CAS 操作，同时只有一个线程会成功，所以会造成大量线程进行自旋重试，这会降低并发性能。

## 3.2 ThreadLocalRandom

使用 `ThreadLocalRandom.current()` 来获取当前线程的随机数生成器。ThreadLocalRandom 的实现原理和 ThreadLocal 类似。每个线程都维护一个种子变量，则每个线程生成随机数时都根据自己老的种子计算新的种子，并使用新种子更新老的种子，再根据新种子计算随机数，就不会存在竞争问题了，这会大大提高并发性能。

![Screen Shot 2021-06-05 at 10.45.02](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-05%20at%2010.45.02.png)

## 3.3 源码

![Screen Shot 2021-06-05 at 10.45.40](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-05%20at%2010.45.40.png)

ThreadLocalRandom 类继承了 Random 类并重写了 nextlnt 方法，在 ThreadLocalRandom 类中并没有使用继承自 Random 类的原子性种子变量。在 ThreadLocalRandom 中并没有存放具体的种子，具体的种子存放在具体的调用线程的 `threadLocalRandomSeed` 变量里面。 ThreadLocalRandom 类似于 ThreadLocal 类，就是个工具类。当线程调用 ThreadLocalRandom 的 current() 方法时，ThreadLocalRandom 负责初始化调用线程的 threadLocalRandomSeed 变量，也就是初始化种子。

当调用 ThreadLocalRandom 的 nextlnt 方法时，实际上是获取当前线程的 `threadLocalRandomSeed` 变量作为当前种子来计算新的种子，然后更新新的种子到当前线程的 threadLocalRandomSeed 变量，而后再根据新种子并使用具体算法计算随机数。这里需要注意的是，threadLocalRandomSeed 变量只是 Thread 类里面的一个普通 long 变量，它并不需要是原子性变量。

其中 seeder 和 probeGenerator 是两个原子性变量，在初始化调用线程的种子和探针变量时会用到它们， 每个线程只会使用一次。

另外，变量 instance 是 ThreadLocalRandom 的一个实例，该变量是 static 的。当多线程通过 ThreadLocalRandom 的 current 方法获取 ThreadLocalRandom 的实例时，**其实获取的是同一个实例。**但**是由于具体的种子是存放在线程里面的**，所以在 ThreadLocaIRandom 的实例里面只包含与线程无关的通用算法， 所以它是线程安全的。

### Unsafe 机制

	// Unsafe mechanics  
    private static final sun.misc.Unsafe UNSAFE;  
    private static final long SEED;  
    private static final long PROBE;  
    private static final long SECONDARY;  
    static {  
        try {  
            // 获取 Unsafe 实例  
            UNSAFE = sun.misc.Unsafe.getUnsafe();  
            Class<?> tk = Thread.class;  
            /*  
            分别获取 Thread 类里面 threadLocalRandomSeed、threadLocalRandomProbe  
            和 threadLocalRandomSecondarySeed 变量在 Thread 实例里面的偏移量  
            */  
            SEED = UNSAFE.objectFieldOffset  
                (tk.getDeclaredField("threadLocalRandomSeed"));  
            PROBE = UNSAFE.objectFieldOffset  
                (tk.getDeclaredField("threadLocalRandomProbe"));  
            SECONDARY = UNSAFE.objectFieldOffset  
                (tk.getDeclaredField("threadLocalRandomSecondarySeed"));  
        } catch (Exception e) {  
            throw new Error(e);  
        }  
    }

### ThreadLocalRandom current() 方法

该方法获取 ThreadLocalRandom 实例，并初始化调用线程中的 threadLocalRandomSeed 和 threadLocalRandomProbe 变量。

	static final ThreadLocalRandom instance = new ThreadLocalRandom();  
  
	public static ThreadLocalRandom current() {  
        // 1.  
        if (UNSAFE.getInt(Thread.currentThread(), PROBE) == 0)  
            // 2.  
            localInit();  
        // 3.  
        return instance;  
    }  
  
	static final void localInit() {  
        int p = probeGenerator.addAndGet(PROBE_INCREMENT);  
        int probe = (p == 0) ? 1 : p; // skip 0  
        long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));  
        Thread t = Thread.currentThread();  
        UNSAFE.putLong(t, SEED, seed);  
        UNSAFE.putInt(t, PROBE, probe);  
    }

在如上代码 (1) 中，如果当前线程中 threadLocalRandomProbe 的变量值为 0（默认情况下线程的这个变量值为 0），则说明当前线程是第一次调用 ThreadLocalRandom 的 current 方法，那么就需要调用 locallnit方法计算当前线程的初始化种子变量（延迟初始化）。

代码 (2) 首先根据 probeGenerator 计算当前线程中 threadLocalRandomProbe 的初始化值，然后根据 seeder 计算当前线程的初始化种子，而后把这两个变量设置到当前线程。 代码 (3) 返回 ThreadLocalRandom 的实例。这个方法是静态方法，多个线程返回的是同一个 ThreadLocalRandom 实例。

### int nextInt(int bound) 方法

计算当前线程的下一个随机数。

	public int nextInt(int bound) {  
        if (bound <= 0)  
            throw new IllegalArgumentException(BadBound);  
        // 根据当前线程中的种子计算新种子  
        int r = mix32(nextSeed());  
        // 根据新种子和 bound 计算随机数  
        int m = bound - 1;  
        if ((bound & m) == 0) // power of two  
            r &= m;  
        else { // reject over-represented candidates  
            for (int u = r >>> 1;  
                 u + m - (r = u % bound) < 0;  
                 u = mix32(nextSeed()) >>> 1)  
                ;  
        }  
        return r;  
    }

如上代码的逻辑步骤与 Random 相似，重点看 nextSeed() 方法：

	final long nextSeed() {  
        Thread t; long r; // read and update per-thread seed  
        UNSAFE.putLong(t = Thread.currentThread(), SEED,  
                       r = UNSAFE.getLong(t, SEED) + GAMMA);  
        return r;  
    }

首先使用 r = UNSAFE.getLong(t, SEED) 获取当前线程中 threadLocalRandomSeed 变量的值，然后在种子的基础上累加 GAMMA 值作为新种子，而后使用 UNSAFE 的 putLong 方法把新种子放入当前线程的 threadLocalRandomSeed 变量中。

# 4. 原子操作类

## 4.1 原子变量操作类

`AtomicLong` 是原子性递增或者递减类，其内部使用 `Unsafe` 来实现。

public class AtomicLong extends Number implements java.io.Serializable {  
    private static final long serialVersionUID = 1927816293512124184L;  
  
    private static final Unsafe unsafe = Unsafe.getUnsafe();  
    private static final long valueOffset;  
  
    // 判断 JVM 是否支持 Long 类型无锁 CAS  
    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();  
    private static native boolean VMSupportsCS8();  
  
    static {  
        try {  
            valueOffset = unsafe.objectFieldOffset  
                (AtomicLong.class.getDeclaredField("value"));  
        } catch (Exception ex) { throw new Error(ex); }  
    }  
  
    private volatile long value;  
  
    public AtomicLong(long initialValue) {  
        value = initialValue;  
    }  
    ...  
}

`value` 被声明为 `volatile` 的，这是为了在多线程下保证内存可见性，`value` 是具体存放计数的变量。

### 主要函数

#### 递增和递减

	public final long getAndIncrement() {  
        return unsafe.getAndAddLong(this, valueOffset, 1L);  
    }  
	public final long getAndDecrement() {  
        return unsafe.getAndAddLong(this, valueOffset, -1L);  
    }  
  
	public final long incrementAndGet() {  
        return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;  
    }  
    public final long decrementAndGet() {  
        return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L;  
    }

上述方法都是通过调用 `Unsafe` 的 `getAndAddLong` 方法实现的，这个方法是原子性操作。

其中 `getAndIncrement` 在 JDK7 中的实现逻辑为：

	public final long getAndIncrement() {  
        while (true) {  
            long current = get();  
            long next = current + 1;  
            if (compareAndSet(current, next))  
                return current;  
        }  
    }

JDK8 中将这个循环逻辑已经被 `Unsafe` 内置了，提高复用性。

	// Unsafe  
	public final long getAndAddLong(Object var1, long var2, long var4) {  
        long var6;  
        do {  
            var6 = this.getLongVolatile(var1, var2);  
        } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));  
  
        return var6;  
    }

#### boolean compareAndSet(long expect, long update)

如果原子变量中的 value 值等于 expect，则使用 update 值更新该值并返回 true，否则返回 false。

	public final boolean compareAndSet(long expect, long update) {  
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);  
    }

`Unsafe` 的 `compareAndSwapLong` 是个 native 方法。

AtomicLong 这些原子操作都使用了 CAS 非阻塞算法，性能比 synchronzied 等阻塞算法好，但是在高并发情况下还是会存在性能问题。

## 4.2 JDK 8 新增的原子操作类 LongAdder

### 简单介绍

在高并发下使用 `AtomicLong` 时，大量线程会同时竞争同一个原子变量。

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-06%20at%2013.40.10.png" alt="Screen Shot 2021-06-06 at 13.40.10" style="zoom:50%;" />

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-06%20at%2013.39.36.png" alt="Screen Shot 2021-06-06 at 13.39.36" style="zoom: 36.6%;" />

使用 `LongAdder` 时，是在内部维护多个 `Cell` 变量，每个 `Cell` 里面有一 个初始值为 0 的 long 型变量 ，这样，在同等并发量的情况下，争夺单个变量更新操作的线程量会减少。另外，多个线程在争夺同一个 `Cell` 原子变量时如果失败了，它并不是在当前 `Cell` 变量上一直自旋 CAS 重试，而是尝试在其他 Cell 的变量上进行 CAS 尝试，这个改变增加了当前线程重试 CAS 成功的可能性。最后，在获取 `LongAdder` 当前值时， 是把所有 `Cell` 变量的 value值累加后再加上 `base` 返回的。

`LongAdder` 维护了一个延迟初始化的原子性更新数组（因为 `Cells` 占用的内存是相对比较大的。默认情况下 `Cell` 数组是 null）和一个基值变量 `base`。

当一开始判断 `Cell` 数组是 null 并且并发线程较少时，所有的累加操作都是对 `base` 变量进行的。保持 `Cell` 数组的大小为 2 的 N 次方，在初始化时 `Cell` 数组中的 `Cell` 元素个数为 2，数组里面的变量实体是 `Cell` 类型。`Cell` 类型是 `AtomicLong` 的一个改进，用来减少缓存的争用，也就是解决伪共享问题 。

对于大多数孤立的多个原子操作进行字节填充是浪费的，因为原子性操作都是无规律地分散在内存中的（也就是说多个原子性变量的内存地址是不连续的），多个原子变量被放入同一个缓存行的可能性很小。但是原子性数组元素的内存地址是连续的，所以数组内的多个元素能经常共享缓存行，因此这里使用 `@sun.misc.Contended` 注解对 `Cell` 类进行字节填充，这防止了数组中多个元素共享一个缓存行，在性能上是一 个提升 。

### 源码

#### LongAdder 结构

![Screen Shot 2021-06-06 at 13.46.18](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-06%20at%2013.46.18.png)

`LongAdder` 类继承自 `Striped64` 类，在 `Striped64` 内部维护着三个变量。

-   `LongAdder` 的真实值其实是 `base` 的值与 `Cell` 数组里面所有 `Cell` 元素中的 `value` 值的累加， `base` 是个基础值，默认为 0。
    
-   `cellsBusy` 用来实现自旋锁，状态值只有 0 和 1，当创建 `Cell` 元素， 扩容 `Cell` 数组或者初始化 `Cell` 数组时，使用 CAS 操作该变量来保证同时只有一个线程可以进行其中之一的操作。
    

`Cell` 构造：

	// Striped64  
	@sun.misc.Contended static final class Cell {  
        volatile long value;  
        Cell(long x) { value = x; }  
        final boolean cas(long cmp, long val) {  
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);  
        }  
  
        // Unsafe mechanics  
        private static final sun.misc.Unsafe UNSAFE;  
        private static final long valueOffset;  
        static {  
            try {  
                UNSAFE = sun.misc.Unsafe.getUnsafe();  
                Class<?> ak = Cell.class;  
                valueOffset = UNSAFE.objectFieldOffset  
                    (ak.getDeclaredField("value"));  
            } catch (Exception e) {  
                throw new Error(e);  
            }  
        }  
    }

可以看到， `Cell` 的构造很简单，其内部维护一个被声明为 `volatile` 的变量，这里声明为 `volatile` 是因为线程操作 `value` 变量时没有使用锁， 为了保证变量的内存可见性这里将其声明为 `volatile` 的。另外 cas 函数通过 CAS 操作，保证了当前线程更新时被分配的 `Cell` 元素中 `value` 值的原子性。另外，`Cell` 类使用 `@sun.misc.Contended` 修饰是为了避免伪共享。

#### long sum()

返回当前的值，累加所有 `Cell` 内部的 `value` 值后再累加 `base`。例如下面的代码，**由于计算总和时没有对 Cell 数组进行加锁，所以在累加过程中可能有其他线程对 Cell 中的值进行了修改，也有可能对数组进行了扩容，所以 `sum` 返回的值并不是非常精确的**，其返回值并不是一个调用 `sum` 方法时的原子快照值 。

	public long sum() {  
        Cell[] as = cells; Cell a;  
        long sum = base;  
        if (as != null) {  
            for (int i = 0; i < as.length; ++i) {  
                if ((a = as[i]) != null)  
                    sum += a.value;  
            }  
        }  
        return sum;  
    }

#### void reset()

重置操作，把 `base` 置为 0，如果 `Cell` 数组有元素，则元素值被重置为 0。

	public void reset() {  
        Cell[] as = cells; Cell a;  
        base = 0L;  
        if (as != null) {  
            for (int i = 0; i < as.length; ++i) {  
                if ((a = as[i]) != null)  
                    a.value = 0L;  
            }  
        }  
    }

#### long sumThenReset()

等于 `sum()` 和 `rest()` 一起进行。当多线程调用该方法时会有问题，比如考虑第一个调用线程清空 `Cell` 的值，则后一个线程调用时累加的都是 0 值。

	public long sumThenReset() {  
        Cell[] as = cells; Cell a;  
        long sum = base;  
        base = 0L;  
        if (as != null) {  
            for (int i = 0; i < as.length; ++i) {  
                if ((a = as[i]) != null) {  
                    sum += a.value;  
                    a.value = 0L;  
                }  
            }  
        }  
        return sum;  
    }

#### long value()

	public long longValue() {  
        return sum();  
    }

#### void add(long x)

	public void add(long x) {  
        Cell[] as; long b, v; int m; Cell a;  
        if ((as = cells) != null || !casBase(b = base, b + x)) {	// 1.  
            boolean uncontended = true;  
            if (as == null || (m = as.length - 1) < 0 ||			// 2.  
                (a = as[getProbe() & m]) == null ||					// 3.  
                !(uncontended = a.cas(v = a.value, v + x)))			// 4.  
                  
                longAccumulate(x, null, uncontended);				// 5.  
        }  
    }  
  
	final boolean casBase(long cmp, long val) {  
        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);  
    }

代码 (1) 首先看 `cells` 是否为 null，如果为 null 则当前在基础变量 `base` 上进行累加， 这时候就类似 `AtomicLong` 的操作。

如果 `cells` 不为 null 或者线程执行代码 (1) 的 CAS 操作失败了，则会去执行代码 (2)。

代码 (2) (3) 决定当前线程应该访问 `cells` 数组里面的哪一个 `Cell` 元素。

如果当前线程映射的元素存在则执行代码 (4)，使用 CAS 操作去更新分配的 Cell 元素的 value 值，如果当前线程映射的元素不存在或者存在但是 CAS 操作失败则执行代码 (5)。

其实将代码 (2) (3) (4) 合起来看就是获取当前线程应该访问的 cells 数组的 Cell 元素，然后进行 CAS 更新操作，只是在获取期间如果有些条件不满足则会跳转到代码 (5) 执行。

另外当前线程应该访问 cells 数组的哪一个 Cell 元素是通过 `getProbe() & m` 进行计算的，其中 m 是当前 cells 数组元素个数 -1，getProbe() 则用于获取当前线程中变量 `threadLocalRandomProbe` 的值，这个值一开始为 0，在代码 (5) 里面会对其进行初始化。并且当前线程通过分配的 Cell 元素的 cas 函数来保证对 Cell 元素 value 值更新的原子性。

> 这里就能说明为什么前面说 “ `Cell` 数组是 null 并且并发线程较少时，所有的累加操作都是对 `base` 变量进行的”。因为代码 (1) 可知，如果并发量少，casBase 可能每次都会直接成功，这样有会导致 `cells` 一直不会被初始化。

#### void longAccumulate(long x, LongBinaryOperation fn, boolean wasUncontended)`

	final void longAccumulate(long x, LongBinaryOperator fn,  
                              boolean wasUncontended) {  
        // (6) 初始化当前线程变量 threadLocalRandomProbe 的值  
        int h;  
        if ((h = getProbe()) == 0) {  
            ThreadLocalRandom.current(); // force initialization  
            h = getProbe();  
            wasUncontended = true;  
        }  
        boolean collide = false;                // True if last slot nonempty  
        for (;;) {  
            Cell[] as; Cell a; int n; long v;  
            if ((as = cells) != null && (n = as.length) > 0) {		// (7)  
                if ((a = as[(n - 1) & h]) == null) {				// (8)  
                    if (cellsBusy == 0) {       // Try to attach new Cell  
                        Cell r = new Cell(x);   // Optimistically create  
                        if (cellsBusy == 0 && casCellsBusy()) {  
                            boolean created = false;  
                            try {               // Recheck under lock  
                                Cell[] rs; int m, j;  
                                if ((rs = cells) != null &&  
                                    (m = rs.length) > 0 &&  
                                    rs[j = (m - 1) & h] == null) {  
                                    rs[j] = r;  
                                    created = true;  
                                }  
                            } finally {  
                                cellsBusy = 0;  
                            }  
                            if (created)  
                                break;  
                            continue;           // Slot is now non-empty  
                        }  
                    }  
                    collide = false;  
                }  
                else if (!wasUncontended)       // CAS already known to fail  
                    wasUncontended = true;      // Continue after rehash  
                  
                // (9) 当前 Cell 存在，则执行 CAS 设置  
                else if (a.cas(v = a.value, ((fn == null) ? v + x :  
                                             fn.applyAsLong(v, x))))  
                    break;  
                  
                // (10) 当前 Cell 数组个数大于 CPU 个数  
                else if (n >= NCPU || cells != as)  
                    collide = false;            // At max size or stale  
                  
                // (11) 是否有冲突  
                else if (!collide)  
                    collide = true;  
                  
                // (12) 如果当前元素个数没有达到 CPU 个数并且有冲突则扩容  
                else if (cellsBusy == 0 && casCellsBusy()) {  
                    try {  
                        // （12.1）  
                        if (cells == as) {      // Expand table unless stale  
                            Cell[] rs = new Cell[n << 1];  
                            for (int i = 0; i < n; ++i)  
                                rs[i] = as[i];  
                            cells = rs;  
                        }  
                    } finally {  
                        // （12.2）  
                        cellsBusy = 0;  
                    }  
                    // (12.3)  
                    collide = false;  
                    continue;                   // Retry with expanded table  
                }  
                // (13) 为了能够找到一个空闲的 Cell，  
                // 重新计算 hash 值，xorshift 算法生成随机数  
                h = advanceProbe(h);  
            }  
              
            // (14) 初始化 Cell 数组  
            else if (cellsBusy == 0 && cells == as && casCellsBusy()) {  
                boolean init = false;  
                try {                           // Initialize table  
                    if (cells == as) {  
                        // 14.1  
                        Cell[] rs = new Cell[2];  
                        // 14.2  
                        rs[h & 1] = new Cell(x);  
                        cells = rs;  
                        init = true;  
                    }  
                } finally {  
                    // 14.3  
                    cellsBusy = 0;  
                }  
                if (init)  
                    break;  
            }  
            else if (casBase(v = base, ((fn == null) ? v + x :  
                                        fn.applyAsLong(v, x))))  
                break;                          // Fall back on using base  
        }  
    }

当每个线程第 一次 执行到代码 (6) 时，会初始化当前线程变量 `threadLocalRandomProbe` 的值，上面也说了，这个变量在计算当前线程应该被分配到 `cells` 数组的哪一个 `Cell` 元素时会用到。

`cells` 数组的初始化：在代码 (14) 中进行，其中 `cellsBusy` 是一个标示，为 0 说明当前 `cells` 数组没有在被初始化或者扩容，也没有在新建 `Cell` 元素，为 1 则说明 `cells` 数组在被初始化或者扩容，或者当前在创建新的 `Cell` 元素，通过 CAS 操作来进行 0 或 1 状态的切换，这里使用 `casCellsBusy` 函数。代码 (14.1) 初始化 `cells` 数组元素个数为 2，然后使用 `h&1` 计算当前线程应该访问 `cell` 数组的哪个位置，也就是使用当前线程的 `threadLocalRandomProbe变量值 & (cells数组元素个数-1)`，然后标示 cells 数组已经被初始化，最后代码 (14.3) 重置了 `cellsBusy` 标记。显然这里没有使用 CAS 操作，却是线程安全的，原因是 `cellsBusy` 是 `volatile` 类型的，这保证了变量的内存可见性，另外此时其他地方的代码没有机会修改 `cellsBusy` 的值。在这里初始化的 `cells` 数组里面的两个元素的值目前还是 null。

`cells` 数组的扩容：在代码 (12) 中进行，对 `cells` 扩容是有条件的，也就是代码 (10) (11) 的条件都不满足的时候。具体就是当前 cells 的元素个数小于当前机器 CPU 个数并且当前多个线程访问了 cells 中同一个元素从而导致冲突使其中 一个线程 CAS 失败时才会进行扩容操作。这里为何要涉及 CPU 个数呢？其实在基础篇中己经讲过，只有当每个 CPU 都运行一个线程时才会使多线程的效果最佳，也就是当 `cells` 数组元素个数与 CPU 个数一致时，每个 Cell 都使用一个 CPU 进行处理，这时性能才是最佳的。代码 (12) 中的扩容操 作也是先通过 CAS 设置 `cellsBusy` 为 1，然后才能进行扩容。假设 CAS 成功则执行代码 (12.1) 将容量扩充为之前的 2 倍，并复制 `Cell` 元素到扩容后数组。另外，扩容后 `cells` 数组里面除了包含复制过来的元素外，还包含其他新元素，这些元素的值目前还是 null。

在代码 (7)(8) 中，当前线程调用 `add` 方法并根据当前线程的随机数 `threadLocalRandomProbe` 和 `cells` 元素个数计算要访问的 `Cell` 元素下标，然后如果发现对应下标元素的值为 null，则新增一个 `Cell` 元素到 `cells` 数组，并且在将其添加到 `cells` 数组之前要竞争设置 `cellsBusy` 为 1。

代码 (13) 对 CAS 失败的线程重新计算当前线程的随机值 `threadLocalRandomProbe`, 以减少下次访问 `cells`元素时的冲突机会。

## 4.3 LongAccumulator 类

	public LongAccumulator(LongBinaryOperator accumulatorFunction,  
                           long identity) {  
        this.function = accumulatorFunction;  
        base = this.identity = identity;  
    }  
  
  
    @FunctionalInterface  
    public interface LongBinaryOperator {  
        long applyAsLong(long left, long right);  
    }

`accumulatorFunction`是一个双目运算器接口，其根据输入的两个参数返回一个计算值，`identity` 则是 `LongAccumulator` 累加器的初始值。

`LongAdder` 类时 `LongAccumulator` 类的一个特例，在于前者固定了只能进行递增。调用 `LongAdder` 就相当于：

	LongAdder adder = new LongAdder();  
  
	LongAccumulator accumulator = new LongAccumulator(new LongBinaryOperator() {  
            @Override  
            public long applyAsLong(long left, long right) {  
                return left + right;  
            }  
        }, 0);

`LongAccumulator` 相比于 `LongAdder`，可以为累加器提供非 0的初始值，后者只能提供默认的 0 值 。 另外，前者还可以指定累加规则，比如不进行累加而进行相乘，只需要在构造 LongAccumulator 时传入自定义的双目运算器即可，后者则内置累加的规则。

从下面代码我们可以知道， LongAccumulator相比于 LongAdder的不同在于，在调用 casBase 时后者传递的是 b+x，前者则使用了 r = function.applyAsLong(b = base, x) 来计算。

	// LongAdder  
	public void add(long x) {  
        Cell[] as; long b, v; int m; Cell a;  
        if ((as = cells) != null || !casBase(b = base, b + x)) {	  
            boolean uncontended = true;  
            if (as == null || (m = as.length - 1) < 0 ||			  
                (a = as[getProbe() & m]) == null ||					  
                !(uncontended = a.cas(v = a.value, v + x)))			  
                  
                longAccumulate(x, null, uncontended);				  
        }  
    }  
  
  
	// LongAccumulator  
	public void accumulate(long x) {  
        Cell[] as; long b, v, r; int m; Cell a;  
        if ((as = cells) != null ||  
            (r = function.applyAsLong(b = base, x)) != b && !casBase(b, r)) {  
            boolean uncontended = true;  
            if (as == null || (m = as.length - 1) < 0 ||  
                (a = as[getProbe() & m]) == null ||  
                !(uncontended =  
                  (r = function.applyAsLong(v = a.value, x)) == v ||  
                  a.cas(v, r)))  
                longAccumulate(x, function, uncontended);  
        }  
    }

另外，前者在调用 `longAccumulate` 时传递的是 `function`，而后者是 `null`。从下面的代码可知，当 fn为 `null` 时就使用 v+x 加法运算，这时候就等价于 `LongAdder`，当 fn不为 null 时则使用传递的 fn 函数计算。

else if(casBase(v = base, ((fn==null) ? v+x : fn.applyAsLong(v, x))))  
		break; // Fall back on using base

# 5. 并发 List

## 5.1 介绍

并发包中的并发 List 只有 `CopyOnWriteArrayList`，这是一个线程安全的 `ArrayList`，对其进行的修改操作都是在底层的一个复制的数组（快照）上进行的 ，也就是使用了写时复制策略。

类图：

![Screen Shot 2021-06-11 at 22.48.23](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-11%20at%2022.48.23.png)

每个 `CopyOnWriteArrayList` 对象里面有一个 `array` 数组对象用来存放具体元素， `ReentrantLock` 独占锁对象用来保证同时只有以个线程 对 `array` 进行修改。

## 5.2 主要方法

### 初始化

主要是初始化内部变量 array。

    private transient volatile Object[] array;  
  
	final void setArray(Object[] a) {  
        array = a;  
    }  
  
	public CopyOnWriteArrayList() {  
        setArray(new Object[0]);  
    }  
  
    public CopyOnWriteArrayList(E[] toCopyIn) {  
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));  
    }  
  
	public CopyOnWriteArrayList(Collection<? extends E> c) {  
        Object[] elements;  
        if (c.getClass() == CopyOnWriteArrayList.class)  
            elements = ((CopyOnWriteArrayList<?>)c).getArray();  
        else {  
            elements = c.toArray();  
            // c.toArray might (incorrectly) not return Object[] (see 6260652)  
            if (elements.getClass() != Object[].class)  
                elements = Arrays.copyOf(elements,   
                                         elements.length, Object[].class);  
        }  
        setArray(elements);  
    }

### 添加元素

添加元素有 `add(E e)`、`add(int index, E element)`、`addIfAbsent(E e)` 和 `addAllAbsent(Collection<? extends E> c)` 等。

	public boolean add(E e) {  
        // 获取独占锁  
        final ReentrantLock lock = this.lock;  
        lock.lock();  
        try {  
            // 获取 array  
            Object[] elements = getArray();  
            // 复制 array 到新数组，并添加新元素  
            int len = elements.length;  
            Object[] newElements = Arrays.copyOf(elements, len + 1);  
            newElements[len] = e;  
              
            // 用新数组替换 array  
            setArray(newElements);  
            return true;  
        } finally {  
            lock.unlock();  
        }  
    }

### 获取元素

	public E get(int index) {  
        return get(getArray(), index);  
    }  
  
	final Object[] getArray() {  
        return array;  
    }  
  
	private E get(Object[] a, int index) {  
        return (E) a[index];  
    }

线程 x 在调用 get 方法的时候分为两步：

1.  获取 array
    
2.  获取对应下标的元素
    

但没有加锁。如果 x 在第一步和第二步的中间，有个线程 y 调用了 remove 方法，正好删除了 x 要 get 的元素，但不会影响到 x 获取。因为 remove 和 add 一样，先获取独占锁，然后复制一份 array，在复制的数组里删除了 x 要访问元素的对应元素，再将 array 指向复制的数组。而这时候 array 之前指向的数组引用计数为 1，因为线程 x 还在使用它，所以不影响 x 的读。

![Screen Shot 2021-06-11 at 00.04.14](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-11%20at%2000.04.14.png)

所以，虽然线程 y 已经删除了 index 处的元素，但是线程 x 的第二步还是会返回 index 处的元素，这其实就是**写时复制策略产生的弱一致性问题**。

### 修改指定元素

	public E set(int index, E element) {  
        final ReentrantLock lock = this.lock;  
        lock.lock();  
        try {  
            Object[] elements = getArray();  
            E oldValue = get(elements, index);  
  
            if (oldValue != element) {  
                int len = elements.length;  
                Object[] newElements = Arrays.copyOf(elements, len);  
                newElements[index] = element;  
                setArray(newElements);  
            } else {  
                // Not quite a no-op; ensures volatile write semantics  
                setArray(elements);  
            }  
            return oldValue;  
        } finally {  
            lock.unlock();  
        }  
    }

注意，如果指定位置元素和新值一样，为了保证 volatile 语义，还是需要重新设置 array，虽然 array 并没有改变。

### 删除元素

	public E remove(int index) {  
        final ReentrantLock lock = this.lock;  
        lock.lock();  
        try {  
            Object[] elements = getArray();  
            int len = elements.length;  
            E oldValue = get(elements, index);  
            int numMoved = len - index - 1;  
            if (numMoved == 0)  
                setArray(Arrays.copyOf(elements, len - 1));  
            else {  
                Object[] newElements = new Object[len - 1];  
                System.arraycopy(elements, 0, newElements, 0, index);  
                System.arraycopy(elements, index + 1, newElements, index,  
                                 numMoved);  
                setArray(newElements);  
            }  
            return oldValue;  
        } finally {  
            lock.unlock();  
        }  
    }

### 弱一致性的迭代器

	public Iterator<E> iterator() {  
        return new COWIterator<E>(getArray(), 0);  
    }  
  
	static final class COWIterator<E> implements ListIterator<E> {  
        private final Object[] snapshot;  
        private int cursor;  
  
        private COWIterator(Object[] elements, int initialCursor) {  
            cursor = initialCursor;  
            snapshot = elements;  
        }  
  
        public boolean hasNext() {  
            return cursor < snapshot.length;  
        }  
  
        public E next() {  
            if (! hasNext())  
                throw new NoSuchElementException();  
            return (E) snapshot[cursor++];  
        }  
    }

`snapshot` 变量保存了当前 list 的内容，虽然是指针传递的引用，但 snapshot 可以是 list 的副本。

-   如果迭代器在遍历过程中，没有其他线程对 list 进行增删改，那么 snapshot 本身就是 list 的 array。
    
-   如果有其他线程进行了增删改，那么 snapshot 就是快照了。因为增删改之后 list 的 array 被新数组替换了，但这时候老数组被 snapshot 引用。这也说明获取迭代器并使用时，其他线程对该 list 进行的增删改不可见，因为它们操作的是两个不同的数组，这就是**弱一致性**。
    

public class CopyList {  
    private static volatile CopyOnWriteArrayList<String> arrayList   
        			= new CopyOnWriteArrayList<>();  
  
    public static void main(String[] args) throws InterruptedException {  
        arrayList.add("hello");  
        arrayList.add("alibaba");  
        arrayList.add("welcome");  
        arrayList.add("to");  
        arrayList.add("hangzhou");  
        Thread threadOne = new Thread(()->{  
            arrayList.set(1, "baba");  
            arrayList.remove(2);  
            arrayList.remove(3);  
        });  
        Iterator<String> itr = arrayList.iterator();  
        threadOne.start();  
        threadOne.join();  
  
        while (itr.hasNext()) {  
            System.out.print(itr.next() + " ");  
        }  
    }  
}  
  
  
输出：hello alibaba welcome to hangzhou 

> 弱一致性的一些思考：
> 
> 单线程下，经常会写出下面这种代码。将 a 的引用传递给了 b，于是 b 和 a 都指向堆中的同一个对象，那么修改 b 也就相当于修改了 a：
> 
> int[] a = new int[]{1, 2, 3};  
> int[] b = a;  
> b[0] = -1;  
> // a = [-1, 2, 3]
> 
> 但是如果修改 b 所指的内存地址，那么 a 和 b 就指向不同的对象了：
> 
> int[] a = new int[]{1, 2, 3};  
> int[] b = a;  
> b = new int[]{-1, 2, 3};  
> // a = [1, 2, 3]
> 
> 但是在多线程情况下，先将 a 指向的对象传递给另一个线程的 b，如果此时 a 的指向了另一个对象，b 是不知情的，还是指向 a 最开始指向的对象。

# 6. 锁

## 6.1 LockSupport 工具类

它的主要作用是挂起和唤醒线程，也是创建锁和其他同步类的基础。LockSupport 类与每个使用它的线程都会关联一个许可证，在默认情况下调用 LockSupport 类的方法的线程是不持有许可证的。 LockSupport 是使用 Unsafe 类实现的。

### void park()

如果调用 `park` 方法的线程已经拿到了与 LockSupport 关联的许可证，则调用 `Locksupport.park()` 时会马上返回，否则调用线程会被阻塞挂起。

在默认情况下调用线程是不持有许可证的：

	public static void main(String[] args){  
        System.out.println("begin park");  
        LockSupport.park();  
        System.out.println("end park");  
    }  
	输出：begin park

在其他线程调用 `unpark(Thread thread)` 方法并且将当前线程作为参数时，调用 `park` 方法而被阻塞的线程会返回。另外，如果其他线程调用了阻塞线程的 `interrupt()` 方法 ，设置了中断标志或者线程被虚假唤醒，则阻塞线程也会返回。所以在调用 park 方法时最好也使用循环条件判断方式。

需要注意的是，因调用 `park()` 方法而被阻塞的线程被其他线程中断而返回时并不会抛出 `InterruptedException` 异常（而 sleep、wait 等方法会）。

park 方法返回时不会告诉你因何种原因返回，所以调用者需要根据之前调用 park 方法的原因，再次检查条件是否满足，如果不满足则还需要再次调用 park 方法。下面代码就是根据调用前后中断状态的对比就可以判断是不是因为被中断才返回的。只有中断子线程，子线程才会运行结束，如果子线程不被中断 ， 即使调用 `unpark(thread)` 方法子线程也不会结束。

	public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(()->{  
            System.out.println("child thread begin park");  
  
            while (!Thread.currentThread().isInterrupted()) {  
                LockSupport.park();  
            }  
            System.out.println("child thread unpark");  
        });  
  
        thread.start();  
        Thread.sleep(1000);  
        System.out.println("main thread begin unpark");  
        thread.interrupt();  
    }  
	输出：  
    child thread begin park  
	main thread begin unpark  
	child thread unpark

### void unpark(Thread thread)

当一个线程调用 `unpark` 时：

-   如果参数 `thread` 线程没有持有 `thread` 与 `LockSupport` 类关联的许可证， 则让 `thread` 线程持有。
    
-   如果 `thread` 之前因调用 `park()` 而被挂起，则调用 `unpark` 后，该线程会被唤醒。如果 `thread` 之前没有调用 `park`，则调用 `unpark` 方法后 ， 再调用 `park` 方法，其会立刻返回。
    

	public static void main(String[] args){  
        System.out.println("begin park");  
        LockSupport.unpark(Thread.currentThread());  
        LockSupport.park();  
        System.out.println("end park");  
    }  
	输出：  
    begin park  
	end park

### void park(long nanos)

如果被挂起的线程在 nanos 时间后还没有拿到许可证，会自动返回。

### void park(Object blocker)

当线程程在没有持有许可证的情况下调用 park 方法而被阻塞挂起时，这个 blocker 对象会被记录到该线程 内部。

使用诊断工具可以观察线程被阻塞的原因，诊断工具是通过调用 getBlocker(Thread) 方法来获取 blocker 对 象的，所以 JDK 推荐我们使用带有 blocker 参数的 park 方法，并且 blocker 被设置为 this，这样当在打印线程堆栈排查问题时就能知道是哪个类被阻塞了。

public class TestPark {  
    private void testPark() {  
        LockSupport.park();  
    }  
    public static void main(String[] args){  
        TestPark testPark = new TestPark();  
        testPark.testPark();  
    }  
}

运行后，使用 `jstack pid` 命令查看线程堆栈可以看到：

![Screen Shot 2021-06-12 at 00.17.27](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-12%20at%2000.17.27.png)

修改成：`LockSupport.park(this)` 之后：

![Screen Shot 2021-06-12 at 00.17.23](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-12%20at%2000.17.23.png)

源码：

    public static void park(Object blocker) {  
        Thread t = Thread.currentThread();  
        setBlocker(t, blocker);  
        // 挂起线程  
        UNSAFE.park(false, 0L);  
        // 线程被激活后，清除 blocker 变量，因为一般都是在线程阻塞时才使用  
        setBlocker(t, null);  
    }

Thread 类里面有个变量 `volatile Object parkBlocker`， 用来存放 park 方法传递的 blocker 对象，也就是把 blocker 变量存放到了调用 `park` 方法的线程的成员变量里面。

### void parkNanos(Object blocker, long nanos)

### void parkUntil(Object blocker, long deadline)

	public static void parkUntil(Object blocker, long deadline) {  
        Thread t = Thread.currentThread();  
        setBlocker(t, blocker);  
        UNSAFE.park(true, deadline);  
        setBlocker(t, null);  
    }

其中参数 deadline 的时间单位为 ms，该时间是从 1970 年到现在某一个时间点的毫秒值。

### 例子

public class FIFOMutex {  
    private final AtomicBoolean locked = new AtomicBoolean(false);  
    private final Queue<Thread> waiters = new ConcurrentLinkedQueue<>();  
  
    private void lock() {  
        boolean wasInterrupted = false;  
        Thread current = Thread.currentThread();  
        waiters.add(current);  
  
        // (1)  
        while (waiters.peek() != current || !locked.compareAndSet(false, true)) {  
            LockSupport.park(this);  
            if (Thread.interrupted()) {			// (2)  
                wasInterrupted = true;  
            }  
        }  
  
        waiters.remove();  
        if (wasInterrupted) {					// (3)  
            current.interrupt();  
        }  
    }  
  
    private void unlock() {  
        locked.set(false);  
        LockSupport.unpark(waiters.peek());  
    }  
}

这是 一 个先进先出的锁。 在代码 (1) 处，如果当前线程不是队首或者当前锁己经被其他线程获取，则调用 park 方法挂起自己。

然后在代码 (2) 处判断，如果 park 方法是因为被中断而返回，则忽略中断，并且重置中断标志，做个标记，然后再次判断当前线程是不是队首元素或者当前锁是否己经被其他线程获取，如果是则继续调用 park 方法挂起自己。

然后在代码 (3) 中，判断标记，如果标记为 true 则中断该线程，这个怎么理解呢？其实就是其他线程中断了该线程，虽然我对中断信号不感兴趣，忽略它，但是不代表其他线程对该标志不感兴趣，所以要恢复下。

## 6.2 抽象同步队列 AQS

### AbstractQueuedSynchronizer

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612092219117.png" alt="image-20210612092219117" style="zoom: 33%;" />

它是同步器的基本组件，并发包中锁的底层就是用 AQS 实现的。

AQS 是一个双向 Node 队列，有 `head` 和 `tail`；

Node 中的 `thread` 变量用来存放进入 AQS 里的线程；Node 内部的 `SHARED` 用来标记该线程是获取共享资源时被阻塞挂起后放入 AQS 队列的， `EXCLUSIVE` 用来标记线程是获取独占资源时被挂起后放入 AQS 队列的；

`waitStatus` 记录当前线程等待状态，可以为 `CANCELLED`（线程被取消了）、`SIGNAL`（线程需要被唤醒）、 `CONDITION`（线程在条件队列里面等待）、`PROPAGATE`（释放共享资源时需要通知其他节点）。

AQS 中维持了一个单一单状态信息 `state`，相关方法有 `getState`、`setState` 和 `compareAndSetState`。

> -   对于 ReentrantLock，state 表示当前线程获取锁的可重入次数；
>     
> -   对于 ReentrantReadWriteLock 来说，state 的高 16 位表示获取读锁的线程可重入次数，低 16 位表示获取到写锁的线程可重入次数；
>     
> -   对于 Semaphore 来说，state 表示当前可用信号个数；
>     
> -   对于 CountDownLatch 来说，state 表示计数器当前的值。
>     

AQS 有个内部类 `ConditionObject`，用来结合锁实现线程同步。`ConditionObject` 可以直接访问 AQS 对象内部的变量，比如 state 和 AQS 队列。`ConditionObject` 是条件变量，每个条件变量对应一个条件队列（单向链表队列），其用来存放调用条件变量的 `await` 方法后被阻塞的线程，这个条件队列的头、尾元素分别为 `firstWaiter` 和 `lastWaiter`。

对于 AQS 来说，线程同步的关键是对状态值 `state` 进行操作。根据 `state` 是否属于一个线程，操作 `state` 的方式分为独占方式和共享方式：

-   在独占方式下获取和释放资源使用的方法为：`void acquire(int arg)`、`void acquireInterruptibly(int arg)`、 `boolean release(int arg)`。
    
-   在共享方式下获取和释放资源的方法为：`void acquireShared(int arg)`、`void acquireSharedInterruptibly(int arg)`、`boolean releaseShared(int arg)`。
    

#### 实现独占锁和共享锁

##### 独占方式

使用独占方式获取的资源是与具体线程绑定的，就是说如果一个线程获取到了资源，就会标记是这个线程获取到了，其他线程再尝试操作 `state` 获取资源时会发现当前该资源不是自己持有的，就会在获取失败后被阻塞。

获取与释放资源的流程如下：

1.  当一个线程调用 `acquire(int arg)` 方法获取独占资源时，会首先使用 `tryAcquire` 方法尝试获取资源， 具体是设置状态变量 `state` 的值，成功则直接返回，失败则将当前线程封装为类型为 `Node.EXCLUSIVE` 的 Node 节点后插入到 AQS 阻塞队列的尾部，并调用 `LockSupport.park(this)` 方法挂起自己 。
    
    	public final void acquire(int arg) {  
            if (!tryAcquire(arg) &&  
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  
                selfInterrupt();  
        }
    
2.  当一个线程调用 `release(int arg)` 方法时会尝试使用 `tryRelease` 操作释放资源，这里是设置状态变量 `state` 的值，然后调用 `LockSupport.unpark(thread)` 方法激活 AQS 队列里面被阻塞的一个线程。 被激活的线程则使用 `tryAcquire` 尝试，看当前状态变量 `state` 的值是否能满足自己的需要，满足则该线程被激活，然后继续向下运行，否则还是会被放入 AQS 队列并被挂起。
    
    	public final boolean release(int arg) {  
            if (tryRelease(arg)) {  
                Node h = head;  
                if (h != null && h.waitStatus != 0)  
                    unparkSuccessor(h);  
                return true;  
            }  
            return false;  
        }
    

`trAcquire` 和 `tryRelease` 需要由具体的子类来实现。 子类在实现 tryAcquire和 tryRelease时要根据具体场景使用 CAS 算法尝试修改 state状态值， 成功则返回 true，否则返回 false。 子类还需要定义，在调用 `acquire` 和 `release` 方法时 `state` 状态值的增减代表什么含义 。

> 比如独占锁 `ReentrantLock`， 定义当 `state` 为 0 时表示锁空闲，为 1 时表示锁己经被占用。在重写 `tryAcquire` 时，在内部需要使用 CAS 算法查看当前 state 是否为 0，如果为 0 则 使用 CAS 设置为 1，并设置当前锁的持有者为当前线程，而后返回 true，如果 CAS 失败则返回 false。
> 
> 比如继承自 AQS 实现的独占锁在实现 `tryRelease` 时，在内部需要使用 CAS 算法把当前 state 的值从 1 修改为 0，并设置当前锁的持有者为 null，然后返回 true， 如果 CAS 失败 则返回 false。

##### 共享方式

对应共享方式的资源与具体线程是不相关的，当多个线程去请求资源时通过 CAS 方式竞争获取资源，当 一个线程获取到了资源后，另外一个线程再次去获取时如果当前资源还能满足它的需要，则当前线程只需要使用 CAS 方式进行获取即可。比如 `Semaphore` 信号量，当一个线程通过 `acquire()` 方法获取信号量时，会首先看当前信号量个数是否满足需要，不满足则把当前线程放入阻塞队列，如果满足则通过自旋 CAS 获取信号量。

获取与释放资源的流程如下：

1.  当线程调用 `acquireShared(int arg)` 获取共享资源时，会首先使用 `tryAcquireShared` 尝试获取资源，具体是设置状态变量 `state` 的值，成功则直接返回，失败则将当前线程封装为类型为 `Node.SHARED` 的 Node 节点后插入到 AQS 阻塞队列的尾部，并使用 `LockSupport.park(this)` 方法挂起自己。
    
    	public final void acquireShared(int arg) {  
            if (tryAcquireShared(arg) < 0)  
                doAcquireShared(arg);  
        }
    
2.  当一个线程调用 `releaseShared(int arg)` 时会尝试使用 `tryReleaseShared` 操作释放资源，这里是设置状态变量 `state` 的值，然后使用 `LockSupport.unpark(thread)` 激活 AQS 队列里面被阻塞的一个线程。被激活的线程则使用 `tryAcquireShared` 查看当前状态变量 `state` 的值是否能满足自己的 需要，满足则该线程被激活，然后继续向下运行，否则还是会被放入 AQS 队列并被挂起。
    
        public final boolean releaseShared(int arg) {  
            if (tryReleaseShared(arg)) {  
                doReleaseShared();  
                return true;  
            }  
            return false;  
        }
    

`tryAcquireShared` 和 `tryReleaseShared` 需要由具体的子类来实现。子类在实现 `tryAcquireShared` 和 `tryReleaseShared` 时要根据具体场景使用 CAS 算法尝试修改 `state` 状态值，成功则返回 true，否则返回 false。

> 比如继承自 AQS 实现的读写锁 ReentrantReadWriteLock 里面的读锁在重写 tryAcquireShared 时，首先查看写锁是否被其他线程持有，如果是则直接返回 false， 否则使用 CAS 递增 state 的高 16 位。重写 tryReleaseShared 时，在内部需要使用 CAS 算法把当前 state 值的高 16 位减 1， 然后返回 true，如果 CAS 失败则返回 false。

基于 AQS 实现的锁除了需要重写上面中的一类方法外，**还需要重写 `isHeldExclusively` 方法**，来判断锁是被当前线程独占还是被共享。

`void acquireInterruptibly(int arg)` 与 `void acquireSharedInterruptibly(int arg)` 这两个函数中都有一个带有 Interruptibly 关键字。不带 Interruptibly 关键字的方法的意思是不对中断进行响应，也就是线程在调用不带 Interruptibly 关键字的方法获取资源时或者获取资源失败被挂起时，其他线程中断了该线程，那么该线程不会因为被中断而抛出异常，它还是继续获取资源或者被挂起，忽略中断。否则，会抛出 InterruptedException。

#### 维护 AQS 提供的队列

主要看入队操作：

当一个线程获取锁失败后该线程会被转换为 Node 节点，然后就会使用 `enq(final Node node)` 方法将该节点插入到 AQS 的阻塞队列。

    private Node enq(final Node node) {  
        for (;;) {  
            Node t = tail;  
            if (t == null) { // Must initialize  
                if (compareAndSetHead(new Node()))  
                    tail = head;  
            } else {  
                // node 插入队尾，返回之前的队尾  
                node.prev = t;  
                if (compareAndSetTail(t, node)) {  
                    t.next = node;  
                    return t;  
                }  
            }  
        }  
    }

![image-20210612104917370](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612104917370.png)

### 条件变量

notify 和 wait 是配合 synchronized 内置锁实现线程间同步的基础设施，条件变量的 signal 和 await 方法也是用来配合使用 AQS 实现的锁实现线程间同步的基础设施。它们的不同在于，synchronized 同时只能与一个共享变量的 notify 或 wait 方法实现同步，而 AQS 的一个锁可以对应多个条件变量。

在调用共享变量的 notify 和 wait 方法前必须先获取该共享变量的内置锁，同理，在调用条件变量的 signal 和 await 方法前也必须先获取条件变量对应的锁。

        ReentrantLock lock = new ReentrantLock();  
        Condition condition = lock.newCondition();  
  
		// 程序 1  
        lock.lock();  
        try {  
            System.out.println("begin wait");  
            condition.await();  
            System.out.println("end wait");  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            lock.unlock();  
        }  
  
		// 程序 2  
        lock.lock();  
        try {  
            System.out.println("begin signal");  
            condition.signal();  
            System.out.println("end signal");  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            lock.unlock();  
        }

通过调用 `newCondition` 方法创建一个条件变量 ConditionObject（这是 AQS 的内部类，实现了 Condition 接口，可以访问 AQS 的变量和方法）。在每个条件变量内部都维护了一个条件队列，用来存放调用条件变量的 await() 方法时被阻塞的线程。

如果线程调用了条件变量的 await() 方法阻塞挂起了当前线程。当其他线程调用条件变量的 signal 方法时，被阻塞的线程才有可能会从 await 处返回。和调用 Object 的 wait 方法一样，如果在没有获取到锁前调用了条件变量的 await 方法则会抛出 java.lang.IllegalMonitorStateException 异常。调用条件变量的 await() 方法就相当于调用共享变量的 wait() 方法，signal 和 notify、signalAll 和 notifyAll 同理。

#### await

在如下代码中，当线程调用条件变量的 await() 方法时（必须先调用锁的 lock() 方法获取锁），在内部会构造一个类型为 `Node.CONDITION` 的 node 节点，然后将该节点插入条件队列末尾，之后当前线程会释放获取的锁（也就是会操作锁对应的 state 变量的值），并被阻塞挂起。这时候如果有其他线程调用 lock.lock() 尝试获取锁，就会有一个线程获取到锁，如果获取到锁的线程调用了条件变量的 await() 方法，则该线程也会被放入条件变量的阻塞队列，然后释放获取到的锁，在 await() 方法处阻塞。

        public final void await() throws InterruptedException {  
            if (Thread.interrupted())  
                throw new InterruptedException();  
            Node node = addConditionWaiter();  
            int savedState = fullyRelease(node);  
            int interruptMode = 0;  
            while (!isOnSyncQueue(node)) {  
                LockSupport.park(this);  
              	if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)  
                    break;  
            }  
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)  
                interruptMode = REINTERRUPT;  
            if (node.nextWaiter != null) // clean up if cancelled  
                unlinkCancelledWaiters();  
            if (interruptMode != 0)  
                reportInterruptAfterWait(interruptMode);  
        }

在如下代码中，当另外一个线程调用条件变量的 signal 方法时（必须先调用锁的 lock() 方法获取锁），在内部会把条件队列里面队头的一个线程节点从条件队列里面移除并放入 AQS 的阻塞队列里面，然后激活这个线程。

#### signal

        public final void signal() {  
            if (!isHeldExclusively())  
                throw new IllegalMonitorStateException();  
            Node first = firstWaiter;  
            if (first != null)  
                doSignal(first);  
        }

需要注意的是，AQS 只提供了 ConditionObject 的实现，并没有提供 `newCondition` 函数，该函数用来 new 一个 ConditionObject 对象。需要由 AQS 的实现来提供 `newCondition` 函数。

> 一般要实现一个同步类，都回去实现 Lock 接口，Lock 接口有抽象的 newCondition、lock、unlock 等方法。然后实现一个内部类来继承 AQS，并实现 newCondition 方法，供外部类来调用。

#### addConditionWaiter

下面来看当一个线程调用条件变量的 await() 方法而被阻塞后，如何将其放入条件队列 。

        private Node addConditionWaiter() {  
            Node t = lastWaiter;  
            // If lastWaiter is cancelled, clean out.  
            if (t != null && t.waitStatus != Node.CONDITION) {  
                unlinkCancelledWaiters();  
                t = lastWaiter;  
            }  
            Node node = new Node(Thread.currentThread(), Node.CONDITION);  
            if (t == null)  
                firstWaiter = node;  
            else  
                t.nextWaiter = node;  
            lastWaiter = node;  
            return node;  
        }

注意：当多个线程同时调用 lock.lock() 方法获取锁时，只有一个线程获取到了锁，其他线程会被转换为 Node 节点插入到 lock 锁对应的 AQS 阻塞队列里面，并做自旋 CAS 尝试获取锁。

如果获取到锁的线程又调用了对应的条件变量的 await() 方法，则该线程会释放获取到的锁，并被转换为 Node 节点插入到条件变量对应的条件队列里面 。

这时候因为调用 lock.lock() 方法被阻塞到 AQS 队列里面的一个线程会获取到被释放的锁，如果该线程也调用了条件变量的 await() 方法则该线程也会被放入条件变量的条件队列里面。

当另外一个线程调用条件变量的 `signal()` 或者 `signalAll()` 方法时，会把条件队列里面的一个或者全部 Node节点移动到 AQS 的阻塞队列里面，**等待时机获取锁**。

下图说明了： 一个锁对应一个 AQS 阻塞队列，对应多个条件变量， 每个条件变量有自己的一个条件队列。

![Screen Shot 2021-06-12 at 14.17.23](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-12%20at%2014.17.23.png)

### 基于 AQS 实现自定义同步器

实现一个不可重入独占锁。定义 state = 0 表示目前没有锁被线程持有，state = 1 表示有一个线程持有锁，state 不会大于 1。

NonReentrantLock 定义了一个内部类 Sync 用来实现具体的锁的操作，Sync 则继承了 AQS。由于我们 现的是独占模式的锁，所 以 Sync 重写了 tryAcquire、 tryRelease 和 isHeldExclusively 3 个方法。另外，Sync 提供了 newCondition 这个方法用来支持条件变量。

public class NonReentrantLock implements Lock, Serializable {  
    private static class Sync extends AbstractQueuedSynchronizer {  
        @Override  
        protected boolean isHeldExclusively() {  
            return getState() == 1;  
        }  
  
        @Override  
        protected boolean tryAcquire(int acquires) {  
            assert acquires == 1;  
            if (compareAndSetState(0, 1)) {  
                setExclusiveOwnerThread(Thread.currentThread());  
                return true;  
            }  
            return false;  
        }  
  
        @Override  
        protected boolean tryRelease(int releases) {  
            assert releases == 1;  
            if (getState() == 0) {  
                throw new IllegalMonitorStateException();  
            }  
            setExclusiveOwnerThread(null);  
            setState(0);  
            return true;  
        }  
  
        Condition newCondition() {  
            return new ConditionObject();  
        }  
    }  
  
    private final Sync sync = new Sync();  
      
    @Override  
    public void lock() {  
        sync.acquire(1);  
    }  
  
    @Override  
    public boolean tryLock() {  
        return sync.tryAcquire(1);  
    }  
  
    @Override  
    public void unlock() {  
        sync.release(1);  
    }  
  
    @Override  
    public Condition newCondition() {  
        return sync.newCondition();  
    }  
  
    public boolean isLocked() {  
        return sync.isHeldExclusively();  
    }  
  
    @Override  
    public void lockInterruptibly() throws InterruptedException {  
        sync.acquireInterruptibly(1);  
    }  
      
    @Override  
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {  
        return sync.tryAcquireNanos(1, unit.toNanos(time));  
    }  
}

#### 使用 NonReentrantLock 实现生产-消费模型

	final static NonReentrantLock lock = new NonReentrantLock();  
    final static Condition notFull = lock.newCondition();  
    final static Condition notEmpty = lock.newCondition();  
  
    final static Queue<String> queue = new LinkedBlockingQueue<>();  
    final static int queueSize = 10;  
  
    public static void main(String[] args) {  
        Thread producer = new Thread(() -> {  
            lock.lock();  
            try {  
                while (queue.size() == queueSize) {  
                    notEmpty.await();  
                }  
                queue.add("ele");  
                notFull.signalAll();  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                lock.unlock();  
            }  
        });  
  
        Thread consumer = new Thread(() -> {  
            lock.lock();  
            try {  
                while (0 == queue.size()) {  
                    notFull.await();  
                }  
                String ele = queue.poll();  
                System.out.println(ele);  
                notEmpty.signalAll();  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                lock.unlock();  
            }  
        });  
  
        producer.start();  
        consumer.start();  
    }

这里 `notEmpty` 和 `notFull` 应该分别指的是「满」和「空」。

使用 while 而不是 if 是为了避免虚假唤醒。

## 6.3 独占锁 ReentrantLock 原理

### 类图

![image-20210612144357143](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612144357143.png)

ReentrantLock 最终还是使用 AQS 来实现的，并且根据参数来决定其内部是一个公平还是非公平锁，默认是非公平锁。

	public ReentrantLock() {  
        sync = new NonfairSync();  
    }  
  
    public ReentrantLock(boolean fair) {  
        sync = fair ? new FairSync() : new NonfairSync();  
    }

其中 Sync 类继承自 AQS，它的子类 NonfairSync 和 FairSync 分别实现了获取锁的非公平与公平策略 。

> 不可重入锁，如果线程尝试在已获得锁的情况下再去获得锁，会阻塞自己，具体看 NonReentrantLock 的 tryAcquire 方法。

### 获取锁

#### void lock()

当一个线程第一次获取该锁时会尝试使用 CAS 设置 state 的值为 1，如果 CAS 成功则当前线程获取了该锁，然后记录该锁的持有者为当前线程。在该线程没有释放锁的情况下第二次获取该锁后，状态值被设置为 2。在该线程释放该锁时，会尝试使用 CAS 让状态值减 1， 如果减 1 后状态值为 0，则当前线程释放该锁。

	public void lock() {  
        sync.lock();  
    }

Sync 是抽象类，lock 是抽象方法，先看 NonfairSync 的实现：

	final void lock() {  
		if (compareAndSetState(0, 1))  
            setExclusiveOwnerThread(Thread.currentThread());  
        else  
            acquire(1);  
    }  
  
	protected final boolean tryAcquire(int acquires) {  
        return nonfairTryAcquire(acquires);  
    }  
	  
	final boolean nonfairTryAcquire(int acquires) {  
        final Thread current = Thread.currentThread();  
        int c = getState();  
        // 个人理解：先判断是否为 0，可以避免很多次 CAS 操作  
        if (c == 0) {  
            // 防止此时其他线程提前获得锁  
            if (compareAndSetState(0, acquires)) {  
                setExclusiveOwnerThread(current);  
                return true;  
            }  
        }  
        // 该线程已经有锁了，就不需要使用 CAS 了  
        else if (current == getExclusiveOwnerThread()) {  
            int nextc = c + acquires;  
            if (nextc < 0) // overflow  
                throw new Error("Maximum lock count exceeded");  
            setState(nextc);  
            return true;  
        }  
        return false;  
    }  
  
	// 贴出 AQS 的 acquire  
    public final void acquire(int arg) {  
        if (!tryAcquire(arg) &&  
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  
            selfInterrupt();  
    }

非公平的体现：

首先假设此时锁被线程 A 占有，线程 B 最终调用 nonfairTryAcquire 返回 false 然后被放入 AQS 阻塞队列。之后线程 C 调用 nonfairTryAcquire 时，线程 A 正好释放了锁，C 可以顺利获得锁，这就是不公平的体现。因为线程 C 在获取锁的时候并没有查看当前 AQS 队列里是否有比自己更早请求该锁的线程。

然后是 FairSync 的实现：

	final void lock() {  
		acquire(1);  
	}  
  
	protected final boolean tryAcquire(int acquires) {  
        final Thread current = Thread.currentThread();  
        int c = getState();  
        if (c == 0) {  
            if (!hasQueuedPredecessors() &&  
                compareAndSetState(0, acquires)) {  
                setExclusiveOwnerThread(current);  
                return true;  
            }  
        }  
        else if (current == getExclusiveOwnerThread()) {  
            int nextc = c + acquires;  
            if (nextc < 0)  
                throw new Error("Maximum lock count exceeded");  
            setState(nextc);  
            return true;  
        }  
        return false;  
    }  
  
	// AQS  
    public final boolean hasQueuedPredecessors() {  
        // The correctness of this depends on head being initialized  
        // before tail and on head.next being accurate if the current  
        // thread is first in queue.  
        Node t = tail; // Read fields in reverse initialization order  
        Node h = head;  
        Node s;  
        return h != t &&  
            ((s = h.next) == null || s.thread != Thread.currentThread());  
    }

FairSync 在 CAS 操作之前多了AQS 实现的 `hasQueuedPredecessors` 方法。

-   如果 h==t 则说明当前队列为空，直接返回 false；
    
-   如果 h!=t 并且 s==null 则说明有一个元素将要作为 AQS 的第一个节点入队列（回顾前面的内容，enq 函数的第一个元素入队列是两步操作：首先创建一个哨兵头节点，然后将第一个元素插入哨兵节点后面），那么返回 true；
    
-   如果 h!=t 并且 s!=null 和 s.thread != Thread.cunentThread() 则说明队列里面的第一个元素不是当前线程，那么返 回 true。
    

#### void lockInterruptibly()

    public void lockInterruptibly() throws InterruptedException {  
        sync.acquireInterruptibly(1);  
    }  
  
	public final void acquireInterruptibly(int arg) throws InterruptedException {  
        if (Thread.interrupted())  
            throw new InterruptedException();  
        if (!tryAcquire(arg))  
            doAcquireInterruptibly(arg);  
    }

#### void tryLock()

尝试获取锁，如果当前该锁没有被其他线程持有，则当前线程获取该锁井返回 true，否则返回 false。该方法不会引起当前线程阻塞。tryLock() 使用非公平策略。

    public boolean tryLock() {  
        return sync.nonfairTryAcquire(1);  
    }

#### boolean tryLock(long timeout, TimeUnit unit)

如果超时时间到了没有获取到锁则返回 false。

    public boolean tryLock(long timeout, TimeUnit unit)  
            throws InterruptedException {  
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));  
    }

### 释放锁

#### void unlock()

    public void unlock() {  
        sync.release(1);  
    }  
  
	// AQS  
    public final boolean release(int arg) {  
        if (tryRelease(arg)) {  
            Node h = head;  
            if (h != null && h.waitStatus != 0)  
                unparkSuccessor(h);  
            return true;  
        }  
        return false;  
    }  
	          
	protected final boolean tryRelease(int releases) {  
        int c = getState() - releases;  
        if (Thread.currentThread() != getExclusiveOwnerThread())  
            throw new IllegalMonitorStateException();  
        boolean free = false;  
        if (c == 0) {  
            free = true;  
            setExclusiveOwnerThread(null);  
        }  
        setState(c);  
        return free;  
    }

### 案例

使用 ReentrantLock 实现线程安全的 List。

public class ReentrantLockList {  
    private ArrayList<String> array = new ArrayList<>();  
    private volatile ReentrantLock lock = new ReentrantLock();  
  
    public void add(String e) {  
        lock.lock();  
        try { array.add(e); }   
        finally { lock.unlock(); }  
    }  
  
    public void remove(String e) {  
        lock.lock();  
        try { array.remove(e); }   
        finally { lock.unlock(); }  
    }  
  
    public String get(int index) {  
        lock.lock();  
        try { return array.get(index); }   
        finally { lock.unlock(); }  
    }  
}  

## 6.4 ReentrantReadWriteLock

适合 ReentrantLock 效率低的读多写少场景，ReentrantReadWriteLock 采用读写分离的策略。

### 类图

![image-20210612163225016](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612163225016.png)

读写锁的内部维护了一个 ReadLock 和一个 WriteLock，它们依赖 Sync 实现具体功能。而 Sync 继承自AQS，并且也提供了公平和非公平的实现。下面只介绍非公平的读写锁实现。

	// Sync  
	static final int SHARED_SHIFT   = 16;  
	// 共享锁（读锁）状态单位值 65536  
    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);  
	// 共享锁线程最大个数 65535  
    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;  
	// 排他锁（写锁）掩码，二进制，15 个 1  
    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;  
  
    /** 返回读锁线程数  */  
    static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }  
    /** 返回写锁可重入个数  */  
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

Sync 中有个 Thread firstReader 变量来记录第一个获取到读锁的线程；int firstReaderHoldCount 记录第一个获取到读锁的线程可重入次数；HoldCounter cachedHoldCounter 变量来记录最后一个获取读锁的线程；ThreadLocalHoldCounter readHolds 用来记录除了第一个获取读锁线程外其他获取读锁的线程可重入次数。

HoldCounter 和 ThreadLocalHoldCounter 是 Sync 的内部类。

	static final class HoldCounter {  
        int count = 0;  
        // Use id, not reference, to avoid garbage retention  
        final long tid = getThreadId(Thread.currentThread());  
    }  
  
	static final class ThreadLocalHoldCounter extends ThreadLocal<HoldCounter> {  
        public HoldCounter initialValue() {  
            return new HoldCounter();  
        }  
    }

### 写锁的获取与释放

写锁使用 WriteLock 实现。

#### void lock()

写锁是个独占锁，某时只有一个线程可以获取该锁。如果当前没有线程获取到读锁和写锁，则当前线程可以获取到写锁然后返回。 如果当前己经有线程获取到读锁或写锁，则当前请求写锁的线程会被阻塞挂起。写锁是可重入锁。

// WriteLock  
public void lock() {  
    sync.acquire(1);  
}  
  
// Sync  
protected final boolean tryAcquire(int acquires) {  
    Thread current = Thread.currentThread();  
    int c = getState();  
    int w = exclusiveCount(c);  
    // c!=0 说明有线程获得锁  
    if (c != 0) {  
        // w==0 说明有线程获得了读锁（此时 state 低 16 位为 0）  
        // w!=0 说明有线程获得了写锁，然后判断是不是当前线程获得的  
        if (w == 0 || current != getExclusiveOwnerThread())  
            return false;  
        if (w + exclusiveCount(acquires) > MAX_COUNT)  
            throw new Error("Maximum lock count exceeded");  
        // 设置可重入次数（不需要 CAS）  
        setState(c + acquires);  
        return true;  
    }  
    // 到这里说明当前没有线程获得锁  
    if (writerShouldBlock() ||  
        !compareAndSetState(c, c + acquires))  
        return false;  
    setExclusiveOwnerThread(current);  
}

writeShouldBolck 是 Sync 的抽象方法，NonfairSync 的实现：

final boolean writerShouldBlock() {  
    return false; // writers can always barge  
}

FairSync 的实现：

final boolean writerShouldBlock() {  
    return hasQueuedPredecessors();  
}

#### void lockInterruptibly()

// WriteLock  
public void lockInterruptibly() throws InterruptedException {  
    sync.acquireInterruptibly(1);  
}

#### boolean tryLock()

// WriteLock  
public boolean tryLock() {  
    return sync.tryWriteLock();  
}  
  
// Sync  
final boolean tryWriteLock() {  
    Thread current = Thread.currentThread();  
    int c = getState();  
    if (c != 0) {  
        int w = exclusiveCount(c);  
        if (w == 0 || current != getExclusiveOwnerThread())  
            return false;  
        if (w == MAX_COUNT)  
            throw new Error("Maximum lock count exceeded");  
    }  
    if (!compareAndSetState(c, c + 1))  
        return false;  
    setExclusiveOwnerThread(current);  
    return true;  
}

这里 tryWriteLock 和 tryAcquire 类似，但 tryWriteLock 使用了非公平策略。

#### boolean tryLock(long timeout, TimeUnit unit)

除了有超时之外，该方法会对中断进行响应，也就是当其他线程调用了该线程的 interrupt() 方法中断了当前线程时，当前线程会抛出 InterruptedException 异常。

// WriteLock  
public boolean tryLock(long timeout, TimeUnit unit)  
    		throws InterruptedException {  
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));  
}

#### void unlock()

// WriteLock  
public void unlock() {  
    sync.release(1);  
}  
  
// Sync  
protected final boolean tryRelease(int releases) {  
    // 检查是否是写锁拥有者调用的 unlock  
    if (!isHeldExclusively())  
        throw new IllegalMonitorStateException();  
    // 没有考虑高 16 位，因为获取写锁时读锁状态值肯定全为 0  
    int nextc = getState() - releases;  
    boolean free = exclusiveCount(nextc) == 0;  
    if (free)  
        setExclusiveOwnerThread(null);  
    setState(nextc);  
    return free;  
}

### 读锁的获取和释放

读锁使用 ReadLock 来实现。

#### void lock()

// ReadLock  
public void lock() {  
    sync.acquireShared(1);  
}  
  
// AQS  
public final void acquireShared(int arg) {  
    if (tryAcquireShared(arg) < 0)  
        doAcquireShared(arg);  
}  
  
// Sync  
protected final int tryAcquireShared(int unused) {  
    Thread current = Thread.currentThread();  
    int c = getState();  
    // 判断 1.当前是否写锁，2.如果有写锁，判断写锁拥有者是不是zi j  
    if (exclusiveCount(c) != 0 &&  
        getExclusiveOwnerThread() != current)  
        return -1;  
      
    int r = sharedCount(c);  
    if (!readerShouldBlock() &&  
        r < MAX_COUNT &&  
        // 抢占式将 state 高 16 位加 1  
        compareAndSetState(c, c + SHARED_UNIT)) {  
        if (r == 0) {  
            firstReader = current;  
            firstReaderHoldCount = 1;  
        } else if (firstReader == current) {  
            firstReaderHoldCount++;  
        } else {  
            HoldCounter rh = cachedHoldCounter;  
            // rh == null 说明当前只有一个 firstReader  
            // 第二个条件说明当前线程不是最后一个获得读锁的线程  
            // 满足条件后初始化 cachedHoldCounter  
            if (rh == null || rh.tid != getThreadId(current))  
                cachedHoldCounter = rh = readHolds.get();  
            // TODO：这里没明白，获得然后释放读锁的线程再获取的时候，rh.count == 0？  
            else if (rh.count == 0)  
                readHolds.set(rh);  
            rh.count++;  
        }  
        return 1;  
    }  
    //  类似 tryAcquireShared，但是是自旋获取，代码在下面  
    return fullTryAcquireShared(current);  
}  
  

同样，readerShouldBlock 是 Sync 提供的抽象方法，NonfairSync 的实现：

// NonfairSync  
final boolean readerShouldBlock() {  
    return apparentlyFirstQueuedIsExclusive();  
}  
  
// AQS  
// 如果队列非空，判断第一个元素是不是正在尝试获得写锁  
final boolean apparentlyFirstQueuedIsExclusive() {  
    Node h, s;  
    return (h = head) != null &&	// 如果队列还没添加过元素  
        (s = h.next)  != null &&	// 如果队列非空  
        !s.isShared()         &&	// 如果队列第一个元素试图获取写锁  
        s.thread != null;			// 如果第一个元素内部记录了 thread  
}

// Sync   
final int fullTryAcquireShared(Thread current) {  
    HoldCounter rh = null;  
    for (;;) {  
        int c = getState();  
        if (exclusiveCount(c) != 0) {  
            if (getExclusiveOwnerThread() != current)  
                return -1;  
            // else we hold the exclusive lock; blocking here  
            // would cause deadlock.  
        } else if (readerShouldBlock()) {  
            // Make sure we're not acquiring read lock reentrantly  
            if (firstReader == current) {  
                // assert firstReaderHoldCount > 0;  
            } else {  
                if (rh == null) {  
                    rh = cachedHoldCounter;  
                    if (rh == null || rh.tid != getThreadId(current)) {  
                        rh = readHolds.get();  
                        if (rh.count == 0)  
                            readHolds.remove();  
                    }  
                }  
                if (rh.count == 0)  
                    return -1;  
            }  
        }  
        if (sharedCount(c) == MAX_COUNT)  
            throw new Error("Maximum lock count exceeded");  
        if (compareAndSetState(c, c + SHARED_UNIT)) {  
            if (sharedCount(c) == 0) {  
                firstReader = current;  
                firstReaderHoldCount = 1;  
            } else if (firstReader == current) {  
                firstReaderHoldCount++;  
            } else {  
                if (rh == null)  
                    rh = cachedHoldCounter;  
                if (rh == null || rh.tid != getThreadId(current))  
                    rh = readHolds.get();  
                else if (rh.count == 0)  
                    readHolds.set(rh);  
                rh.count++;  
                cachedHoldCounter = rh; // cache for release  
            }  
            return 1;  
        }  
    }  
}

#### void lockInterruptibly()

public void lockInterruptibly() throws InterruptedException {  
    sync.acquireSharedInterruptibly(1);  
}

#### boolean tryLock()

如果当前己经有其他线程持有写锁则该方法直接返回 false，但当前线程并不会被阻塞。如果当前线程己经持有了该读锁则简单增加 AQS 的状态值高 16 位后直接返回 true。

public boolean tryLock() {  
    return sync.tryReadLock();  
}

#### boolean tryLock(long timeout, TimeUnit unit)

除了有超时之外，该方法会对中断进行响应，也就是当其他线程调用了该线程的 interrupt() 方法中断了当前线程时，当前线程会抛出 InterruptedException 异常。

// ReadLock    
public boolean tryLock(long timeout, TimeUnit unit)  
    	throws InterruptedException {  
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));  
}

#### void unlock()

// ReadLock  
public void unlock() {  
    sync.releaseShared(1);  
}  
  
// AQS  
public final boolean releaseShared(int arg) {  
    if (tryReleaseShared(arg)) { // 如果返回 true，通过 doReleaseShared  
        doReleaseShared();		 // 释放一个因写锁阻塞的线程  
        return true;  
    }  
    return false;  
}  
  
// Sync  
protected final boolean tryReleaseShared(int unused) {  
    Thread current = Thread.currentThread();  
    if (firstReader == current) {  
        // assert firstReaderHoldCount > 0;  
        if (firstReaderHoldCount == 1)  
            firstReader = null;  
        else  
            firstReaderHoldCount--;  
    } else {  
        HoldCounter rh = cachedHoldCounter;  
        if (rh == null || rh.tid != getThreadId(current))  
            rh = readHolds.get();  
        int count = rh.count;  
        if (count <= 1) {  
            readHolds.remove();  
            if (count <= 0)  
                throw unmatchedUnlockException();  
        }  
        --rh.count;  
    }  
    // 循环直到可以让自己的读计数 -1  
    for (;;) {  
        int c = getState();  
        int nextc = c - SHARED_UNIT;  
        if (compareAndSetState(c, nextc))  
            return nextc == 0;  
    }  
}

### 案例

public class ReentrantLockList {  
    private ArrayList<String> array = new ArrayList<>();  
    private volatile ReentrantReadWriteLock lock = new ReentrantReadWriteLock();  
    private final Lock readLock = lock.readLock();  
    private final Lock writeLock = lock.writeLock();  
  
    public void add(String e) {  
        writeLock.lock();  
        try { array.add(e); }   
        finally { writeLock.unlock(); }  
    }  
  
    public void remove(String e) {  
        writeLock.lock();  
        try { array.remove(e); }   
        finally { writeLock.unlock(); }  
    }  
  
    public String get(int index) {  
        readLock.lock();  
        try { return array.get(index); }   
        finally { readLock.unlock(); }  
    }  
}

![image-20210612204041143](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612204041143.png)

## 6.5 StampedLock

### 概述

StampedLock 是 JDK8 新增的，提供了三种模式的读写控制，当调用获取锁的系列函数时，会返回一个 long 型的变量，称之为戳记（stamp），这个戳记代表了锁的状态。其中 try 系列获取锁的函数，当获取锁失败后会返回为 0 的 stamp 值。当调用释放锁和转换锁的方法时需要传入获取锁时返回的 stamp 值。

#### 写锁 writeLock

是一个**不可重入独占锁**，某时只有一个线程可以获取该锁，当一个线程获取该锁后，其他请求读锁和写锁的线程必须等待。请求该锁成功后会返回一个 `stamp` 变量用来表示该锁的版本，当释放该锁时需要调用 `unlockWrite` 方法并传递获取锁时的 `stamp` 参数。并且它提供了非阻塞的 `tryWriteLock` 方法。

#### 悲观读锁 reaLock

是一个不可重入共享锁，在没有线程获取独占写锁的情况下，多个线程可以同时获取该锁。如果已经有线程持有写锁，则其他线程请求获取该读锁会被阻塞。悲观是指在具体操作数据前其会悲观地认为其他线程可能要对自己操作的数据进行修改，所以需要先对数据加锁，这是在**读少写多**的情况下的一种考虑。请求该锁成功后会返回一个 `stamp` 变量用来表示该锁的版本，当释放该锁时需要调用 `unlockRead` 方法并传递 `stamp` 参数。并且它提供了非阻塞的 `tryReadLock` 方法。

#### 乐观读锁 tryOptimisticRead

它是相对于悲观锁来说的，在操作数据前并没有通过 CAS 设置锁的状态，仅仅通过位运算测试。如果当前没有线程持有写锁，则简单地返回一个非 0 的 `stamp` 版本信息。获取该 `stamp` 后在具体操作数据前还需要调用 `validate` 方法验证该 stamp 是否已经不可用，也就是看当调用 `trγOptimisticRead` 返回 `stamp` 后到当前时间期间是否有其他线程持有了写锁，如果是则 `validate` 会返回 0, 否则就可以使用该 `stamp` 版本的锁对数据进行操作。由于 `tryOptimisticRead` 并没有使用 CAS 设置锁状态，所以**不需要显式地释放该锁**。 该锁的一个特点是适用于**读多写少**的场景，因为获取读锁只是使用位操作进行检验，不涉及 CAS 操作，所以效率会高很多，但是同时由于没有使用真正的锁，在保证数据一致性上需要复制一份要操作的变量到方法栈，并且在操作数据时可能其他写线程己经修改了数据，而我们操作的是方法栈里面的数据，也就是一个快照，所以最多返回的不是最新的数据，但是一致性还是得到保障的。

#### 三种锁的转换

StampedLock 还支持这三种锁在一定条件下进行相互转换。例如 `long tryConvertToWriteLock(long stamp)` 期望把 `stamp` 标示的锁升级为写锁，这个函数会在下面几种情况下返回一个有效的 `stamp`（也就是晋升写锁成功）：

-   当前锁已经是写锁了；
    
-   当前锁处于读锁模式，并且没有其他线程是读锁模式（也可能有多个读锁都在升级为写锁，只有一个会成功）；
    
-   当前处于乐观读模式，并且当前写锁可用。
    

StampedLock 三种锁都是不可重入锁；多个线程同时争夺读锁和写锁时，结果是随机的；该锁没有直接实现 `Lock` 或 `ReadWriteLock`，而是在内部维护了一个双向阻塞队列。

### 案例

public class Point {  
    private double x, y;  
    private final StampedLock sl = new StampedLock();  
  
    void move(double deltaX, double deltaY) {  
        long stamp = sl.writeLock();  
        try {  
            x += deltaX;  
            y += deltaY;  
        } finally {  
            sl.unlockWrite(stamp);  
        }  
    }  
  
    // 乐观读锁  
    double distanceFromOrigin() {  
        long stamp = sl.tryOptimisticRead();  
        // 将变量复制到方法体栈内  
        double currentX = x, currentY = y;  
        // 检查获取到 stamp 后，锁有没有被其他写线程排它性抢占  
        // 不能和上一行代码换位置，防止在 validate 通过后，复制变量之前被写锁抢占  
        if (!sl.validate(stamp)) {  
            // 如果被抢占则获取一个悲观读锁  
            stamp = sl.readLock();  
            try {  
                // 将全量复制到方法体栈内  
                currentX = x;  
                currentY = y;  
            } finally {  
                // 释放悲观读锁（乐观读锁不需要释放）  
                sl.unlockRead(stamp);  
            }  
        }  
        return Math.sqrt(currentX * currentX + currentY * currentY);  
    }  
  
    // 使用悲观锁获取读锁，并尝试转换为写锁  
    void moveIfAtOrigin(double newX, double newY) {  
        // 这里可以用乐观读锁替换  
        long stamp = sl.readLock();  
        try {  
            // 如果当前点在原点则易懂  
            while (x == 0.0 && y == 0.0) {  
                // 尝试将获取的读锁升级为写锁  
                long ws = sl.tryConvertToWriteLock(stamp);  
                // 升级成功，更新 stamp，并设置新坐标，然后退出循环  
                if (ws != 0L) {  
                    stamp = ws;  
                    x = newX;  
                    y = newY;  
                    break;  
                } else {  
                    // 升级写锁失败，释放读锁，显式获取独占写锁，然后进行循环  
                    sl.unlockRead(stamp);  
                    stamp = sl.writeLock();  
                }  
            }  
        } finally {  
            sl.unlock(stamp);  
        }  
    }  
}

1.  readLock 和 writeLock 都会阻塞，但 tryOptimisticRead 不会；
    
2.  在 tryOptimisticRead 之后，validate 之前，将变量复制到本地方法栈里；
    
3.  即使在 validate 通过之后，拿到的数据也可能会变成不是最新的；
    
4.  变量不需要 volatie，加锁的语义保证了内存的可见性。
    

乐观读锁的一般使用顺序：

long stamp = lock.tryOptimisticRead();  
copyVariable2ThreadMemory();  
if (!sl.validate(stamp)) {  
    stamp = lock.readLock();  
    try {  
        copyVariable2ThreadMemory();  
    } finally {  
        lock.unlockRead(stamp);  
    }  
}  
useThreadMemoryVarables();

### 总结

StampedLock 提供的读写锁与 ReentrantReadWriteLock 类似，只是前者提供的是不可重入锁。但是前者通过提供乐观读锁在多线程多读的情况下提供了更好的性能，这是因为获取乐观读锁时不需要进行 CAS 操作设置锁的状态，而只是简单地测试状态。

![image-20210612211814101](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612211814101.png)

# 7. 并发队列原理

## 7.1 ConcurrentLinkedQueue

`ConcurrentLinkedQueue` 是线程安全的无界非阻塞队列，其底层数据结构使用单向链表实现，对于入队和出队操作使用 CAS 来实现线程安全。

### 7.1.1 类图

![Screen Shot 2021-06-28 at 21.53.52](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-28%20at%2021.53.52.png)

`ConcurrentLinkedQueue` 内部的队列使用单向链表方式实现，其中有两个 `volatile` 类型的 `Node` 节点分别用来存放队列的首、尾节点。从下面的无参构造函数可知，默认头、尾节点都是指向 `item` 为 null 的**哨兵节点**。新元素会被插入队列末尾，出队时从队列头部获取一个元素。

public ConcurrentLinkedQueue() {  
    head = tail = new Node<E>(null);  
}

在 `Node` 节点内部则维护一个使用 volatile 修饰的变量 `item`，用来存放节点的值；`next` 用来存放链表的下一个节点，从而链接为一个单向无界链表。其内部则使用 `UnSafe` 工具类提供的 CAS 算法来保证出入队时操作链表的原子性。

### 原理

#### offer

`offer` 是在队列末尾添加一个元素，除非参数是 `null` 会抛 NPE，否则会一直返回 true。另外，由于使用了 CAS 无阻塞算法，因此该方法不会阻塞刮起线程。

public boolean offer(E e) {  
    checkNotNull(e);  
    // 2. 构造Node节点，在构造函数内部调用 unsafe.putObject  
    final Node<E> newNode = new Node<E>(e);  
      
    // 3. 从尾节点进行插入  
    for (Node<E> t = tail, p = t;;) {  
        Node<E> q = p.next;  
        // 4. 如采 q==null 说明 p 是尾节点，则执行插入  
        if (q == null) {  
            // 5. 使用CAS设置p节点的next节点  
            if (p.casNext(null, newNode)) {  
                // 6. CAS成功，则说明新增节点已经被放入链表，然后设置当前尾节点  
                // (包含head，第 1, 3, 5. . .个节点为尾节点)  
                if (p != t) // hop two nodes at a time  
                    casTail(t, newNode);  // Failure is OK.  
                return true;  
            }  
            // Lost CAS race to another thread; re-read next  
        }  
        else if (p == q)  
            // 7. 多线程操作时，由于poll操作移除元素后可能会把head变为自引用  
            // ，也就是head的 next变成了 head，所以这里需要  
            // 重新找新的 head  
            p = (t != (t = tail)) ? t : head;  
        else  
            // 8. 寻找尾节点  
            p = (p != t && t != (t = tail)) ? t : q;  
    }  
}

##### 单线程

首先执行代码 2 并使用 item 作为构造函数参数创建一 个新的节点，然后代码 3 从队列尾部节点开始循环，打算从队列尾部添加元素，当执行到代码 4 时队列状态如下图所示。

![Screen Shot 2021-07-06 at 23.01.26](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.01.26.png)

这时候节点 p、 t、 head、 tail 同时指向了 item 为 null 的哨兵节点，由于哨兵节点的 next 节点为 null，所以这里 q 也指向 null。 代码 4 发现 `q==null` 则执行代码 5，通过 CAS 原子操作判断 p 节点的 next 节点是否为 null，如果为 null 则使用节点 `newNode` 替换 p 的 next 节点，然后执行代码 6，这里由于 `p==t` 所以没有设置尾部节点，然后退出 `offer` 方法，这时候队列的状态如下图所示。

![Screen Shot 2021-07-06 at 23.03.03](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.03.03.png)

##### 多线程

假设线程 A 调用 `offer(item1)`，线程 B 调用 `offer(item2)`，同时执行到代码 5，线程 A 先执行了比较设置操作，发现当前 p 的 next 节点确实是 null，则会原子性地更新 next 节点为 item1，这时候线程 B 也会判断 p 的 next 节点是否为 null，结果发现不是 null，则跳到代码 3，然后执行到代码 4，这时候的队列分布如下图所示。

![Screen Shot 2021-07-06 at 23.22.39](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.22.39.png)

然后线程 B 执行代码 8，因为 `p == t`，所以将 q 赋给 p。这时候的队列分布如下图所示。

![Screen Shot 2021-07-06 at 23.24.31](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.24.31.png)

然后线程 B 再次跳到代码 3 执行，当执行到代码 4 时，队列状态如下图所示。

![Screen Shot 2021-07-06 at 23.25.22](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.25.22.png)

由于这时候 `q == null`，所以线程 B 会执行代码 5，通过 CAS 操作判断当前 p 的 next 节点是否是 null，不是则再次循环尝试 ， 是则使用 item2 替换。 假设 CAS 成功了，那么执行代码 6，由于 `p != t`， 所以设置 `tail` 节点为 item2，然后退出 `offer` 方法。 这时候队列分布如下图所示。

![Screen Shot 2021-07-06 at 23.26.46](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.26.46.png)

##### 执行 poll 可能发生的情况

分析到现在，就差代码 7 还没走过，其实这一步要在执行 `poll` 操作后才会执行 。这里先来看一下执行 `poll` 操作后可能会存在的一种情况，如下图所示。

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.28.04.png" alt="Screen Shot 2021-07-06 at 23.28.04" style="zoom:50%;" />

此时调用 `offer`，执行到代码 4 时的状态图如下。

![Screen Shot 2021-07-06 at 23.28.49](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.28.49.png)

这里由于 q 节点不为空并且 `p == q` 所以执行代码 7，由于 `t == tail` 所以 p 被赋值为 head，然后重新循环，循环后执行到代码 4，这时候队列状态如下图所示。

![Screen Shot 2021-07-06 at 23.30.29](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.30.29.png)

这时候由于 `q == null`，所以执行代码 5 进行 CAS 操作，如果当前没有其他线程执行 `offer` 操作，则 CAS 操作会成功， p的next节点被设置为新增节点。 然后执行代码 (6)' 由于 p!=t 所以设置新节点为队列的尾部节点，现在队列状态如图 7-11 所示。

#### add

`add` 就是在内部调用 `offer`。

public boolean add(E e) {  
    return offer(e);  
}

#### poll

`poll` 操作是在队列头部获取并移除一个元素，如果队列为空则返回 null。

public E poll() {  
    // 1. goto 标记  
    restartFromHead:  
      
    // 2. 无限循环  
    for (;;) {  
        for (Node<E> h = head, p = h, q;;) {  
            // 3. 保存当前节点值  
            E item = p.item;  
              
            // 4. 当前节点有值则 CAS 变为 null  
            if (item != null && p.casItem(item, null)) {  
                // 5. CAS 成功则标记当前节点并从链表中移除  
                if (p != h) // hop two nodes at a time  
                    updateHead(h, ((q = p.next) != null) ? q : p);  
                return item;  
            }  
            // 6. 当前队列为空则返回 null  
            else if ((q = p.next) == null) {  
                updateHead(h, p);   
                return null;  
            }  
            // 7. 如采当前节点被自引用了， 则重新寻找新的队列头节点  
            else if (p == q)  
                continue restartFromHead;  
            else   
                p = q;  
        }  
    }  
}  
    
final void updateHead(Node<E> h, Node<E> p) {  
    if (h != p && casHead(h, p))  
        h.lazySetNext(h);  
}

(1). 队列一开始为空时队列状态如下图所示。

![Screen Shot 2021-07-07 at 21.26.09](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.26.09.png)

由于 `head` 节点指向的是 item 为 null 的哨兵节点，所以会执行到代码 6，假设这个过程中没有线程调用 offer方法，则此时 q 等于 null，这时候队列状态如下图所示。

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.27.59.png" alt="Screen Shot 2021-07-07 at 21.27.59" style="zoom:50%;" />

所以会执行 `updateHead` 方法，由于 `h` 等于 `p` 所以没有设置头节点，`poll` 方法直接返回 null。

(2). 假设执行到代码 6 时已经有其他线程调用了 offer 方法并成功添加一个元素到队列，这时候 q 指向的是新增元素的节点，此时队列状态如下图所示。

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.29.58.png" alt="Screen Shot 2021-07-07 at 21.29.58" style="zoom:50%;" />

所以代码 6 判断的结果为 false，然后会转向执行代码 7，而此时 p 不等于 q，所以转向执行代码 8，此时队列状态如下图所示。

![Screen Shot 2021-07-07 at 21.31.24](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.31.24.png)

然后程序转向执行代码 3，p 现在指向的元素值不为 null，则执行 `p.casltem(item, null)` 通过 CAS 操作尝试设置 p 的 item 值为 null，如果此时没有其 他线程进行 `poll` 操作， 则 CAS 成功会执行代码 5，由于此时 `p != h` 所以设置头节点为 p，并设置 h 的 next 节点 为 h 自己， poll 然后返回被从队列移除的节点值 item。 此时队列状态如下图所示。

# 8. ThreadPoolExecutor

## 8.1 介绍

线程池主要解决两个问题：一是当执行大量异步任务时线程池能够提供较好的性能。在不使用线程池时，每当需要执行异步任务时直接 new 一个线程来运行，而线程的创建和销毁是需要开销的。线程池里面的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。二是线程i也提供了一种资源限制和管理的手段，比如可以限制线程的个数，动态新增线程等。每个 `ThreadPoolExecutor` 也保留了一些基本的统计数据，比如当前线程池完成的任务数目等。

另外， 线程池也提供了许多可调参数和可扩展性接口，以满足不同情境的需要，也可以使用的 `Executors` 的工厂方法，比如 `newCachedThreadPool` （线程池线程个数最多可达 `Integer.MAX_VALUE`，线程自动回收)、`newFixedThreadPool` （固定大小的线程池）和 `newSingleThreadExecutor` （单个线程）等来创建线程池，也还可以自定义。

## 8.2 类图

![Screen Shot 2021-07-07 at 21.55.06](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.55.06.png)

`Executors` 是个工具类，提供了多个静态方法，根据用户选择返回不同的线程池实例。 `ThreadPoolExecutor` 继承了 `AbstractExecutorService`，成员变量 `Atomic ctl`，用来记录线程池状态和线程池中线程个数，类似于 `ReentrantReadWriteLock` 使用一个变量来保存两种信息。

这里假设 Integer 类型是 32 位二进制表示，则其中高 3 位用来表示线程池状态，后面 29 位用来记录线程池线程个数。

// (高3位)用来表示线程池状态， (低29位)用来表示线程个数  
// 默认是 RUNNING状态，线程个数为 0  
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  
  
// 线程个数掩码位数，并不是所有平台的 int 的类型都是 32 位的，所以准确地说，   
// 是具体平台下 Integer 的二进制位数 -3 后的剩余位数所表示的数才是线程的个数  
private static final int COUNT_BITS = Integer.SIZE - 3;  
  
// 线程最大个数（低29位） 00011111111111111111111111111111  
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

线程池状态：

// (高3位) : 11100000000000000000000000000000  
private static final int RUNNING    = -1 << COUNT_BITS;  
  
// (高3位) : 00000000000000000000000000000000  
private static final int SHUTDOWN   =  0 << COUNT_BITS;  
  
// (高3位) : 00100000000000000000000000000000  
private static final int STOP       =  1 << COUNT_BITS;  
  
// (高3位) : 01000000000000000000000000000000  
private static final int TIDYING    =  2 << COUNT_BITS;  
  
// (高3位) : 01100000000000000000000000000000  
private static final int TERMINATED =  3 << COUNT_BITS;  
  
// 获取高3位(运行状态)  
private static int runStateOf(int c)     { return c & ~CAPACITY; }  
  
// 获取低29位(线程个数)  
private static int workerCountOf(int c)  { return c & CAPACITY; }  
  
// 计算ctl新值(线程状态与线程个数 )  
private static int ctlOf(int rs, int wc) { return rs | wc; }

线程池状态含义如下：

-   RUNNING：接受新任务并且处理阻塞队列里的任务。
    
-   SHUTDOWN：拒绝新任务但是处理阻塞队列里的任务 。
    
-   STOP：拒绝新任务并且抛弃阻塞队列里的任务，同时会中断正在处理的任务。
    
-   TIDYING：所有任务都执行完（包含阻塞队列里面的任务）后当前线程池活动线程数为 0，将要调用 `terminated` 方法。
    
-   TERMINATED：终止状态。`terminated` 方法调用完成以后的状态 。
    

线程池状态转换列举如下 。

-   RUNNING -> SHUTDOWN：显式调用 `shutdown()` 方法， 或者隐式调用了 `finalize()`方法里面的 `shutdown()` 方法。
    
-   RUNNING 或 SHUTDOWN -> STOP : 显式调用 `shutdownNow()` 方法时。
    
-   SHUTDOWN -> TIDYING：当线程池和任务队列都为空时。
    
-   STOP->TIDYING：当线程池为空时。
    
-   TIDYING -> TERMINATED：当 `terminated()` hook 方法执行完成 时 。
    

线程池参数如下。

-   corePoolSize：线程池核心线程个数。
    
-   workQueue：用于保存等待执行的任务的阻 塞 队列，比如基于数组的有界 `ArrayBlockingQueue`、基于链表的无界 `LinkedBlockingQueue`、最多只有一个元素的同步队列 `SynchronousQueue` 及优先级队列 `PriorityBlockingQueue` 等。
    
-   maximunPoolSize：线程池最大线程数量。
    
-   ThreadFactory：创建线程的工厂。
    
-   RejectedExecutionHandler：饱和策略，当队列满并且线程个数达到 maximunPoolSize 后采取的策略，比如 AbortPolicy （抛出异常）、CallerRunsPolicy（使用调用者所在线程来运行任务）、DiscardOldestPolicy（调用 poll 丢弃一个任务，执行当前任务）及 DiscardPolicy（默默丢弃，不抛出异常）
    
-   keeyAliveTime：存活时间。如果当前线程池中的线程数量比核心线程数量多，并且是闲置状态，则这些闲置的线程能存活的最大时间。
    
-   TimeUnit：存活时间的时间单位 。
    
    线程池类型如下 。
    
    • newFixedThreadPool :创建一个核心线程个数和最大线程个数都为 nThreads 的线程 池，并且阻 塞 队列 长度为 Integer.
