---
tags: ğŸ“¥ï¸/ğŸ“šï¸/ğŸŸ¥ï¸
aliases:
type: book
status: ğŸŸ¥ï¸
created: 2022-05-05 15-54
updated: 2022-06-01 22-15
---

# Title: [[{ 2021-08 Java å¹¶å‘ç¼–ç¨‹ä¹‹ç¾]]

## Metadata
- `Topics:` [[Java]] [[Concurrency]]
- `Title:` [[{ 2021-08 Java å¹¶å‘ç¼–ç¨‹ä¹‹ç¾]]
- `Type:` [[{]]
- `Publish Date:` 
- `Reviewed Date:` [[2022-05-05]]

## Note

# 1. å¹¶å‘ç¼–ç¨‹çº¿ç¨‹åŸºç¡€

## 1.1 ä»€ä¹ˆæ˜¯çº¿ç¨‹

## 1.2 çº¿ç¨‹åˆ›å»ºä¸è¿è¡Œ

### ç»§æ‰¿ Thread

1

 Â  Â public static class MyThread extends Thread {

2

 Â  Â  Â  Â @Override

3

 Â  Â  Â  Â public void run() {

4

 Â  Â  Â  Â  Â  Â System.out.println("I am a child thread");

5

 Â  Â  Â   }

6

 Â   }

7

 Â  Â public static void main(String[] args){

8

 Â  Â  Â  Â MyThread thread = new MyThread();

9

 Â  Â  Â  Â thread.start();

10

 Â   }

è°ƒç”¨ start æ–¹æ³•åï¼Œçº¿ç¨‹å¤„äºå°±ç»ªæ€ã€‚

-   ä½¿ç”¨ç»§æ‰¿æ–¹å¼çš„å¥½å¤„æ˜¯ï¼Œåœ¨ `run()` æ–¹æ³•å†…è·å–å½“å‰çº¿ç¨‹ç›´æ¥ä½¿ç”¨ `this` å°±å¯ä»¥äº†ï¼Œæ— é¡»ä½¿ç”¨ `Thread.currentThread()` æ–¹æ³•ï¼›
    
-   ä¸å¥½çš„åœ°æ–¹æ˜¯ Java ä¸æ”¯æŒå¤šç»§æ‰¿ã€‚å¦å¤–ä»»åŠ¡ä¸ä»£ç æ²¡æœ‰åˆ†ç¦» ï¼Œ å½“å¤šä¸ªçº¿ç¨‹æ‰§è¡Œä¸€æ ·çš„ä»»åŠ¡æ—¶éœ€è¦å¤šä»½ä»»åŠ¡ä»£ç ï¼Œè€Œ `Runnable` åˆ™æ²¡æœ‰è¿™ä¸ªé™åˆ¶ã€‚
    

### å®ç° Runnable æ¥å£çš„ run æ–¹æ³•

1

    public static class RunnableTask implements Runnable {

2

 Â  Â  Â  Â @Override

3

 Â  Â  Â  Â public void run() {

4

 Â  Â  Â  Â  Â  Â System.out.println("I am a child thread");

5

 Â  Â  Â   }

6

 Â   }

7

 Â  Â public static void main(String[] args){

8

 Â  Â  Â  Â RunnableTask task = new RunnableTask();

9

 Â  Â  Â  Â new Thread(task).start();

10

 Â  Â  Â  Â new Thread(task).start();

11

 Â   }

-   ä¸¤ä¸ªçº¿ç¨‹å…±ç”¨ä¸€ä¸ª task ä»£ç é€»è¾‘ï¼Œå¦‚æœéœ€è¦ ï¼Œå¯ä»¥ç»™ RunableTask æ·»åŠ å‚æ•°è¿›è¡Œä»»åŠ¡åŒºåˆ†ã€‚
    
-   RunableTask å¯ä»¥ç»§æ‰¿å…¶ä»–ç±»ã€‚
    

### FutureTask

ä¸Šè¿°ä¸¤ç§æ–¹æ³•éƒ½æœ‰ä¸€ä¸ªç¼ºç‚¹ï¼Œä»»åŠ¡æ²¡æœ‰è¿”å›å€¼ã€‚

	public static class CallerTask implements Callable<String> {  
        @Override  
        public String call() throws Exception {  
            return "hello";  
        }  
    }  
  
    public static void main(String[] args) {  
        // åˆ›å»ºå¼‚æ­¥ä»»åŠ¡  
        FutureTask<String> futureTask = new FutureTask<>(new CallerTask());  
        new Thread(futureTask).start();  
        try {  
            // ç­‰å¾…ä»»åŠ¡æ‰§è¡Œå®Œæ¯•è¿”å›è®°è¿‡  
            String result = futureTask.get();  
            System.out.println(result);  
        } catch (InterruptedException | ExecutionException e) {  
            e.printStackTrace();  
        }  
    }

## 1.3 çº¿ç¨‹é€šçŸ¥ä¸ç­‰å¾…

### wait()

è°ƒç”¨ `wait()` æ–¹æ³•çš„çº¿ç¨‹ä¼šè¢«é˜»å¡æŒ‚èµ·ï¼Œç›´åˆ°å‘ç”Ÿäº†ä¸‹é¢äº‹ä»¶ä¹‹ä¸€ï¼š

-   å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†è¯¥å¯¹è±¡çš„ notify() æˆ–è€… notifyAll() æ–¹æ³•ï¼›
    
-   å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†è¯¥çº¿ç¨‹çš„ interrupt() æ–¹æ³•ï¼Œè¯¥çº¿ç¨‹æŠ›å‡º `InterruptedException` å¼‚å¸¸è¿”å›ã€‚
    
    	static Object obj = new Object();  
      
        public static void main(String[] args) throws InterruptedException {  
            Thread thread = new Thread(() -> {  
                try {  
                    System.out.println("---begin---");  
                    synchronized (obj) {  
                        obj.wait();  
                    }  
                    System.out.println("---end---");  
                } catch (InterruptedException e) {  
                    e.printStackTrace();  
                }  
            });  
            thread.start();  
            Thread.sleep(1000);  
      
            System.out.println("---begin interrupt thread");  
            thread.interrupt();  
            System.out.println("---end interrupt thread");  
        }  
    è¾“å‡ºï¼š  
    ---begin---  
    ---begin interrupt thread  
    ---end interrupt thread  
    java.lang.InterruptedException  
    	at java.lang.Object.wait(Native Method)  
    	at java.lang.Object.wait(Object.java:502)  
    	at com.chenghuipeng.learning.ProducerAndCustomer.lambda$main$0(ProducerAndCustomer.java:16)  
    	at java.lang.Thread.run(Thread.java:748)
    

å¦‚æœè°ƒç”¨ wait() æ–¹æ³•çš„çº¿ç¨‹æ²¡æœ‰äº‹å…ˆè·å–è¯¥å¯¹è±¡çš„ç›‘è§†å™¨é”ï¼Œåˆ™è°ƒç”¨ wait() æ–¹æ³•æ—¶è°ƒç”¨çº¿ç¨‹ä¼šæŠ›å‡º `IllegalMonitorStateException` å¼‚å¸¸ã€‚

è·å–å…±äº«å˜é‡ç›‘è§†å™¨é”çš„æ–¹æ³•ï¼š

1.  synchronized (å…±äº«å˜é‡) { doSomething() }
    
2.  è°ƒç”¨è¯¥å…±äº«å˜é‡çš„ synchronized æ–¹æ³•ã€‚
    

**è™šå‡å”¤é†’**ï¼šä¸€ä¸ªçº¿ç¨‹å¯ä»¥ä»æŒ‚èµ·çŠ¶æ€å˜ä¸ºå¯ä»¥è¿è¡ŒçŠ¶æ€ï¼Œå³ä½¿è¯¥çº¿ç¨‹æ²¡æœ‰è¢«å…¶ä»–çº¿ç¨‹è°ƒç”¨ notify()ã€notifyAll() æ–¹æ³•è¿›è¡Œé€šçŸ¥ï¼Œæˆ–è€…è¢«ä¸­æ–­ï¼Œæˆ–è€…ç­‰å¾…è¶…æ—¶ã€‚è™½ç„¶å¾ˆå°‘å‘ç”Ÿï¼Œä½†å¿…é¡»è¦é˜²æ‚£äºæœªç„¶ï¼š

// æ ‡å‡†å½¢å¼  
synchronized (obj) {  
    while (è¢«å”¤é†’æ¡ä»¶ä¸æ»¡è¶³) {  
        obj.wait();  
    }  
}

ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…çš„ç®€å•ä¾‹å­ï¼š

// ç”Ÿäº§çº¿ç¨‹  
synchronized (queue) {  
	//æ¶ˆè´¹é˜Ÿåˆ—æ»¡ï¼Œè´1Jç­‰å¾…é˜Ÿåˆ—ç©ºé—²  
	while (queue.size() == MAX SIZE) {  
		try {  
			//æŒ‚èµ·å½“å‰çº¿ç¨‹ï¼Œ å¹¶é‡Šæ”¾é€šè¿‡åŒæ­¥å—è·å–çš„ queue ä¸Šçš„é”ï¼Œè®©æ¶ˆè´¹è€…çº¿ç¨‹å¯ä»¥è·å–è¯¥é”ï¼Œç„¶åè·å–é˜Ÿåˆ—é‡Œé¢çš„å…ƒç´   
			queue .wait() ;  
		} catch (Exception ex) {  
			ex.prå·¥ntStackTrace() ;  
        }  
    }  
	//ç©ºé—²åˆ™ç”Ÿæˆå…ƒç´  ï¼Œ å¹¶é€šçŸ¥æ¶ˆè´¹è€…çº¿ç¨‹  
	queue.add(ele);  
    queue.notifyAll();  
}  
  
// æ¶ˆè´¹è€…çº¿ç¨‹  
synchronized (queue) {  
	//æ¶ˆè´¹é˜Ÿåˆ—ä¸ºç©º  
	while (queue.size() == 0) {  
		try {  
			//æŒ‚èµ·å½“å‰çº¿ç¨‹ï¼Œ å¹¶é‡Šæ”¾é€šè¿‡åŒæ­¥å—è·å–çš„ queue ä¸Šçš„é”ï¼Œè®©ç”Ÿäº§è€…çº¿ç¨‹å¯ä»¥è·å–è¯¥é”ï¼Œå°†ç”Ÿäº§å…ƒç´ æ”¾å…¥é˜Ÿåˆ—  
			queue.wait() ;  
		} catch (Exception ex) {  
			ex.prå·¥ntStackTrace() ;  
        }  
    }  
	//æ¶ˆè´¹å…ƒç´ ï¼Œå¹¶é€šçŸ¥å”¤é†’ç”Ÿäº§è€…çº¿ç¨‹  
	queue.take();  
    queue.notifyAll();  
}

çº¿ç¨‹è°ƒç”¨å…±äº«å˜é‡çš„ wait() æ–¹æ³•ååªä¼šé‡Šæ”¾å½“å‰å…±äº«å˜é‡ä¸Šçš„é”ï¼Œå¦‚æœå½“å‰çº¿ç¨‹è¿˜æŒæœ‰å…¶ä»–å…±äº«å˜é‡çš„é”ï¼Œåˆ™è¿™äº›é”æ˜¯ä¸ä¼šè¢«é‡Šæ”¾çš„ã€‚

### wait(long timeout)

å¦‚æœä¸€ä¸ªçº¿ç¨‹è°ƒç”¨å…±äº«å¯¹è±¡çš„è¯¥æ–¹æ³•æŒ‚èµ·åï¼Œæ²¡æœ‰åœ¨æŒ‡å®šçš„ `timeout` ms æ—¶é—´å†…è¢«å…¶ä»–çº¿ç¨‹è°ƒç”¨è¯¥å…±äº«å˜é‡çš„ notify() æˆ–è€… notifyAll() æ–¹æ³•å”¤é†’ï¼Œé‚£ä¹ˆè¯¥å‡½æ•°è¿˜æ˜¯ä¼šå› ä¸ºè¶…æ—¶è€Œè¿”å›ã€‚å¦‚æœå°† timeout è®¾ ç½®ä¸º 0 åˆ™å’Œ wait æ–¹æ³•æ•ˆæœ ä¸€ æ ·ï¼Œå› ä¸ºåœ¨ wait æ–¹æ³•å†…éƒ¨å°±æ˜¯è°ƒç”¨äº† wait(0)ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœåœ¨è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œ ä¼ é€’äº†ä¸€ä¸ªè´Ÿçš„ timeout åˆ™ä¼šæŠ›å‡º `IllegalArgumentException` å¼‚å¸¸ã€‚

### wait(long timeout, int nanos)

åœ¨å…¶å†…éƒ¨è°ƒç”¨çš„æ˜¯ wait(long timeout) å‡½æ•°ï¼Œå¦‚ä¸‹æºç åªæœ‰åœ¨ nanos>0 æ—¶æ‰ä½¿å‚æ•° timeout é€’å¢ 1ã€‚

	public final void wait(long timeout, int nanos) throws InterruptedException {  
        if (timeout < 0) {  
            throw new IllegalArgumentException("timeout value is negative");  
        }  
  
        if (nanos < 0 || nanos > 999999) {  
            throw new IllegalArgumentException("nanosecond timeout value out of range");  
        }  
  
        if (nanos > 0) {  
            timeout++;  
        }  
  
        wait(timeout);  
    }

### notify()

ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨å…±äº«å¯¹è±¡çš„ notify() æ–¹æ³•åï¼Œä¼š**éšæœº**å”¤é†’ä¸€ä¸ªåœ¨è¯¥å…±äº«å˜é‡ä¸Šè°ƒç”¨ wait ç³»åˆ—æ–¹æ³•åè¢«æŒ‚èµ·çš„çº¿ç¨‹ã€‚

æ­¤å¤–ï¼Œè¢«å”¤é†’çš„çº¿ç¨‹ä¸èƒ½é©¬ä¸Šä» wait æ–¹æ³•è¿”å›å¹¶ç»§ç»­æ‰§è¡Œï¼Œå®ƒå¿…é¡»åœ¨è·å–äº†å…±äº«å¯¹è±¡çš„ç›‘è§†å™¨é”åæ‰å¯ä»¥è¿”å›ï¼Œä¹Ÿå°±æ˜¯å”¤é†’å®ƒçš„çº¿ç¨‹é‡Šæ”¾äº†å…±äº«å˜é‡ä¸Šçš„ç›‘è§†å™¨é”åï¼Œè¢«å”¤é†’çš„çº¿ç¨‹ä¹Ÿä¸ä¸€å®šä¼šè·å–åˆ°å…±äº«å¯¹è±¡çš„ç›‘è§†å™¨é”ï¼Œè¿™æ˜¯å› ä¸ºè¯¥çº¿ç¨‹è¿˜éœ€è¦å’Œå…¶ä»–çº¿ç¨‹ä¸€èµ·ç«äº‰è¯¥é”ï¼Œåªæœ‰è¯¥çº¿ç¨‹ç«äº‰åˆ°äº†å…±äº«å˜é‡çš„ç›‘è§†å™¨é”åæ‰å¯ä»¥ç»§ç»­æ‰§è¡Œã€‚

ç±»ä¼¼ wait ç³»åˆ—æ–¹æ³•ï¼Œåªæœ‰å½“å‰çº¿ç¨‹è·å–åˆ°äº†å…±äº«å˜é‡çš„ç›‘è§†å™¨é”åï¼Œæ‰å¯ä»¥è°ƒç”¨å…±äº«å˜é‡çš„ notify() æ–¹æ³•ï¼Œå¦åˆ™ä¼šæŠ›å‡º `IllegalMonitorStateException` å¼‚å¸¸ã€‚

### notifyAll()

notifyAll() æ–¹æ³•ä¼šå”¤é†’æ‰€æœ‰åœ¨è¯¥å…±äº«å˜é‡ä¸Šç”±äºè°ƒç”¨ wait ç³»åˆ—æ–¹æ³•è€Œè¢«æŒ‚èµ·çš„çº¿ç¨‹ã€‚

notify() å’Œ notifyAll() åŒºåˆ«å¦‚ä¸‹ã€‚

private static volatile Object resourceA = new Object();    public static void main(String[] args) throws InterruptedException {        Thread threadA = new Thread(() -> {            synchronized (resourceA) {                System.out.println("threadA get resourceA lock");                try {                    System.out.println("threadA begin wait");                    resourceA.wait();                    System.out.println("threadA end wait");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        Thread threadB = new Thread(() -> {            synchronized (resourceA) {                System.out.println("threadB get resourceA lock");                try {                    System.out.println("threadB begin wait");                    resourceA.wait();                    System.out.println("threadB end wait");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        });        Thread threadC = new Thread(() -> {            synchronized (resourceA) {                System.out.println("threadC begin notify");                resourceA.notify();            }        });        threadA.start();        threadB.start();        Thread.sleep(1000);        threadC.start();        threadA.join();        threadB.join();        threadC.join();        System.out.println("main over");    }è¾“å‡ºï¼šthreadA get resourceA lockthreadA begin waitthreadB get resourceA lockthreadB begin waitthreadC begin notifythreadA end wait

threadC çš„ notify() éšæœºå”¤é†’äº† threadAï¼ŒthreadA ä»é˜»å¡è½¬æˆå°±ç»ªï¼Œå¹¶åœ¨ threadC é‡Šæ”¾é”ä¹‹å threadA è·å¾—é”å¹¶æ‰§è¡Œï¼ŒthreadA é‡Šæ”¾é”ä¹‹åï¼Œå› ä¸º threadB æŒ‚èµ·ï¼Œæ‰€ä»¥å¹¶ä¸èƒ½è·å¾—é”ã€‚æ”¹æˆ notifyAll() ä¹‹åï¼š

è¾“å‡ºï¼šthreadA get resourceA lockthreadA begin waitthreadB get resourceA lockthreadB begin waitthreadC begin notifythreadB end waitthreadA end waitmain over

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒnotifyAll() åªèƒ½å”¤é†’è¿™ä¸ªæ–¹æ³•è¢«è¢«è°ƒç”¨ä¹‹å‰å›  wait é˜»å¡çš„çº¿ç¨‹ã€‚

## 1.4 ç­‰å¾…çº¿ç¨‹æ‰§è¡Œç»ˆæ­¢çš„ join æ–¹æ³•

join æ–¹æ³•å¯ä»¥ç­‰å¾…çº¿ç¨‹æ‰§è¡Œå®Œæ¯•ï¼Œè¯¥æ–¹æ³•æ˜¯ Thread ç±»ç›´æ¥æä¾›çš„æ— å‚ void æ–¹æ³•ã€‚

	public static void main(String[] args) throws InterruptedException {        Thread threadA = new Thread(() -> {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("threadA over");        });        Thread threadB = new Thread(() -> {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println("threadB over");        });        threadA.start();        threadB.start();        System.out.println("wait all child thread over");        threadA.join();        threadB.join();        System.out.println("all child thread over");    }è¾“å‡ºï¼šwait all child thread overthreadA overthreadB overall child thread over

ä¸»çº¿ç¨‹è°ƒç”¨ threadA.join ä¹‹åä¼šè¢«é˜»å¡ï¼Œç­‰åˆ° threadA æ‰§è¡Œå®Œåæ‰ä¼šè¿”å›ã€‚ä¹‹åè°ƒç”¨ threadB.join å†æ¬¡è¢«é˜»å¡ï¼Œç­‰å¾… threadB æ‰§è¡Œå®Œæˆåè¿”å›ã€‚

> è¿™é‡Œåªæ˜¯ä¸ºäº†æ¼”ç¤º join çš„ç”¨æ³•ï¼Œåé¢è®²åˆ°çš„ CountDownLatch ä¼šæ›´å¥½ç”¨ã€‚

å¦å¤–ï¼Œçº¿ç¨‹ A è°ƒç”¨çº¿ç¨‹ B çš„ join æ–¹æ³•åä¼šè¢«é˜»å¡ï¼Œå½“å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†çº¿ç¨‹ A çš„ interrupt() æ–¹æ³•ä¸­æ–­äº†çº¿ç¨‹ A æ—¶ï¼Œçº¿ç¨‹ A ä¼šæŠ›å‡º `InterruptedException` å¼‚å¸¸è€Œè¿”å›ï¼š

	public static void main(String[] args) {        Thread threadA = new Thread(() -> {            System.out.println("threadA run");            while (true) { }        });        Thread mainThread = Thread.currentThread();        Thread threadB = new Thread(() -> {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            mainThread.interrupt();        });        threadA.start();        threadB.start();        try {            threadA.join();        } catch (InterruptedException e) {            System.out.println("main thread: " + e);        }    }

## 1.5 è®©çº¿ç¨‹ç¡çœ çš„ sleep æ–¹æ³•

Thread ç±»ä¸­æœ‰ä¸€ä¸ªé™æ€çš„ sleepæ–¹æ³•ï¼Œå½“ä¸€ä¸ªæ‰§è¡Œä¸­çš„çº¿ç¨‹è°ƒç”¨äº† Thread çš„ sleep æ–¹æ³•åï¼Œè°ƒç”¨çº¿ç¨‹ä¼šæš‚æ—¶è®©å‡ºæŒ‡å®šæ—¶é—´çš„æ‰§è¡Œæƒï¼Œä¹Ÿå°±æ˜¯åœ¨è¿™æœŸé—´ä¸å‚ä¸ CPU çš„è°ƒåº¦ï¼Œä½†æ˜¯è¯¥çº¿ç¨‹æ‰€æ‹¥æœ‰çš„ç›‘è§†å™¨èµ„æºï¼Œæ¯”å¦‚é”è¿˜æ˜¯æŒæœ‰ä¸è®©å‡ºçš„ã€‚æŒ‡å®šçš„ç¡çœ æ—¶é—´åˆ°äº†åè¯¥å‡½æ•°ä¼šæ­£å¸¸è¿”å›ï¼Œçº¿ç¨‹å°±å¤„äºå°±ç»ªçŠ¶æ€ï¼Œç„¶åå‚ä¸ CPU çš„è°ƒåº¦ï¼Œè·å–åˆ° CPU èµ„æºåå°±å¯ä»¥ç»§ç»­è¿è¡Œäº†ã€‚

å¦‚æœåœ¨ç¡çœ æœŸé—´å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†è¯¥çº¿ç¨‹çš„ interrupt() æ–¹æ³•ä¸­æ–­äº†è¯¥çº¿ç¨‹ï¼Œåˆ™è¯¥çº¿ç¨‹ä¼šåœ¨è°ƒç”¨ sleep æ–¹æ³•çš„åœ°æ–¹æŠ›å‡º `InterruptedException` å¼‚å¸¸è€Œè¿”å› ã€‚

> sleep æ˜¯é˜»å¡ï¼Œä½†æ²¡æœ‰é‡Šæ”¾é”ï¼›wait æ˜¯é‡Šæ”¾é”æ‰é˜»å¡ã€‚

## 1.6 è®©å‡º CPU æ‰§è¡Œæƒçš„ yield æ–¹æ³•

Thread ç±»ä¸­æœ‰ä¸€ä¸ªé™æ€çš„ yield æ–¹æ³•ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ yield æ–¹æ³•æ—¶ï¼Œå®é™…å°±æ˜¯åœ¨æš—ç¤ºçº¿ç¨‹è°ƒåº¦å™¨å½“å‰çº¿ç¨‹è¯·æ±‚è®©å‡ºè‡ªå·±çš„ CPU ä½¿ç”¨ï¼Œä½†æ˜¯çº¿ç¨‹è°ƒåº¦å™¨å¯ä»¥æ— æ¡ä»¶å¿½ç•¥è¿™ä¸ªæš—ç¤ºã€‚å½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ yield æ–¹æ³•æ—¶ï¼Œå½“å‰çº¿ç¨‹ä¼šè®©å‡º CPU ä½¿ç”¨æƒï¼Œç„¶åå¤„äºå°±ç»ªçŠ¶æ€ï¼Œçº¿ç¨‹è°ƒåº¦å™¨ä¼šä»çº¿ç¨‹å°±ç»ªé˜Ÿåˆ—é‡Œé¢è·å–ä¸€ä¸ªçº¿ç¨‹ä¼˜å…ˆçº§æœ€é«˜çš„çº¿ç¨‹ï¼Œå½“ç„¶ä¹Ÿæœ‰å¯èƒ½ä¼šè°ƒåº¦åˆ°åˆšåˆšè®©å‡º CPU çš„é‚£ä¸ªçº¿ç¨‹æ¥è·å– CPU æ‰§è¡Œæƒã€‚

ä¸€èˆ¬å¾ˆå°‘ä½¿ç”¨è¿™ä¸ªæ–¹æ³•ï¼Œåœ¨è°ƒè¯•æˆ–è€…æµ‹è¯•æ—¶è¿™ä¸ªæ–¹æ³•æˆ–è®¸å¯ä»¥å¸®åŠ©å¤ç°ç”±äºå¹¶å‘ç«äº‰æ¡ä»¶å¯¼è‡´çš„é—®é¢˜ï¼Œå…¶åœ¨è®¾è®¡å¹¶å‘æ§åˆ¶æ—¶æˆ–è®¸ä¼šæœ‰ç”¨é€”ï¼Œåé¢åœ¨è®²è§£ java.util.concurrent.locks åŒ…é‡Œé¢çš„é”æ—¶ä¼šçœ‹åˆ°è¯¥æ–¹æ³•çš„ä½¿ç”¨ã€‚

## 1.7 çº¿ç¨‹ä¸­æ–­

Java ä¸­çš„çº¿ç¨‹ä¸­æ–­æ˜¯ä¸€ç§çº¿ç¨‹é—´çš„åä½œæ¨¡å¼ï¼Œé€šè¿‡è®¾ç½®çº¿ç¨‹çš„ä¸­æ–­æ ‡å¿—å¹¶ä¸èƒ½ç›´æ¥ç»ˆæ­¢è¯¥çº¿ç¨‹çš„æ‰§è¡Œï¼Œè€Œæ˜¯è¢«ä¸­æ–­çš„çº¿ç¨‹æ ¹æ®ä¸­æ–­çŠ¶æ€è‡ªè¡Œå¤„ç†ã€‚

-   `void interrupt()`ï¼šä¸­æ–­çº¿ç¨‹ã€‚åªæ˜¯å°†çº¿ç¨‹çš„ä¸­æ–­æ ‡å¿—è®¾ä¸º trueï¼Œçº¿ç¨‹å¹¶æ²¡æœ‰å®é™…ä¸­æ–­ï¼Œå®ƒä¼šç»§ç»­æ‰§è¡Œã€‚ å¦‚æœçº¿ç¨‹å› ä¸ºè°ƒç”¨äº† wait ç³»åˆ—å‡½æ•°ã€ join æ–¹æ³•æˆ–è€… sleep æ–¹æ³•è€Œè¢«é˜»å¡æŒ‚èµ·ï¼Œè¿™æ—¶å¦‚æœè¢«è°ƒç”¨ interrupt() æ–¹æ³•ï¼Œåˆ™è¯¥çº¿ç¨‹ä¼šåœ¨è°ƒç”¨è¿™äº›æ–¹æ³•çš„åœ°æ–¹æŠ›å‡º InterruptedException å¼‚å¸¸ã€‚
    
    > åªæ˜¯è®¾ç½®äº†ä¸­æ–­æ ‡å¿—ï¼Œçº¿ç¨‹å†…éƒ¨å®ç°ä¼šæ ¹æ®è¿™ä¸ªæ ‡å¿—æ¥å†³å®šåšä»€ä¹ˆï¼Œæ¯”å¦‚ä¸‹é¢çš„ä¸¤ä¸ªä¾‹å­ï¼Œçº¿ç¨‹ä¼šé€šè¿‡åˆ¤æ–­ä¸­æ–­æ ‡å¿—æ¥å†³å®šæ˜¯å¦é€€å‡º while å¾ªç¯ã€‚
    
-   `boolean isInterrupted()`ï¼šè¿”å›å½“å‰çº¿ç¨‹æ˜¯å¦è¢«ä¸­æ–­ã€‚
    
    // æºç public boolean isInterrupted() {    // ä¼ é€’ falseï¼Œè¡¨ç¤ºä¸æ¸…é™¤ä¸­æ–­æ ‡å¿—ã€‚	return isInterrupted(false);}private native boolean isInterrupted(boolean ClearInterrupted);
    
-   `static boolean interrupted()`ï¼šè¿”å›å½“å‰çº¿ç¨‹æ˜¯å¦è¢«ä¸­æ–­ï¼Œå¦‚æœè¢«ä¸­æ–­ï¼Œåˆ™æ¸…é™¤ä¸­æ–­æ ‡å¿—ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¯¥æ–¹æ³•æ˜¯é™æ€æ–¹æ³•ï¼Œå†…éƒ¨é€šè¿‡ currentThread() æ–¹æ³•æ¥è·å–å½“å‰è°ƒç”¨æ–¹æ³•çš„çº¿ç¨‹çš„ä¸­æ–­æ ‡å¿—ï¼Œè€Œä¸æ˜¯è°ƒç”¨æ–¹æ³•çš„å®ä¾‹å¯¹è±¡çš„ã€‚
    
    public static boolean interrupted() {    // ä¼ é€’ trueï¼Œè¡¨ç¤ºæ¸…é™¤ä¸­æ–­æ ‡å¿—ã€‚	return currentThread().isInterrupted(true);}
    

ä½¿ç”¨ interrupted é€€å‡ºçš„ä¾‹å­ï¼š

public void run() {	try {        // ä¹¦ä¸Šè¿™é‡Œç”¨çš„æ˜¯ isInterrupted æ–¹æ³•ï¼Œæ„Ÿè§‰ä¸å¯¹		while (!Thread.currentThread().interrupted() && more work to do){			// do more work		}	} catch (InterruptedException e) {		// thread was interrupted during sleep or wait	} finally {		// cleanup if required	}}

1.  å¦‚æœçº¿ç¨‹è¢«ä¸­æ–­ï¼Œinterrupted() è¿”å› trueï¼Œç¬¬ä¸€ä¸ªæ¡ä»¶ä¸º falseï¼Œè·³å‡ºå¾ªç¯ï¼ˆinterrupted() ä¹Ÿä¼šæ¸…é™¤çº¿ç¨‹çš„ä¸­æ–­æ ‡å¿—ï¼‰ï¼›
    
2.  å¦åˆ™ï¼Œç¬¬ä¸€ä¸ªæ¡ä»¶è¿”å› trueï¼Œå¾ªç¯æ˜¯å¦ç»§ç»­éœ€è¦çœ‹ç¬¬äºŒä¸ªæ¡ä»¶ã€‚
    

> `!Thread.currentThread().interrupted()` å…¶å®å°±æ˜¯ `!Thread.interrupted()`ã€‚
> 
> çœ‹åˆ° `while(!Thread.interrupted())` å°±è¦æƒ³åˆ°ï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼šå½“å‰çº¿ç¨‹ä¸­æ–­æ ‡å¿—ä¸º true çš„æ—¶å€™é€€å‡ºå¾ªç¯ï¼Œå¹¶æ¸…é™¤ä¸­æ–­æ ‡å¿—ã€‚

æ ¹æ®ä¸­æ–­æ ‡å¿—åˆ¤æ–­çº¿ç¨‹æ˜¯å¦ç»ˆæ­¢çš„ä¾‹å­ï¼š

	public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(() -> {  
            // å¦‚æœå½“å‰çº¿ç¨‹æ²¡æœ‰è¢«è®¾ç½®ä¸­æ–­æ ‡å¿—  
            while (!Thread.currentThread().isInterrupted()) {  
                System.out.println(Thread.currentThread() + " hello");  
            }  
        });  
  
        thread.start();  
        Thread.sleep(1000);  
        System.out.println("main thread interrupt thread");  
        thread.interrupt();  
  
        thread.join();  
        System.out.println("main is over");  
    }  
è¾“å‡ºï¼š  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
main thread interrupt thread  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
Thread[Thread-0,5,main] hello  
main is over

è¿˜æœ‰ä¸€ç§æƒ…å†µï¼Œå½“çº¿ç¨‹ä¸ºäº†ç­‰å¾…ä¸€äº›ç‰¹å®šæ¡ä»¶çš„åˆ°æ¥æ—¶ï¼Œä¸€èˆ¬ä¼šè°ƒç”¨ sleep å‡½æ•° ã€ wait ç³»åˆ—å‡½æ•°æˆ–è€… join å‡½æ•°æ¥é˜»å¡æŒ‚èµ·å½“å‰çº¿ç¨‹ã€‚æ¯”å¦‚ä¸€ ä¸ªçº¿ç¨‹è°ƒç”¨äº† Thread. sleep(3000)ï¼Œé‚£ä¹ˆè°ƒç”¨çº¿ç¨‹ä¼šè¢«é˜»å¡ï¼Œ ç›´åˆ° 3s åæ‰ä¼šä»é˜»å¡çŠ¶æ€å˜ä¸ºæ¿€æ´»çŠ¶æ€ã€‚ ä½†æ˜¯æœ‰å¯èƒ½åœ¨ 3s å†…æ¡ä»¶å·±è¢«æ»¡è¶³ï¼Œå¦‚æœä¸€ ç›´ç­‰åˆ° 3s å å†è¿”å›æœ‰ç‚¹æµªè´¹æ—¶é—´ï¼Œè¿™æ—¶å€™å¯ä»¥è°ƒç”¨è¯¥çº¿ç¨‹çš„ interrupt() æ–¹æ³•ï¼Œ å¼ºåˆ¶ sleep æ–¹æ³•æŠ›å‡º `InterruptedException` å¼‚å¸¸è€Œè¿”å›ï¼Œçº¿ç¨‹æ¢å¤åˆ°æ¿€æ´»çŠ¶æ€ã€‚

	public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(() -> {  
            synchronized (resourceA) {  
                try {  
                    System.out.println("enter");  
                    resourceA.wait();  
                } catch (InterruptedException e) {  
                    System.out.println("leave");  
                }  
            }  
        });  
        thread.start();  
        Thread.sleep(1000);  
        thread.interrupt();  
    }  
è¾“å‡ºï¼š  
enter  
leave

ç†è§£ isInterrupted() å’Œ interrupted()ï¼š

public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(() -> {  
            while (true);  
        });  
        thread.start();  
        thread.interrupt();  
        System.out.println("isInterrupted: " + thread.isInterrupted());  
        System.out.println("isInterrupted: " + thread.interrupted());  
        System.out.println("isInterrupted: " + Thread.interrupted());  
        System.out.println("isInterrupted: " + thread.isInterrupted());  
        thread.join();  
}  
è¾“å‡ºï¼š  
isInterrupted: true  
isInterrupted: false  
isInterrupted: false  
isInterrupted: true

## 1.8 ç†è§£çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢

çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶æœºæœ‰ï¼š

-   å½“å‰çº¿ç¨‹çš„ CPU æ—¶é—´ä½¿ç”¨å®Œå¤„äºå°±ç»ªçŠ¶æ€æ—¶ã€‚
    
-   å½“å‰çº¿ç¨‹è¢«å…¶ä»–çº¿ç¨‹ä¸­æ–­æ—¶ ã€‚
    

## 1.9 çº¿ç¨‹æ­»é”

// TODO

## 1.10 å®ˆæŠ¤çº¿ç¨‹ä¸ç”¨æˆ·çº¿ç¨‹

Java ä¸­çš„çº¿ç¨‹åˆ†ä¸ºä¸¤ç±»ï¼Œåˆ†åˆ«ä¸º daemon çº¿ç¨‹ï¼ˆå®ˆæŠ¤çº¿ç¨‹ï¼‰å’Œ user çº¿ç¨‹ï¼ˆç”¨æˆ·çº¿ç¨‹ï¼‰ã€‚åœ¨ JVM å¯åŠ¨æ—¶ä¼šè°ƒç”¨ main å‡½æ•°ï¼Œ main å‡½æ•°æ‰€åœ¨çš„é’±ç¨‹å°±æ˜¯ä¸€ä¸ªç”¨æˆ·çº¿ç¨‹ï¼Œå…¶å®åœ¨ JVM å†…éƒ¨åŒæ—¶è¿˜å¯åŠ¨äº†å¥½å¤šå®ˆæŠ¤çº¿ç¨‹ï¼Œæ¯”å¦‚åƒåœ¾å›æ”¶çº¿ç¨‹ã€‚å®ˆæŠ¤çº¿ç¨‹å’Œç”¨æˆ·çº¿ç¨‹åŒºåˆ«ä¹‹ä¸€æ˜¯å½“æœ€åä¸€ä¸ªéå®ˆæŠ¤çº¿ç¨‹ç»“æŸæ—¶ï¼ŒJVM ä¼š æ­£å¸¸é€€å‡ºï¼Œè€Œä¸ç®¡å½“å‰æ˜¯å¦æœ‰å®ˆæŠ¤çº¿ç¨‹ï¼Œå°±æ˜¯è¯´å®ˆæŠ¤çº¿ç¨‹æ˜¯å¦ç»“æŸå¹¶ä¸å½±å“ JVM çš„é€€å‡ºã€‚æ¢è¨€ä¹‹ï¼Œåªè¦æœ‰ä¸€ä¸ªç”¨æˆ·çº¿ç¨‹è¿˜åœ¨è¿è¡Œï¼ŒJVM å°±ä¸ä¼šé€€å‡ºã€‚

é€šè¿‡ Thread çš„ setDaemon(true) æ¥åˆ›å»ºå®ˆæŠ¤çº¿ç¨‹ã€‚

> main çº¿ç¨‹è¿è¡Œç»“æŸåï¼ŒJVM ä¼šè‡ªåŠ¨å¯åŠ¨ä¸€ ä¸ªå«ä½œ DestroyJavaVM çš„çº¿ç¨‹ï¼Œè¯¥çº¿ç¨‹ä¼šç­‰å¾…æ‰€æœ‰ç”¨æˆ·çº¿ç¨‹ç»“æŸåç»ˆæ­¢ JVM è¿›ç¨‹ã€‚

## 1.11 ThreadLocal

å¤šé’±ç¨‹è®¿é—®åŒä¸€ä¸ªå…±äº«å˜é‡æ—¶ç‰¹åˆ«å®¹æ˜“å‡ºç°å¹¶å‘é—®é¢˜ã€‚ä¸ºäº†ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œä¸€èˆ¬ä½¿ç”¨è€…åœ¨è®¿é—®å…±äº«å˜é‡æ—¶éœ€è¦è¿›è¡Œé€‚å½“çš„åŒæ­¥ã€‚åŒæ­¥çš„æªæ–½ä¸€èˆ¬æ˜¯åŠ é”ï¼Œè¿˜æœ‰ä¸€ç§æ–¹å¼å°±æ˜¯ ThreadLocalï¼Œè™½ç„¶ ThreadLocal å¹¶ä¸æ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜è€Œå‡ºç°çš„ ã€‚

åˆ›å»ºä¸€ä¸ª ThreadLocalå˜é‡åï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½ä¼šå¤åˆ¶ä¸€ä¸ªå˜é‡åˆ°è‡ªå·±çš„æœ¬åœ°å†…å­˜ã€‚

### ä½¿ç”¨ç¤ºä¾‹

	static void print(String str) {  
        System.out.println(str + ": " + localVar.get());  
	//  localVar.remove();  
    }  
  
    static ThreadLocal<String> localVar = new ThreadLocal<>();  
  
    public static void main(String[] args){  
        Thread threadA = new Thread(()->{  
            localVar.set("threadA local var");  
            print("threadA");		// 1  
            System.out.println("threadA remove after: " + localVar.get());  
        });  
        Thread threadB = new Thread(()->{  
            localVar.set("threadB local var");  
            print("threadB");  
            System.out.println("threadB remove after: " + localVar.get());  
        });  
          
        threadA.start();  
        threadB.start();  
    }  
è¾“å‡ºï¼š  
threadA: threadA local var  
threadB: threadB local var  
threadA remove after: threadA local var  
threadB remove after: threadB local var

threadA å’Œ threadB éƒ½åœ¨è‡ªå·±çº¿ç¨‹å†…éƒ¨åˆ›å»ºäº†æœ¬åœ°å˜é‡ï¼Œæ³¨é‡Š 1 çš„åœ°æ–¹ï¼ŒthreadA è°ƒç”¨ print æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ‰§è¡Œçš„æ—¶å€™å½“å‰çº¿ç¨‹æ˜¯ threadAã€‚

æ‰“å¼€æ³¨é‡Šåï¼š

è¾“å‡ºï¼š  
threadA: threadA local var  
threadA remove after: null  
threadB: threadB local var  
threadB remove after: null

### å®ç°åŸç†

![Screen Shot 2021-05-30 at 11.52.00](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-05-30%20at%2011.52.00.png)

`Thread` ç±»ä¸­æœ‰ä¸€ä¸ª `threadLocals` å’Œä¸€ä¸ª `inheritableThreadLocals`ï¼Œå®ƒä»¬éƒ½æ˜¯ `ThreadLocalMap` ç±»å‹çš„å˜é‡ï¼Œè€Œ `ThreadLocalMap` æ˜¯ä¸€ä¸ªå®šåˆ¶åŒ–çš„ `Hashmap`ã€‚åœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¯ä¸ªçº¿ç¨‹ä¸­çš„è¿™ä¸¤ä¸ªå˜é‡éƒ½ä¸º `null`ï¼Œåªæœ‰å½“å‰çº¿ç¨‹ç¬¬ä¸€æ¬¡è°ƒç”¨ `ThreadLocal` çš„ `set` æˆ–è€… `get` æ–¹æ³•æ—¶æ‰ä¼šåˆ›å»ºå®ƒä»¬ã€‚å…¶å®æ¯ä¸ªçº¿ç¨‹çš„æœ¬åœ°å˜é‡ä¸æ˜¯å­˜æ”¾åœ¨ `ThreadLocal` å®ä¾‹é‡Œé¢ï¼Œè€Œæ˜¯å­˜æ”¾åœ¨è°ƒç”¨çº¿ç¨‹çš„ `threadLocals` å˜é‡é‡Œé¢ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ`ThreadLocal` ç±»å‹çš„æœ¬åœ°å˜é‡å­˜æ”¾åœ¨å…·ä½“çš„çº¿ç¨‹å†…å­˜ç©ºé—´ä¸­ã€‚`ThreadLocal` å°±æ˜¯ä¸€ä¸ªå·¥å…·å£³ï¼Œå®ƒé€šè¿‡ `set` æ–¹æ³•æŠŠ `value` å€¼æ”¾ å…¥è°ƒç”¨çº¿ç¨‹çš„ `threadLocals` é‡Œé¢å¹¶å­˜æ”¾èµ·æ¥ï¼Œå½“è°ƒç”¨çº¿ç¨‹è°ƒç”¨å®ƒçš„ `get` æ–¹æ³•æ—¶ï¼Œå†ä»å½“å‰çº¿ç¨‹çš„ `threadLocals` å˜é‡é‡Œé¢å°†å…¶æ‹¿å‡ºæ¥ä½¿ç”¨ã€‚å¦‚æœè°ƒç”¨çº¿ç¨‹ä¸€ç›´ä¸ç»ˆæ­¢ï¼Œé‚£ä¹ˆè¿™ä¸ªæœ¬åœ°å˜é‡ä¼šä¸€ç›´å­˜æ”¾åœ¨è°ƒç”¨çº¿ç¨‹çš„ `threadLocals` å˜é‡é‡Œé¢ï¼Œæ‰€ä»¥å½“ä¸éœ€è¦ä½¿ç”¨æœ¬åœ°å˜é‡æ—¶å¯ä»¥é€šè¿‡è°ƒç”¨ `ThreadLocal` å˜é‡çš„ `remove` æ–¹æ³•ï¼Œä»å½“å‰çº¿ç¨‹çš„`threadLocals` é‡Œé¢åˆ é™¤è¯¥æœ¬åœ°å˜é‡ã€‚å¦å¤–ï¼Œ`Thread` é‡Œé¢çš„ `threadLocals` ä¸ºä½•è¢«è®¾è®¡ä¸º `map` ç»“æ„ï¼Ÿå¾ˆæ˜æ˜¾æ˜¯å› ä¸ºæ¯ä¸ªçº¿ç¨‹å¯ä»¥å…³è”å¤šä¸ª `ThreadLocal` å˜é‡ã€‚

> `ThreadLocal` åªæ˜¯ä¸€ä¸ªå·¥å…·ç±»ï¼Œè™½ç„¶å¯èƒ½å¤šä¸ªçº¿ç¨‹çœ‹ä¼¼éƒ½æ˜¯è°ƒç”¨åŒä¸€ä¸ª `ThreadLocal` å˜é‡çš„ `set()`ã€`get()` ç­‰æ–¹æ³•ï¼Œä½†æ˜¯è¿™äº›æ–¹æ³•å†…éƒ¨ç¬¬ä¸€æ­¥å°±æ˜¯è·å¾—å½“å‰çº¿ç¨‹ï¼Œç„¶åè¿”å›å½“å‰çº¿ç¨‹çš„ `ThreadLocalMap`ã€‚

ä¸‹é¢æ˜¯ ThreadLocal ç±»çš„æºç ï¼š

#### void set(T value)

public void set(T value) {  
    // 1. è·å–å½“å‰çº¿ç¨‹  
	Thread t = Thread.currentThread();  
    // 2. å°†å½“å‰çº¿ç¨‹ä½œä¸º keyï¼Œå»æŸ¥æ‰¾å¯¹åº”çš„çº¿ç¨‹å˜é‡ï¼Œæ‰¾åˆ°åˆ™è®¾ç½®  
	ThreadLocalMap map = getMap(t);  
	if (map != null)  
		map.set(this, value);  
	else  
        // 3. ç¬¬ä¸€æ¬¡è°ƒç”¨å°±åˆ›å»ºå½“å‰çº¿ç¨‹å¯¹åº”çš„ HashMap  
		createMap(t, value);  
}  
  
ThreadLocalMap getMap(Thread t) {  
    // è¿”å› Thread ç±»çš„ threadLocals å˜é‡  
	return t.threadLocals;  
}  
  
void createMap(Thread t, T firstValue) {  
	t.threadLocals = new ThreadLocalMap(this, firstValue);  
}

#### T get()

public T get() {  
	Thread t = Thread.currentThread();  
	ThreadLocalMap map = getMap(t);  
	if (map != null) {  
        // TODO  
		ThreadLocalMap.Entry e = map.getEntry(this);  
		if (e != null) {  
            @SuppressWarnings("unchecked")  
            T result = (T)e.value;  
            return result;  
		}  
	}  
    // threadLocals ä¸ºç©ºåˆ™åˆå§‹åŒ–å½“å‰çº¿ç¨‹çš„ threadLocals æˆå‘˜äº¤é‡  
	return setInitialValue();  
}  
  
private T setInitialValue() {  
	T value = initialValue();  
	Thread t = Thread.currentThread();  
	ThreadLocalMap map = getMap(t);  
	if (map != null)  
		map.set(this, value);  
	else  
		createMap(t, value);  
	return value;  
}  
  
// è¿™ä¸ªæ–¹æ³•å­˜åœ¨çš„ç›®çš„å°±æ˜¯ç»Ÿä¸€ç®¡ç†åˆå§‹å€¼ï¼Ÿ  
protected T initialValue() {  
	return null;  
}

#### void remove()

public void remove() {  
	ThreadLocalMap m = getMap(Thread.currentThread());  
	if (m != null)  
		m.remove(this);  
}

æ€»ç»“ï¼šåœ¨æ¯ä¸ªçº¿ç¨‹å†…éƒ¨éƒ½æœ‰ä¸€ä¸ªåä¸º `threadLocals` çš„æˆå‘˜å˜é‡ï¼Œè¯¥å˜é‡çš„ç±»å‹ä¸º `HashMap`ï¼Œå…¶ä¸­ `key` ä¸ºæˆ‘ä»¬å®šä¹‰çš„ `ThreadLocal` å˜é‡çš„ `this` å¼•ç”¨ï¼Œ`value` åˆ™ä¸ºæˆ‘ä»¬ä½¿ç”¨ `set` æ–¹æ³•è®¾ç½®çš„å€¼ã€‚æ¯ä¸ªçº¿ç¨‹çš„æœ¬åœ°å˜é‡å­˜æ”¾åœ¨çº¿ç¨‹è‡ªå·±çš„å†…å­˜å˜é‡ `threadLocals` ä¸­ï¼Œå¦‚æœå½“å‰çº¿ç¨‹ä¸€ç›´ä¸æ¶ˆäº¡ï¼Œé‚£ä¹ˆè¿™äº›æœ¬åœ°å˜é‡ä¼šä¸€ç›´å­˜åœ¨ï¼Œæ‰€ä»¥å¯èƒ½ä¼šé€ æˆå†…å­˜æº¢å‡ºï¼Œå› æ­¤ä½¿ç”¨å®Œæ¯•åè¦è®°å¾—è°ƒç”¨ `ThreadLocal` çš„ `remove` æ–¹æ³•åˆ é™¤å¯¹åº”çº¿ç¨‹çš„ `threadLocals` ä¸­çš„æœ¬åœ°å˜é‡ã€‚

### ThreadLocal ä¸æ”¯æŒç»§æ‰¿æ€§

	static ThreadLocal<String> threadLocal = new ThreadLocal<>();  
  
    public static void main(String[] args){  
        threadLocal.set("hello world");  
        Thread thread = new Thread(()->{  
            System.out.println("thread: " + threadLocal.get());  
        });  
        thread.start();  
        System.out.println("main: " + threadLocal.get());  
    }  
è¾“å‡ºï¼š  
main: hello world  
thread: null

### InheritableThreadLocal ç±»

è¿™ä¸ªç±»ç»§æ‰¿è‡ª ThreadLocalï¼Œå¯ä»¥è®©å­çº¿ç¨‹å¯ä»¥è®¿é—®åœ¨çˆ¶çº¿ç¨‹ä¸­è®¾ç½®çš„æœ¬åœ°å˜é‡ã€‚

public class InheritableThreadLocal<T> extends ThreadLocal<T> {  
    protected T childValue(T parentValue) {  
        return parentValue;  
    }  
  
    ThreadLocalMap getMap(Thread t) {  
       return t.inheritableThreadLocals;  
    }  
  
    void createMap(Thread t, T firstValue) {  
        t.inheritableThreadLocals = new ThreadLocalMap(this, firstValue);  
    }  
}

é‡å†™äº† ThreadLocal çš„ä¸‰ä¸ªæ–¹æ³•ï¼Œä¸»è¦å°±æ˜¯åœ¨ Thread å†…éƒ¨ç”¨ inheritableThreadLocals ä»£æ›¿ threadLocalsã€‚

// Thread æºç   
public Thread(Runnable target) {  
	init(null, target, "Thread-" + nextThreadNum(), 0);  
}  
  
private void init(ThreadGroup g, Runnable target, String name, long stackSize) {  
	init(g, target, name, stackSize, null, true);  
}  
  
private void init(ThreadGroup g, Runnable target, String name, long stackSize,   
                  AccessControlContext acc, boolean inheritThreadLocals) {  
    ...  
    // åœ¨å½“å‰çº¿ç¨‹ä¸­åˆ›å»ºå­çº¿ç¨‹çš„æ—¶å€™ï¼Œå°†å½“å‰çº¿ç¨‹ä½œä¸ºçˆ¶çº¿ç¨‹ä¸­  
	Thread parent = currentThread();  
	...  
    // inheritThreadLocals åœ¨è¿™é‡Œé»˜è®¤ä¸º true  
    // å¦‚æœçˆ¶çº¿ç¨‹ä¸­ inheritableThreadLocals ä¸ä¸ºç©ºï¼Œåˆ™ä¸ºå­çº¿ç¨‹ä¹Ÿåˆ›å»º inheritableThreadLocalsï¼Œ  
	if (inheritThreadLocals && parent.inheritableThreadLocals != null)  
		this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);  
      
	this.stackSize = stackSize;  
	tid = nextThreadID();  
}  
  
  
// ThreadLocal æºç   
static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {  
	return new ThreadLocalMap(parentMap);  
}  
  
  
// Thread å†…éƒ¨ç±» ThreadLocalMap æºç   
private ThreadLocalMap(ThreadLocalMap parentMap) {  
	Entry[] parentTable = parentMap.table;  
	int len = parentTable.length;  
	setThreshold(len);  
	table = new Entry[len];  
  
	for (int j = 0; j < len; j++) {  
		Entry e = parentTable[j];  
		if (e != null) {  
			@SuppressWarnings("unchecked")  
			ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();  
			if (key != null) {  
                // è°ƒç”¨äº† InheritableThreadLocal çš„ childValue æ–¹æ³•ï¼Œç›´æ¥è¿”å› e.value  
                Object value = key.childValue(e.value);  
				Entry c = new Entry(key, value);  
				int h = key.threadLocalHashCode & (len - 1);  
				while (table[h] != null)  
					h = nextIndex(h, len);  
                table[h] = c;  
                size++;  
			}  
		}  
	}  
}

æ€»ç»“ï¼š

-   InheritableThreadLocal ç±»é€šè¿‡é‡å†™ ThreadLocal çš„ getMap å’Œ createMap æ–¹æ³•è®©æœ¬åœ°å˜é‡ä¿å­˜åˆ°äº†å…·ä½“çº¿ç¨‹çš„ inheritableThreadLocals å˜é‡é‡Œï¼Œé‚£ä¹ˆçº¿ç¨‹åœ¨é€šè¿‡ InheritableThreadLocal ç±»å®ä¾‹çš„ set æˆ–è€… get æ–¹æ³•è®¾ç½®å˜é‡æ—¶ï¼Œå°±ä¼šåˆ›å»ºå½“å‰çº¿ç¨‹çš„ inheritableThreadLocals å˜é‡ã€‚
    
-   å½“çˆ¶çº¿ç¨‹åˆ›å»ºå­çº¿ç¨‹æ—¶ï¼Œæ„é€ å‡½æ•°ä¼šæŠŠçˆ¶çº¿ç¨‹ä¸­ inheritableThreadLocals å˜é‡é‡Œé¢çš„æœ¬åœ°å˜é‡å¤åˆ¶ä¸€ä»½ä¿å­˜åˆ°å­çº¿ç¨‹çš„ inheritableThreadLocals å˜é‡é‡Œé¢ã€‚
    

é‚£ä¹ˆåœ¨ä»€ä¹ˆæƒ…å†µä¸‹éœ€è¦å­çº¿ç¨‹å¯ä»¥è·å–çˆ¶çº¿ç¨‹çš„ threadlocal å˜é‡å‘¢ï¼Ÿæ¯”å¦‚å­çº¿ç¨‹éœ€è¦ä½¿ç”¨å­˜æ”¾åœ¨ threadlocal å˜é‡ä¸­çš„ç”¨æˆ·ç™»å½•ä¿¡æ¯ï¼Œå†æ¯”å¦‚ä¸€äº›ä¸­é—´ä»¶éœ€è¦æŠŠç»Ÿä¸€çš„ id è¿½è¸ªçš„æ•´ä¸ªè°ƒç”¨é“¾è·¯è®°å½•ä¸‹æ¥ã€‚å…¶å®å­çº¿ç¨‹ä½¿ç”¨çˆ¶çº¿ç¨‹ä¸­çš„ threadlocal æ–¹æ³•æœ‰å¤šç§æ–¹å¼ï¼Œ æ¯”å¦‚åˆ›å»ºçº¿ç¨‹æ—¶ä¼ å…¥çˆ¶çº¿ç¨‹ä¸­çš„å˜é‡ï¼Œå¹¶å°†å…¶å¤åˆ¶åˆ°å­çº¿ç¨‹ä¸­ï¼Œæˆ–è€…åœ¨çˆ¶çº¿ç¨‹ä¸­æ„é€ ä¸€ä¸ª map ä½œä¸ºå‚æ•°ä¼ é€’ç»™å­çº¿ç¨‹ï¼Œä½†æ˜¯è¿™äº›éƒ½æ”¹å˜äº†æˆ‘ä»¬çš„ä½¿ç”¨ä¹ æƒ¯ï¼Œæ‰€ä»¥åœ¨è¿™äº›æƒ…å†µä¸‹ InheritabIeThreadLocal å°±æ˜¾å¾—æ¯”è¾ƒæœ‰ç”¨ ã€‚

# 2. å¹¶å‘ç¼–ç¨‹çš„å…¶ä»–åŸºç¡€çŸ¥è¯†

## 2.1 ä»€ä¹ˆæ˜¯å¤šçº¿ç¨‹å¹¶å‘ç¼–ç¨‹

## 2.2 ä¸ºä»€ä¹ˆè¦è¿›è¡Œå¤šçº¿ç¨‹å¹¶å‘ç¼–ç¨‹

## 2.3 Java ä¸­çš„çº¿ç¨‹å®‰å…¨é—®é¢˜

çº¿ç¨‹å®‰å…¨é—®é¢˜æ˜¯æŒ‡å½“å¤šä¸ªçº¿ç¨‹åŒæ—¶è¯»å†™ä¸€ä¸ªå…±äº«èµ„æºå¹¶ä¸”æ²¡æœ‰ä»»ä½•åŒæ­¥æªæ–½æ—¶ï¼Œå¯¼è‡´å‡ºç°è„æ•°æ®æˆ–è€…å…¶ä»–ä¸å¯é¢„è§çš„ç»“æœçš„é—®é¢˜ã€‚

## 2.4 Java ä¸­å…±äº«å˜é‡çš„å†…å­˜å¯è§æ€§é—®é¢˜

### Java å†…å­˜æ¨¡å‹

![Screen Shot 2021-06-01 at 23.30.57](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-01%20at%2023.30.57.png)

Java å†…å­˜æ¨¡å‹è§„å®šï¼Œå°†æ‰€æœ‰çš„å˜é‡éƒ½å­˜æ”¾åœ¨ä¸»å†…å­˜ä¸­ï¼Œå½“çº¿ç¨‹ä½¿ç”¨å˜é‡æ—¶ï¼Œä¼šæŠŠä¸»å†…å­˜é‡Œé¢çš„å˜é‡å¤åˆ¶åˆ°è‡ªå·±çš„å·¥ä½œç©ºé—´æˆ–è€…å«ä½œå·¥ä½œå†…å­˜ï¼Œçº¿ç¨‹è¯»å†™å˜é‡æ—¶æ“ä½œçš„æ˜¯è‡ªå·±å·¥ä½œå†…å­˜ä¸­çš„å˜é‡ã€‚Java å†…å­˜æ¨¡å‹æ˜¯ä¸€ä¸ªæŠ½è±¡çš„æ¦‚å¿µï¼Œå®é™…å®ç°ä¸­çº¿ç¨‹çš„å·¥ä½œå†…å­˜å¦‚ä¸‹å›¾ï¼š

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-01%20at%2023.33.10.png" alt="Screen Shot 2021-06-01 at 23.33.10" style="zoom: 50%;" />

å›¾ä¸­æ‰€ç¤ºæ˜¯ä¸€ä¸ªåŒæ ¸ CPU ç³»ç»Ÿæ¶æ„ï¼Œæ¯ä¸ªæ ¸æœ‰è‡ªå·±çš„æ§åˆ¶å™¨å’Œè¿ç®—å™¨ï¼Œå…¶ä¸­æ§åˆ¶å™¨åŒ…å« ä¸€ç»„å¯„å­˜å™¨å’Œæ“ä½œæ§åˆ¶å™¨ï¼Œè¿ç®—å™¨æ‰§è¡Œç®—æœ¯é€»è¾…è¿ç®—ã€‚æ¯ä¸ªæ ¸éƒ½æœ‰è‡ªå·±çš„ä¸€çº§ç¼“å­˜ï¼Œåœ¨æœ‰äº›æ¶æ„é‡Œé¢è¿˜æœ‰ä¸€ä¸ªæ‰€æœ‰ CPU éƒ½å…±äº«çš„äºŒçº§ç¼“å­˜ã€‚é‚£ä¹ˆ Java å†…å­˜æ¨¡å‹é‡Œé¢çš„å·¥ä½œå†…å­˜ï¼Œå°±å¯¹åº”è¿™é‡Œçš„ Ll æˆ–è€… L2 ç¼“å­˜æˆ–è€… CPU çš„å¯„å­˜å™¨ã€‚

å½“ä¸€ä¸ªçº¿ç¨‹æ“ä½œå…±äº«å˜é‡æ—¶ï¼Œå®ƒé¦–å…ˆä»ä¸»å†…å­˜å¤åˆ¶å…±äº«å˜é‡åˆ°è‡ªå·±çš„å·¥ä½œå†…å­˜ï¼Œç„¶åå¯¹å·¥ä½œå†…å­˜é‡Œçš„å˜é‡è¿›è¡Œå¤„ç†ï¼Œå¤„ç†å®Œåå°†å˜é‡å€¼æ›´æ–°åˆ°ä¸»å†…å­˜ã€‚

é‚£ä¹ˆå‡å¦‚çº¿ç¨‹ A å’Œçº¿ç¨‹ B åŒæ—¶å¤„ç†ä¸€ä¸ªå…±äº«å˜é‡ï¼Œä¼šå‡ºç°ä»€ä¹ˆæƒ…å†µï¼Ÿæˆ‘ä»¬ä½¿ç”¨å›¾ 2-5 æ‰€ç¤º CPU æ¶æ„ï¼Œå‡è®¾çº¿ç¨‹ A å’Œçº¿ç¨‹ B ä½¿ç”¨ä¸åŒCPU æ‰§è¡Œï¼Œå¹¶ä¸”å½“å‰ä¸¤çº§ Cache éƒ½ä¸ºç©ºï¼Œ é‚£ä¹ˆè¿™æ—¶å€™ç”±äº Cache çš„å­˜åœ¨ï¼Œå°†ä¼šå¯¼è‡´å†…å­˜ä¸å¯è§é—®é¢˜ ï¼Œ å…·ä½“çœ‹ä¸‹é¢çš„åˆ†æï¼š

1.  çº¿ç¨‹ A é¦–å…ˆè·å–å…±äº«å˜é‡ X çš„å€¼ï¼Œç”±äºä¸¤çº§ Cache éƒ½æ²¡æœ‰å‘½ä¸­ï¼Œæ‰€ä»¥åŠ è½½ä¸»å†…å­˜ä¸­ X çš„å€¼ï¼Œå‡å¦‚ä¸º 0ã€‚ç„¶åæŠŠ X=0 çš„å€¼ç¼“å­˜åˆ°ä¸¤çº§ç¼“å­˜ï¼Œçº¿ç¨‹ A ä¿®æ”¹ X çš„å€¼ä¸º 1ï¼Œç„¶åå°†å…¶å†™å…¥ä¸¤çº§ Cacheï¼Œå¹¶ä¸”åˆ·æ–°åˆ°ä¸»å†…å­˜ã€‚çº¿ç¨‹ A æ“ä½œå®Œæ¯•åï¼Œçº¿ç¨‹ A æ‰€åœ¨çš„ CPU çš„ä¸¤çº§ Cache å†…å’Œä¸»å†…å­˜é‡Œé¢çš„ X çš„å€¼éƒ½æ˜¯ 1ã€‚
    
2.  çº¿ç¨‹ B è·å– X çš„å€¼ï¼Œé¦–å…ˆä¸€çº§ç¼“å­˜æ²¡æœ‰å‘½ä¸­ï¼Œç„¶åçœ‹äºŒçº§ç¼“å­˜ï¼ŒäºŒçº§ç¼“å­˜å‘½ä¸­äº†ï¼Œæ‰€ä»¥è¿”å› X=1ã€‚åˆ°è¿™é‡Œä¸€åˆ‡éƒ½æ˜¯æ­£å¸¸çš„ï¼Œå› ä¸ºè¿™æ—¶å€™ä¸»å†…å­˜ä¸­ä¹Ÿæ˜¯ X=1ã€‚ç„¶åçº¿ç¨‹ B ä¿®æ”¹ X çš„å€¼ä¸º 2ï¼Œ å¹¶å°†å…¶å­˜æ”¾åˆ°çº¿ç¨‹ 2 æ‰€åœ¨çš„ä¸€çº§ Cache å’Œå…±äº«äºŒçº§ Cache ä¸­ï¼Œæœ€åæ›´æ–°ä¸»å†…å­˜ä¸­ X çš„å€¼ä¸º 2ï¼›åˆ°è¿™é‡Œä¸€åˆ‡éƒ½æ˜¯å¥½çš„ã€‚
    
3.  çº¿ç¨‹ A è¿™æ¬¡åˆéœ€è¦ä¿®æ”¹ X çš„å€¼ï¼Œè·å–æ—¶ä¸€çº§ç¼“å­˜å‘½ä¸­ï¼Œå¹¶ä¸” X=1ï¼Œåˆ°è¿™é‡Œé—®é¢˜å°±å‡ºç°äº†ï¼Œæ˜æ˜çº¿ç¨‹ B å·²ç»æŠŠ X çš„å€¼ä¿®æ”¹ä¸ºäº† 2ï¼Œä¸ºä½•çº¿ç¨‹ A è·å–çš„è¿˜æ˜¯ 1 å‘¢ï¼Ÿè¿™å°±æ˜¯å…±äº«å˜é‡çš„å†…å­˜ä¸å¯è§é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹ B å†™å…¥çš„å€¼å¯¹çº¿ç¨‹ A ä¸å¯è§ã€‚
    

## 2.5 Java ä¸­çš„ synchronized å…³é”®å­—

### ä»‹ç»

synchronized å—æ˜¯ Java æä¾›çš„ä¸€ç§åŸå­æ€§å†…ç½®é”ï¼ŒJava ä¸­çš„æ¯ä¸ªå¯¹è±¡éƒ½å¯ä»¥æŠŠå®ƒå½“ä½œä¸€ä¸ªåŒæ­¥é”æ¥ä½¿ç”¨ï¼Œè¿™äº› Java å†…ç½®çš„ä½¿ç”¨è€…çœ‹ä¸åˆ°çš„é”è¢«ç§°ä¸ºå†…éƒ¨é”ï¼Œä¹Ÿå«ä½œç›‘è§†å™¨é”ã€‚çº¿ç¨‹çš„æ‰§è¡Œä»£ç åœ¨è¿›å…¥ synchronized ä»£ç å—å‰ä¼šè‡ªåŠ¨è·å–å†…éƒ¨é”ï¼Œè¿™æ—¶å€™å…¶ä»–çº¿ç¨‹è®¿é—®è¯¥åŒæ­¥ä»£ç å—æ—¶ä¼šè¢«é˜»å¡æŒ‚èµ·ã€‚æ‹¿åˆ°å†…éƒ¨é”çš„çº¿ç¨‹ä¼šåœ¨æ­£å¸¸é€€å‡ºåŒæ­¥ä»£ç å—æˆ–è€…æŠ›å‡ºå¼‚å¸¸åæˆ–è€…åœ¨åŒæ­¥å—å†…è°ƒç”¨äº†è¯¥å†…ç½®é”èµ„æºçš„ wait ç³»åˆ—æ–¹æ³•æ—¶é‡Šæ”¾è¯¥å†…ç½®é”ã€‚å†…ç½®é”æ˜¯æ’å®ƒé”ï¼Œä¹Ÿå°±æ˜¯å½“ä¸€ä¸ªçº¿ç¨‹è·å–è¿™ä¸ªé”åï¼Œå…¶ä»–çº¿ç¨‹å¿…é¡»ç­‰å¾…è¯¥çº¿ç¨‹é‡Šæ”¾é”åæ‰èƒ½è·å–è¯¥é”ã€‚

å¦å¤–ï¼Œç”±äº Java ä¸­çš„çº¿ç¨‹æ˜¯ä¸æ“ä½œç³»ç»Ÿçš„åŸç”Ÿçº¿ç¨‹ä¸€ä¸€å¯¹åº”çš„ï¼Œæ‰€ä»¥å½“é˜»å¡ä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œéœ€è¦ä»ç”¨æˆ·æ€åˆ‡æ¢åˆ°å†…æ ¸æ€æ‰§è¡Œé˜»å¡æ“ä½œï¼Œè¿™æ˜¯å¾ˆè€—æ—¶çš„æ“ä½œï¼Œè€Œ synchronized çš„ä½¿ç”¨å°±ä¼šå¯¼è‡´ä¸Šä¸‹æ–‡åˆ‡æ¢ã€‚

### å†…å­˜è¯­ä¹‰

å‰é¢ä»‹ç»äº†å…±äº«å˜é‡å†…å­˜å¯è§æ€§é—®é¢˜ä¸»è¦æ˜¯ç”±äºçº¿ç¨‹çš„å·¥ä½œå†…å­˜å¯¼è‡´çš„ï¼Œsynchronized çš„å†…å­˜è¯­ä¹‰å°±å¯ä»¥è§£å†³å…±äº«å˜é‡å†…å­˜å¯è§æ€§é—®é¢˜ã€‚

è¿›å…¥ synchronized å—çš„å†…å­˜è¯­ä¹‰æ˜¯**æŠŠåœ¨ synchronized å—å†…ä½¿ç”¨åˆ°çš„å˜é‡ä»çº¿ç¨‹çš„å·¥ä½œå†…å­˜ä¸­æ¸…é™¤**ï¼Œè¿™æ ·åœ¨ synchronized å—å†…ä½¿ç”¨åˆ°è¯¥å˜é‡æ—¶å°±ä¸ä¼šä»çº¿ç¨‹çš„å·¥ä½œå†…å­˜ä¸­è·å–ï¼Œè€Œæ˜¯ç›´æ¥ä»ä¸»å†…å­˜ä¸­è·å–ã€‚é€€å‡º synchronized å—çš„å†…å­˜è¯­ä¹‰æ˜¯**æŠŠåœ¨ synchronized å—å†…å¯¹å…±äº«å˜é‡çš„ä¿®æ”¹åˆ·æ–°åˆ°ä¸»å†…å­˜** ã€‚

å…¶å®è¿™ä¹Ÿæ˜¯**åŠ é”å’Œé‡Šæ”¾é”çš„è¯­ä¹‰**ï¼Œå½“è·å–é”åä¼šæ¸…ç©ºé”å—å†…æœ¬åœ°å†…å­˜ä¸­å°†ä¼šè¢«ç”¨åˆ°çš„å…±äº«å˜é‡ï¼Œåœ¨ä½¿ç”¨è¿™äº›å…±äº«å˜é‡æ—¶ä»ä¸»å†…å­˜è¿›è¡ŒåŠ è½½ï¼Œåœ¨é‡Šæ”¾é”æ—¶å°†æœ¬åœ°å†…å­˜ä¸­ä¿®æ”¹çš„å…±äº«å˜é‡åˆ·æ–°åˆ°ä¸»å†…å­˜ã€‚

é™¤å¯ä»¥è§£å†³å…±äº«å˜é‡å†…å­˜å¯è§æ€§é—®é¢˜å¤–ï¼Œ synchronized ç»å¸¸è¢«ç”¨æ¥å®ç°åŸå­æ€§æ“ä½œã€‚

## 2.6 Java ä¸­çš„ volatile å…³é”®å­—

ä¸Šé¢ä»‹ç»äº†ä½¿ç”¨é”çš„æ–¹å¼å¯ä»¥è§£å†³å…±äº«å˜é‡å†…å­˜å¯è§æ€§é—®é¢˜ï¼Œä½†æ˜¯ä½¿ç”¨é”å¤ªç¬¨é‡ï¼Œå› ä¸ºå®ƒä¼šå¸¦æ¥çº¿ç¨‹ä¸Šä¸‹æ–‡çš„åˆ‡æ¢å¼€é”€ã€‚å¯¹äºè§£å†³å†…å­˜å¯è§æ€§é—®é¢˜ï¼Œ Java è¿˜æä¾›äº†ä¸€ç§å¼±å½¢å¼çš„åŒæ­¥ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨ volatile å…³é”®å­—ã€‚è¯¥å…³é”®å­—å¯ä»¥ç¡®ä¿å¯¹ä¸€ä¸ªå˜é‡çš„æ›´æ–°å¯¹å…¶ä»–çº¿ç¨‹é©¬ä¸Šå¯è§ã€‚å½“ä¸€ä¸ªå˜é‡è¢«å£°æ˜ä¸º volatile æ—¶ï¼Œçº¿ç¨‹åœ¨å†™å…¥å˜é‡æ—¶ä¸ä¼šæŠŠå€¼ç¼“å­˜åœ¨å¯„å­˜å™¨æˆ–è€…å…¶ä»–åœ°æ–¹ï¼Œè€Œæ˜¯ä¼šæŠŠå€¼åˆ·æ–°å›ä¸»å†…å­˜ã€‚å½“å…¶ä»–çº¿ç¨‹è¯»å–è¯¥å…±äº«å˜é‡æ—¶ï¼Œä¼šä»ä¸»å†…å­˜é‡æ–°è·å–æœ€æ–°å€¼ï¼Œè€Œä¸æ˜¯ä½¿ç”¨å½“å‰çº¿ç¨‹çš„å·¥ä½œå†…å­˜ä¸­çš„å€¼ã€‚volatile çš„å†…å­˜è¯­ä¹‰å’Œ synchronized æœ‰ç›¸ä¼¼ä¹‹å¤„ï¼Œå…·ä½“æ¥è¯´å°±æ˜¯ï¼Œå½“çº¿ç¨‹å†™å…¥äº† volatile å˜é‡å€¼æ—¶å°±ç­‰ä»·äºçº¿ç¨‹é€€å‡º synchronized åŒæ­¥å—ï¼ˆæŠŠå†™å…¥å·¥ä½œå†…å­˜çš„å˜é‡å€¼åŒæ­¥åˆ°ä¸»å†…å­˜ï¼‰ï¼Œè¯»å– volatile å˜é‡å€¼æ—¶å°±ç›¸å½“äºè¿›å…¥åŒæ­¥å—ï¼ˆå…ˆæ¸…ç©ºæœ¬åœ°å†…å­˜å˜é‡å€¼ï¼Œå†ä»ä¸»å†…å­˜è·å–æœ€æ–°å€¼ï¼‰ã€‚

å¦‚ä¸‹ä»£ç ä¸­çš„å…±äº«å˜é‡ value æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ï¼š

publlc class ThreadNotSafeinteger {  
	private int value;   
      
    public int get() {  
		return value;  
    }  
	public void set(int value) {   
        this.value =value;  
    }  
}

synchronized å…³é”®å®‡è¿›è¡ŒåŒæ­¥çš„æ–¹å¼ï¼š

publlc class ThreadNotSafeinteger {  
	private int value;   
      
    public synchronized int get() {  
		return value;  
    }  
	public void set(int value) {   
        this.value =value;  
    }  
}

volatiel åŒæ­¥çš„æ–¹å¼ï¼š

publlc class ThreadNotSafeinteger {  
	private volatile int value;   
      
    public int get() {  
		return value;  
    }  
	public void set(int value) {   
        this.value =value;  
    }  
}

synchronized æ˜¯ç‹¬å é”ï¼ŒåŒæ—¶åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ get() æ–¹æ³•ï¼Œå…¶ä»–è°ƒç”¨çº¿ç¨‹ä¼šè¢«é˜»å¡ï¼ŒåŒæ—¶ä¼šå­˜åœ¨çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢å’Œçº¿ç¨‹é‡æ–°è°ƒåº¦çš„å¼€é”€ï¼Œè¿™ä¹Ÿæ˜¯ä½¿ç”¨é”æ–¹å¼ä¸å¥½çš„åœ°æ–¹ã€‚ è€Œ volatie æ˜¯éé˜»å¡ç®—æ³•ï¼Œä¸ä¼šé€ æˆçº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€ã€‚

ä½†å¹¶éåœ¨æ‰€æœ‰æƒ…å†µä¸‹ä½¿ç”¨å®ƒä»¬éƒ½æ˜¯ç­‰ä»·çš„ï¼Œvolatile è™½ç„¶æä¾›äº†å¯è§æ€§ä¿è¯ï¼Œä½†å¹¶ä¸ä¿è¯æ“ä½œçš„åŸå­æ€§ã€‚

é‚£ä¹ˆä¸€èˆ¬åœ¨ä»€ä¹ˆæ—¶å€™æ‰ä½¿ç”¨ volatile å…³é”®å­—å‘¢ï¼š

-   å†™å…¥å˜é‡å€¼ä¸ä¾èµ–å˜é‡çš„å½“å‰å€¼æ—¶ã€‚å› ä¸ºå¦‚æœä¾èµ–å½“å‰å€¼ï¼Œå°†æ˜¯è·å–â€”â€”è®¡ç®—â€”â€”å†™å…¥ä¸‰æ­¥æ“ä½œï¼Œè¿™ä¸‰æ­¥æ“ä½œä¸æ˜¯åŸå­æ€§çš„ï¼Œè€Œ volatile ä¸ä¿è¯åŸå­æ€§ã€‚
    
-   è¯»å†™å˜é‡å€¼æ—¶æ²¡æœ‰åŠ é”ã€‚å› ä¸ºåŠ é”æœ¬èº«å·²ç»ä¿è¯äº†å†…å­˜å¯è§æ€§ï¼Œè¿™æ—¶å€™ä¸éœ€è¦æŠŠå˜é‡å£°æ˜ä¸º volatile çš„ ã€‚
    

## 2.7 Java ä¸­çš„åŸå­æ€§æ“ä½œ

æ‰€è°“åŸå­æ€§æ“ä½œï¼Œæ˜¯æŒ‡æ‰§è¡Œä¸€ç³»åˆ—æ“ä½œæ—¶ï¼Œè¿™äº›æ“ä½œè¦ä¹ˆå…¨éƒ¨æ‰§è¡Œï¼Œè¦ä¹ˆå…¨éƒ¨ä¸æ‰§è¡Œï¼Œä¸å­˜åœ¨åªæ‰§è¡Œå…¶ä¸­ä¸€éƒ¨åˆ†çš„æƒ…å†µã€‚ åœ¨è®¾è®¡è®¡æ•°å™¨æ—¶ä¸€èˆ¬éƒ½å…ˆè¯»å–å½“å‰å€¼ï¼Œç„¶å +lï¼Œå†æ›´æ–°ã€‚è¿™ä¸ªè¿‡ç¨‹æ˜¯è¯»â€”â€”æ”¹â€”â€”å†™çš„è¿‡ç¨‹ï¼Œå¦‚æœä¸èƒ½ä¿è¯è¿™ä¸ªè¿‡ç¨‹æ˜¯åŸå­æ€§çš„ï¼Œé‚£ä¹ˆå°±ä¼šå‡ºç°çº¿ç¨‹å®‰ å…¨é—®é¢˜ã€‚å¦‚ä¸‹ä»£ç æ˜¯çº¿ç¨‹ä¸å®‰å…¨çš„ï¼Œå› ä¸ºä¸èƒ½ä¿è¯ ++value æ˜¯åŸå­æ€§æ“ä½œã€‚

public class ThreadNotSafeCount {  
	private Long value ;  
	publiC Long getCount () {   
        return value ;  
    }  
    public void inc() {  
        ++value ;  
    }  
}

java -c å‘½ä»¤æŸ¥çœ‹æ±‡ç¼–ä»£ç 

public void inc();  
  Code:  
	0: aload 0  
	1: dup  
	2: getfield 		#2  Field value: J  
    5: lconst 1  
	6: ladd  
	7: putfield 		#2  Field value: J  
  10 : return

ç”±æ­¤å¯è§ï¼Œç®€å•çš„ ++value ç”± 2ã€ 5ã€ 6ã€7 å››æ­¥ç»„æˆï¼Œå…¶ä¸­ç¬¬ 2 æ­¥æ˜¯è·å–å½“å‰ value çš„å€¼å¹¶æ”¾å…¥æ ˆé¡¶ï¼Œç¬¬ 5 æ­¥æŠŠå¸¸é‡ 1 æ”¾å…¥æˆ˜é¡¶ï¼Œç¬¬ 6 æ­¥æŠŠå½“å‰æ ˆé¡¶ä¸­ä¸¤ä¸ªå€¼ç›¸åŠ å¹¶æŠŠç»“æœæ”¾å…¥æ ˆé¡¶ï¼Œç¬¬ 7 æ­¥åˆ™æŠŠæ ˆé¡¶çš„ç»“æœèµ‹ç»™ value å˜é‡ã€‚å› æ­¤ï¼Œ Java ä¸­ç®€å•çš„ä¸€å¥ ++value è¢«è½¬æ¢ä¸ºæ±‡ç¼–åå°±ä¸å…·æœ‰åŸå­æ€§äº† ã€‚

é‚£ä¹ˆå¦‚ä½•æ‰èƒ½ä¿è¯å¤šä¸ªæ“ä½œçš„åŸå­æ€§å‘¢?æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ synchronized å…³é”®å­—è¿›è¡ŒåŒæ­¥ï¼Œä¿®æ”¹ä»£ç å¦‚ä¸‹ï¼š

public class ThreadNotSafeCount {  
	private Long value ;  
	publiC synchronized Long getCount () {   
        return value ;  
    }  
    public synchronized void inc() {  
        ++value ;  
    }  
}

ä½¿ç”¨ synchronized å…³é”®å®‡çš„ç¡®å¯ä»¥å®ç°çº¿ç¨‹å®‰å…¨æ€§ï¼Œsynchronized æ˜¯ç‹¬å é”ï¼Œæ²¡æœ‰è·å–å†…éƒ¨é”çš„çº¿ç¨‹ä¼šè¢«é˜»å¡æ‰ï¼Œè€Œè¿™é‡Œçš„ getCount æ–¹æ³•åªæ˜¯è¯»æ“ä½œï¼Œå¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ä¸ä¼šå­˜åœ¨çº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚ä½†æ˜¯åŠ äº†å…³é”®å®‡ synchronized åï¼ŒåŒ ä¸€æ—¶é—´å°±åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è°ƒç”¨ï¼Œè¿™æ˜¾ç„¶å¤§å¤§é™ä½äº†å¹¶å‘æ€§ã€‚ä½ ä¹Ÿè®¸ä¼šé—´ï¼Œæ—¢ç„¶æ˜¯åªè¯» æ“ä½œï¼Œé‚£ä¸ºä½•ä¸å»æ‰ getCount æ–¹æ³•ä¸Šçš„ synchronized å…³é”®å­—å‘¢ï¼Ÿå…¶å®æ˜¯ä¸èƒ½å»æ‰çš„ï¼Œå› ä¸º**è¿™é‡Œè¦é  synchronized æ¥å®ç° value çš„å†…å­˜å¯è§æ€§**ã€‚ä¸‹é¢è®²åˆ°çš„åœ¨å†…éƒ¨ä½¿ç”¨éé˜»å¡ CAS ç®—æ³•å®ç°çš„åŸå­æ€§æ“ä½œç±» AtomicLong å°±æ˜¯ ä¸€ä¸ªæ›´å¥½çš„é€‰æ‹©ã€‚

## 2.8 Java ä¸­çš„ CAS æ“ä½œ

ä½¿ç”¨é”æœ‰ä¸€ä¸ªä¸å¥½çš„åœ°æ–¹ï¼Œå°±æ˜¯å½“ä¸€ä¸ªçº¿ç¨‹æ²¡æœ‰è·å–åˆ°é”æ—¶ä¼šè¢«é˜»å¡æŒ‚èµ·ï¼Œè¿™ä¼šå¯¼è‡´çº¿ç¨‹ä¸Šä¸‹æ–‡çš„åˆ‡æ¢å’Œé‡æ–°è°ƒåº¦å¼€é”€ã€‚Java æä¾›äº†éé˜»å¡çš„ volatile å…³é”®å­—æ¥è§£å†³å…±äº«å˜é‡çš„å¯è§æ€§é—®é¢˜ï¼Œè¿™åœ¨ä¸€ å®šç¨‹åº¦ä¸Šå¼¥è¡¥äº†é”å¸¦æ¥çš„å¼€é”€é—®é¢˜ï¼Œä½†æ˜¯ volatile åªèƒ½ä¿è¯å…±äº«å˜é‡çš„å¯è§æ€§ï¼Œä¸èƒ½è§£å†³è¯»æ”¹ä¸€å†™ç­‰çš„åŸå­æ€§é—®é¢˜ã€‚ CAS å³ Compare and Swapï¼Œæ˜¯ JDK æä¾›çš„éé˜»å¡åŸå­æ€§æ“ä½œï¼Œå®ƒé€šè¿‡ç¡¬ä»¶ä¿è¯äº†æ¯”è¾ƒæ›´æ–°æ“ä½œçš„åŸå­æ€§ã€‚JDK é‡Œé¢çš„ Unsafe ç±»æä¾›äº†ä¸€ç³»åˆ—çš„ compareAndSwap* æ–¹æ³•ï¼Œä¸‹é¢ä»¥ compareAndSwapLong æ–¹æ³•ä¸ºä¾‹è¿›è¡Œç®€å•ä»‹ç» ã€‚

boolean compareAndSwapLong(Object obj, long valueOffset, long expect, long update) æ–¹æ³•ï¼šå…¶ä¸­ compareAndSwap çš„æ„æ€æ˜¯æ¯”è¾ƒå¹¶äº¤æ¢ã€‚CASæœ‰å››ä¸ªæ“ä½œæ•°ï¼Œåˆ†åˆ«ä¸ºï¼šå¯¹è±¡å†…å­˜ä½ç½®ã€å¯¹è±¡ä¸­çš„å˜é‡çš„åç§»é‡ã€å˜é‡é¢„æœŸå€¼å’Œæ–°çš„å€¼ã€‚å…¶æ“ä½œå«ä¹‰æ˜¯ï¼Œå¦‚æœå¯¹è±¡ obj ä¸­å†…å­˜åç§»é‡ä¸º valueOffset çš„å˜é‡å€¼ä¸º expectï¼Œåˆ™ä½¿ç”¨æ–°çš„å€¼ update æ›¿æ¢æ—§çš„å€¼ expectã€‚è¿™æ˜¯å¤„ç†å™¨æä¾›çš„ä¸€ä¸ªåŸå­æ€§æŒ‡ä»¤ã€‚

å…³äº CAS æ“ä½œæœ‰ä¸ªç»å…¸çš„ ABA é—®é¢˜ï¼Œå…·ä½“å¦‚ä¸‹ï¼šå‡å¦‚çº¿ç¨‹ I ä½¿ç”¨ CAS ä¿®æ”¹åˆå§‹å€¼ä¸º A çš„å˜é‡ Xï¼Œé‚£ä¹ˆçº¿ç¨‹ I ä¼šé¦–å…ˆå»è·å–å½“å‰å˜é‡ X çš„å€¼ï¼ˆä¸ºAï¼‰ï¼Œç„¶åä½¿ç”¨ CAS æ“ä½œå°è¯•ä¿®æ”¹ X çš„å€¼ä¸º Bï¼Œå¦‚æœä½¿ç”¨ CAS æ“ä½œæˆåŠŸäº†ï¼Œé‚£ä¹ˆç¨‹åºè¿è¡Œä¸€å®šæ˜¯æ­£ç¡®çš„å—ï¼Ÿå…¶å®æœªå¿…ï¼Œè¿™æ˜¯å› ä¸ºæœ‰å¯èƒ½åœ¨çº¿ç¨‹ I è·å–å˜é‡ X çš„å€¼ A åï¼Œåœ¨æ‰§è¡Œ CAS å‰ï¼Œçº¿ç¨‹ II ä½¿ç”¨ CAS ä¿®æ”¹äº†å˜é‡ X çš„å€¼ä¸º Bï¼Œç„¶ååˆä½¿ç”¨ CAS ä¿®æ”¹äº†å˜é‡ X çš„å€¼ä¸º Aã€‚ æ‰€ä»¥è™½ç„¶çº¿ç¨‹ I æ‰§è¡Œ CAS æ—¶ X çš„å€¼æ˜¯ Aï¼Œä½†æ˜¯è¿™ä¸ª A å·±ç»ä¸æ˜¯çº¿ç¨‹ I è·å–æ—¶çš„ A äº†ã€‚ è¿™å°±æ˜¯ ABA é—®é¢˜ã€‚

ABA é—®é¢˜çš„äº§ç”Ÿæ˜¯å› ä¸ºå˜é‡çš„çŠ¶æ€å€¼äº§ç”Ÿäº†ç¯å½¢è½¬æ¢ï¼Œå°±æ˜¯å˜é‡çš„å€¼å¯ä»¥ä» A åˆ° Bï¼Œç„¶åå†ä» B åˆ° Aã€‚å¦‚æœå˜é‡çš„å€¼åªèƒ½æœç€ä¸€ä¸ªæ–¹å‘è½¬æ¢ï¼Œæ¯”å¦‚ A åˆ° Bï¼ŒB åˆ° Cï¼Œä¸æ„æˆç¯ å½¢ï¼Œå°±ä¸ä¼šå­˜åœ¨é—®é¢˜ã€‚JDK ä¸­çš„ AtomicStampedReference ç±»ç»™æ¯ä¸ªå˜é‡çš„çŠ¶æ€å€¼éƒ½é…å¤‡äº†ä¸€ä¸ªæ—¶é—´æˆ³ï¼Œ ä»è€Œé¿å…äº†ABA é—®é¢˜çš„äº§ç”Ÿã€‚

## 2.9 Unsafe ç±»

### Unsafe ç±»çš„é‡è¦æ–¹æ³•

JDK çš„ rt.jar åŒ…ä¸­çš„ Unsafe ç±»æä¾›äº†ç¡¬ä»¶çº§åˆ«çš„åŸå­æ€§æ“ä½œï¼ŒUnsafeç±»ä¸­çš„æ–¹æ³•éƒ½æ˜¯ native æ–¹æ³•ï¼Œå®ƒä»¬ä½¿ç”¨ JNI çš„æ–¹å¼è®¿é—®æœ¬åœ° C++ å®ç°åº“ã€‚

-   long objectFieldOffset(Field field)ï¼šè¿”å›æŒ‡å®šçš„å˜é‡åœ¨æ‰€å±ç±»ä¸­çš„å†…å­˜åç§»åœ°å€ï¼Œè¯¥åç§»åœ°å€ä»…ä»…åœ¨è¯¥ Unsafe å‡½æ•°ä¸­è®¿é—®æŒ‡å®šå­—æ®µæ—¶ä½¿ç”¨ã€‚å¦‚ä¸‹ä»£ç ä½¿ç”¨ Unsafe ç±»è·å–å˜é‡ value åœ¨ AtomicLong å¯¹è±¡ä¸­çš„å†…å­˜åç§»ã€‚
    
    static{   
        try {  
    		valueOffset = unsafe.obbectFieldOffset  
                (AtomicLong.class.getDeclaredField(â€value")) ;  
    	}   
    	catch (Exception ex) {   
            throw new Error(ex);   
    	}  
    }
    
-   int arrayBaseOffset(Class arrayClass)ï¼šè·å–æ•°ç»„ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„åœ°å€ã€‚
    
-   int arraylndexScale(Class arrayClass)ï¼šè·å–æ•°ç»„ä¸­ä¸€ä¸ªå…ƒç´ å ç”¨çš„å­—èŠ‚ã€‚
    
-   boolean compareAndSwapLong(Object obj, long offset, long expect, long update)ï¼šæ¯”è¾ƒå¯¹è±¡ obj ä¸­åç§»é‡ä¸º offset çš„å˜é‡çš„å€¼æ˜¯å¦ä¸ expect ç›¸ç­‰ï¼Œç›¸ç­‰åˆ™ä½¿ç”¨ update å€¼æ›´æ–°ï¼Œç„¶åè¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚
    
-   public native long getLongvolatile(Object obj, long offset)ï¼šè·å–å¯¹è±¡ obj ä¸­åç§»é‡ä¸º offset çš„å˜é‡å¯¹åº” volatile è¯­ä¹‰çš„å€¼ã€‚
    
-   void putLongVolatile(Object obj, long offset, long value)ï¼šè®¾ç½® obj å¯¹è±¡ä¸­ offset åç§»çš„ç±»å‹ä¸º long çš„ field çš„å€¼ä¸º valueï¼Œæ”¯æŒ volatile è¯­ä¹‰ã€‚
    
-   void putOrderedLong(Object obj, long offset, long value)ï¼šè®¾ç½® obj å¯¹è±¡ä¸­ offset åç§»åœ°å€å¯¹åº”çš„ long å‹ field çš„å€¼ä¸º valueã€‚è¿™æ˜¯ä¸€ä¸ªæœ‰å»¶è¿Ÿçš„ putLongVolatile æ–¹æ³•ï¼Œå¹¶ä¸”ä¸ä¿è¯å€¼ä¿®æ”¹å¯¹å…¶ä»–çº¿ç¨‹ç«‹åˆ»å¯è§ã€‚åªæœ‰åœ¨å˜é‡ä½¿ç”¨ volatile ä¿®é¥°å¹¶ä¸”é¢„è®¡ä¼šè¢«æ„å¤–ä¿®æ”¹æ—¶æ‰ä½¿ç”¨è¯¥æ–¹æ³•ã€‚
    
-   void park(boolean isAbsolute, long time)ï¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œå…¶ä¸­å‚æ•° isAbsolute ç­‰äº false ä¸” time ç­‰äº 0 è¡¨ç¤ºä¸€ç›´é˜»å¡ã€‚time å¤§äº 0 è¡¨ç¤ºç­‰å¾…æŒ‡å®šçš„ time åé˜»å¡çº¿ç¨‹ä¼šè¢«å”¤é†’ï¼Œæ­¤æ—¶è¿™ä¸ª time æ˜¯ä¸ªç›¸å¯¹æ—¶é—´ã€‚å¦‚æœ isAbsolute ç­‰äº trueï¼Œå¹¶ä¸” time å¤§äº 0ï¼Œåˆ™è¡¨ç¤ºé˜»å¡ çš„çº¿ç¨‹åˆ°æŒ‡å®šçš„æ—¶é—´ç‚¹åä¼šè¢«å”¤é†’ï¼Œè¿™é‡Œ time æ˜¯ä¸ªç»å¯¹æ—¶é—´ï¼Œæ˜¯å°†æŸä¸ªæ—¶é—´ç‚¹æ¢ç®—ä¸º ms åçš„å€¼ã€‚å¦å¤–ï¼Œå½“å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†å½“å‰é˜»å¡çº¿ç¨‹çš„ interrupt æ–¹æ³•è€Œä¸­æ–­äº†å½“å‰çº¿ç¨‹æ—¶ï¼Œå½“å‰çº¿ç¨‹ä¹Ÿä¼šè¿”å›ï¼Œè€Œå½“å…¶ä»–çº¿ç¨‹è°ƒç”¨äº† unPark æ–¹æ³•å¹¶ä¸”æŠŠå½“å‰çº¿ç¨‹ä½œä¸ºå‚æ•°æ—¶å½“ å‰çº¿ç¨‹ä¹Ÿä¼šè¿”å›ã€‚
    
-   void unpark(Object thread)ï¼šå”¤é†’è°ƒç”¨ park åé˜»å¡çš„çº¿ç¨‹ã€‚
    

ä¸‹é¢æ˜¯ JDK8 æ–°å¢çš„å‡½æ•° ï¼Œ è¿™é‡Œåªåˆ—å‡º Long ç±»å‹æ“ä½œã€‚

-   long getAndSetLong(Object obj, long offset, long update)ï¼šè·å–å¯¹è±¡ obj ä¸­åç§»é‡ä¸º offset çš„å˜é‡ volatile è¯­ä¹‰çš„å½“å‰å€¼ï¼Œå¹¶è®¾ç½®å˜é‡ volatile è¯­ä¹‰çš„å€¼ä¸º updateã€‚
    
    public final long getAndSetLong(Object obj, long offset, long update) {  
        long l;  
        do {  
            l = getLongvolatile(obj, offset); //(1)  
        } while (!compareAndSwapLong(obj , offset , l, update);  
        return l;  
    }
    
    ç”±ä»¥ä¸Šä»£ç å¯çŸ¥ï¼Œé¦–å…ˆ (1) å¤„çš„ getLongvolatile è·å–å½“å‰å˜é‡çš„å€¼ï¼Œç„¶åä½¿ç”¨ CAS åŸå­æ“ä½œè®¾ç½®æ–°å€¼ã€‚è¿™é‡Œä½¿ç”¨ while å¾ªç¯æ˜¯è€ƒè™‘åˆ°ï¼Œåœ¨å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨çš„æƒ…å†µä¸‹ CAS å¤±è´¥æ—¶éœ€è¦é‡è¯•ã€‚
    
-   long getAndAddLong(Object obj, long offset, long addValue)ï¼šè·å–å¯¹è±¡ obj ä¸­åç§»é‡ä¸º offset çš„å˜é‡ volatile è¯­ä¹‰çš„å½“å‰å€¼ï¼Œå¹¶è®¾ç½®å˜é‡å€¼ä¸ºåŸå§‹å€¼ +addValueã€‚
    
    public final long getAndAddLong(Object obj, long offset, long addValue) {  
        long l;  
        do {  
            l = getLongvolatile(obj, offset);   
        } while (!compareAndSwapLong(obj , offset , l, l + addValue);  
        return l;  
    }
    

### å¦‚ä½•ä½¿ç”¨ Unsafe ç±»

public class TestUnsafe {  
    static final Unsafe unsafe = Unsafe.getUnsafe();  
    static final long stateOffset;  
    private volatile long state = 0;  
  
    static {  
        try {  
            stateOffset = unsafe.objectFieldOffset  
                	(TestUnsafe.class.getDeclaredField("state"));  
        } catch (Exception e) {  
            System.out.println(e.getLocalizedMessage());  
            throw new Error(e);  
        }  
    }  
  
    public static void main(String[] args) {  
        TestUnsafe test = new TestUnsafe();  
        Boolean success = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);  
        System.out.println(success);  
    }  
}  
  
è¾“å‡ºï¼š  
Exception in thread "main" java.lang.ExceptionInInitializerError  
Caused by: java.lang.SecurityException: Unsafe  
	at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)  
	at com.chenghuipeng.learning.TestUnsafe.<clinit>(TestUnsafe.java:7)

getUnsafe() æ–¹æ³•æŠ¥é”™ï¼ŒæŸ¥çœ‹æºç ï¼š

 	@CallerSensitive  
    public static Unsafe getUnsafe() {  
        Class var0 = Reflection.getCallerClass();		// 1  
        if (!VM.isSystemDomainLoader(var0.getClassLoader())) {		// 2  
            throw new SecurityException("Unsafe");  
        } else {  
            return theUnsafe;  
        }  
    }  
	  
	// 3. åˆ¤æ–­ paramClassLoader æ˜¯ä¸æ˜¯ Bootstrap ç±»åŠ è½½å™¨  
	public static boolean isSystemDomainLoader  
        					(ClassLoader paramClassLoader) {  
        return paramClassLoader == null;  
    }

1.  è·å–è°ƒç”¨ getUnsafe è¿™ä¸ªæ–¹æ³•çš„å¯¹è±¡çš„ Class å¯¹è±¡ï¼›
    
2.  åˆ¤æ–­æ˜¯ä¸æ˜¯ Bootstrap ç±»åŠ è½½å™¨åŠ è½½çš„ localClassï¼Œåœ¨è¿™é‡Œæ˜¯çœ‹æ˜¯ä¸æ˜¯ Bootstrap åŠ è½½å™¨åŠ è½½äº† TestUnSafe.classã€‚å¾ˆæ˜æ˜¾ç”±äº TestUnSafe.class æ˜¯ä½¿ç”¨ AppClassLoader åŠ è½½çš„ ï¼Œæ‰€ä»¥è¿™é‡Œç›´æ¥æŠ›å‡ºäº†å¼‚å¸¸ã€‚
    
    > Unsafe ç±»æ˜¯ rt.jar åŒ…æä¾›çš„ï¼Œrt.jar åŒ…é‡Œé¢çš„ç±»æ˜¯ä½¿ç”¨ Bootstrap ç±»åŠ è½½å™¨åŠ è½½çš„ï¼Œè€Œæˆ‘ä»¬çš„å¯åŠ¨ main å‡½æ•°æ‰€åœ¨çš„ç±»æ˜¯ä½¿ç”¨ AppC!assLoader åŠ è½½çš„ï¼Œæ‰€ä»¥åœ¨ main å‡½æ•°é‡Œé¢åŠ è½½ Unsafe ç±»æ—¶ï¼Œæ ¹æ®å§”æ‰˜æœºåˆ¶ï¼Œä¼šå§”æ‰˜ç»™ Bootstrap å»åŠ è½½ Unsafe ç±»ã€‚
    > 
    > å› ä¸º Unsafe ç±»å¯ä»¥ç›´æ¥æ“ä½œå†…å­˜ï¼Œæ‰€ä»¥åšäº†æ­¤é™åˆ¶ã€‚
    

å¯ä»¥é€šè¿‡åå°„æ¥è·å– Unsafe å®ä¾‹ï¼š

  
public class TestUnsafe {  
    static final Unsafe unsafe;  
    static final long stateOffset;  
    private volatile long state = 0;  
  
    static {  
        try {  
            Field field = Unsafe.class.getDeclaredField("theUnsafe");  
            field.setAccessible(true);  
            unsafe = (Unsafe) field.get(null);  
            stateOffset = unsafe.objectFieldOffset  
                		(TestUnsafe.class.getDeclaredField("state"));  
        } catch (Exception e) {  
            System.out.println(e.getLocalizedMessage());  
            throw new Error(e);  
        }  
    }  
  
    public static void main(String[] args) {  
        TestUnsafe test = new TestUnsafe();  
        Boolean success = unsafe.compareAndSwapInt(test, stateOffset, 0, 1);  
        System.out.println(success);  
    }  
}  

## 2.10 Java æŒ‡ä»¤é‡æ’åº

Java å†…å­˜æ¨¡å‹å…è®¸ç¼–è¯‘å™¨å’Œå¤„ç†å™¨å¯¹æŒ‡ä»¤é‡æ’åºä»¥æé«˜è¿è¡Œæ€§èƒ½ï¼Œå¹¶ä¸”åªä¼šå¯¹ä¸å­˜åœ¨æ•°æ®ä¾èµ–æ€§çš„æŒ‡ä»¤é‡æ’åºã€‚åœ¨å•çº¿ç¨‹ä¸‹é‡æ’åºå¯ä»¥ä¿è¯æœ€ç»ˆæ‰§è¡Œçš„ç»“æœä¸ç¨‹åºé¡ºåºæ‰§è¡Œçš„ç»“æœä¸€è‡´ï¼Œä½†æ˜¯åœ¨å¤šçº¿ç¨‹ä¸‹å°±ä¼šå­˜åœ¨é—®é¢˜ã€‚

int a = 1;		(1)  
int b = 2;		(2)  
int c = a + b;	(3)

åœ¨å¦‚ä¸Šä»£ç ä¸­ï¼Œå˜é‡ c çš„å€¼ä¾èµ– a å’Œ b çš„å€¼ï¼Œæ‰€ä»¥é‡æ’åºåèƒ½å¤Ÿä¿è¯ (3) çš„æ“ä½œåœ¨ (2) (1) ä¹‹åï¼Œä½†æ˜¯ (1) (2) è°å…ˆæ‰§è¡Œå°±ä¸ä¸€å®šäº†ï¼Œè¿™åœ¨å•çº¿ç¨‹ä¸‹ä¸ä¼šå­˜åœ¨é—®é¢˜ã€‚

	private static int num = 0;  
    private static boolean ready = false;  
  
	public static class ReadThread extends Thread{  
        @Override  
        public void run() {  
            while (!Thread.currentThread().isInterrupted()) {  
                if (ready) {		// (1)  
                    System.out.println(num + num);		// (2)  
                }  
                System.out.println("read thread...");  
            }  
        }  
    }  
    public static class WriteThread extends Thread {  
        @Override  
        public void run() {  
            num = 2;				// (3)  
            ready = true;			// (4)  
            System.out.println("write thread set over...");  
        }  
    }  
  
    public static void main(String[] args) throws InterruptedException {  
        ReadThread rt = new ReadThread();  
        rt.start();  
        WriteThread wt = new WriteThread();  
        wt.start();  
  
        Thread.sleep(10);  
        rt.interrupt();  
        System.out.println("main exit");  
    }

é¦–å…ˆè¿™æ®µä»£ç é‡Œé¢çš„å˜é‡æ²¡æœ‰è¢«å£°æ˜ä¸º volatile çš„ï¼Œä¹Ÿæ²¡æœ‰ä½¿ç”¨ä»»ä½•åŒæ­¥æªæ–½ï¼Œæ‰€ä»¥åœ¨å¤šçº¿ç¨‹ä¸‹å­˜åœ¨å…±äº«å˜é‡å†…å­˜å¯è§æ€§é—®é¢˜ã€‚è¿™é‡Œå…ˆä¸è°ˆå†…å­˜å¯è§æ€§é—®é¢˜ï¼Œå› ä¸ºé€šè¿‡æŠŠå˜é‡å£°æ˜ä¸º volatile çš„æœ¬èº«å°±å¯ä»¥é¿å…æŒ‡ä»¤é‡æ’åºé—®é¢˜ã€‚

è¿™é‡Œå…ˆçœ‹çœ‹æŒ‡ä»¤é‡æ’åºä¼šé€ æˆä»€ä¹ˆå½±å“ï¼Œå¦‚ä¸Šä»£ç åœ¨ä¸è€ƒè™‘å†…å­˜å¯è§æ€§é—®é¢˜çš„æƒ…å†µä¸‹ä¸€å®šä¼šè¾“å‡º 4ï¼Ÿç­”æ¡ˆæ˜¯ä¸ä¸€å®šï¼Œç”±äºä»£ç  (1) (2) (3) (4) ä¹‹é—´ä¸å­˜åœ¨ä¾èµ–å…³ç³»ï¼Œæ‰€ä»¥å†™çº¿ç¨‹çš„ä»£ç  (3) (4) å¯èƒ½è¢«é‡æ’åºä¸ºå…ˆæ‰§è¡Œ (4) å†æ‰§è¡Œ (3)ï¼Œé‚£ä¹ˆæ‰§è¡Œ (4) åï¼Œè¯»çº¿ç¨‹å¯èƒ½å·²ç»æ‰§è¡Œäº† (1) æ“ä½œï¼Œå¹¶ä¸”åœ¨ (3) æ‰§è¡Œå‰å¼€å§‹æ‰§è¡Œ (2) æ“ä½œï¼Œè¿™æ—¶å€™è¾“å‡ºç»“æœä¸º 0 è€Œä¸æ˜¯ 4ã€‚

é‡æ’åºåœ¨å¤šçº¿ç¨‹ä¸‹ä¼šå¯¼è‡´éé¢„æœŸçš„ç¨‹åºæ‰§è¡Œç»“æœï¼Œè€Œä½¿ç”¨ volatile ä¿®é¥° ready å°±å¯ä»¥é¿å…é‡æ’åºå’Œå†…å­˜å¯è§æ€§é—®é¢˜ï¼š

-   å†™ volatile å˜é‡æ—¶ï¼Œå¯ä»¥ç¡®ä¿ volatile å†™ä¹‹å‰çš„æ“ä½œä¸ä¼šè¢«ç¼–è¯‘å™¨é‡æ’åºåˆ° volatile å†™ä¹‹åã€‚
    
-   è¯» volatile å˜é‡æ—¶ï¼Œå¯ä»¥ç¡®ä¿ volatile è¯»ä¹‹åçš„æ“ä½œä¸ä¼šè¢«ç¼–è¯‘å™¨é‡æ’åºåˆ° volatile è¯»ä¹‹å‰ã€‚
    

## 2.11 ä¼ªå…±äº«

### ä»€ä¹ˆæ˜¯ä¼ªå…±äº«

ä¸ºäº†è§£å†³è®¡ç®—æœºç³»ç»Ÿä¸­ä¸»å†…å­˜ä¸ CPU ä¹‹é—´è¿è¡Œé€Ÿåº¦å·®é—®é¢˜ï¼Œä¼šåœ¨ CPU ä¸ä¸»å†…å­˜ä¹‹é—´æ·»åŠ ä¸€çº§æˆ–è€…å¤šçº§é«˜é€Ÿç¼“å†²å­˜å‚¨å™¨ï¼ˆCacheï¼‰ã€‚è¿™ä¸ª Cache ä¸€èˆ¬æ˜¯è¢«é›†æˆåˆ° CPU å†…éƒ¨çš„ï¼Œæ‰€ä»¥ä¹Ÿå« CPU Cacheï¼Œä¸‹å›¾æ‰€ç¤ºæ˜¯ä¸¤çº§ Cache ç»“æ„ã€‚

![Screen Shot 2021-06-04 at 23.42.54](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-04%20at%2023.42.54.png)

åœ¨ Cache å†…éƒ¨æ˜¯æŒ‰è¡Œå­˜å‚¨çš„ï¼Œå…¶ä¸­æ¯ä¸€è¡Œç§°ä¸ºä¸€ä¸ª Cache è¡Œã€‚Cacheè¡Œï¼ˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼‰æ˜¯ Cache ä¸ä¸»å†…å­˜è¿›è¡Œæ•°æ®äº¤æ¢çš„å•ä½ï¼ŒCache è¡Œçš„å¤§å°ä¸€èˆ¬ä¸º 2 çš„å¹‚æ¬¡æ•°å­—èŠ‚ã€‚

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-04%20at%2023.43.44.png" alt="Screen Shot 2021-06-04 at 23.43.44" style="zoom:50%;" />

å½“ CPU è®¿é—®æŸä¸ªå˜é‡æ—¶ï¼Œé¦–å…ˆä¼šå»çœ‹ CPU Cache å†…æ˜¯å¦æœ‰è¯¥å˜é‡ï¼Œå¦‚æœæœ‰åˆ™ç›´æ¥ä»ä¸­è·å–ï¼Œå¦åˆ™å°±å»ä¸»å†…å­˜é‡Œé¢è·å–è¯¥å˜é‡ï¼Œç„¶åæŠŠè¯¥å˜é‡æ‰€åœ¨å†…å­˜åŒºåŸŸçš„**ä¸€ä¸ª Cache è¡Œå¤§å°çš„å†…å­˜**å¤åˆ¶åˆ° Cache ä¸­ã€‚ç”±äºå­˜æ”¾åˆ° Cache è¡Œçš„æ˜¯å†…å­˜å—è€Œä¸æ˜¯å•ä¸ªå˜é‡ï¼Œæ‰€ä»¥å¯èƒ½ä¼šæŠŠå¤šä¸ªå˜é‡å­˜æ”¾åˆ°ä¸€ä¸ª Cache è¡Œä¸­ã€‚å½“å¤šä¸ªçº¿ç¨‹åŒæ—¶ä¿®æ”¹ä¸€ä¸ªç¼“å­˜è¡Œé‡Œé¢çš„å¤šä¸ªå˜é‡æ—¶ï¼Œç”±äºåŒæ—¶åªèƒ½æœ‰ ä¸€ä¸ªçº¿ç¨‹æ“ä½œç¼“å­˜è¡Œï¼Œæ‰€ä»¥ç›¸æ¯”å°†æ¯ä¸ªå˜é‡æ”¾åˆ°ä¸€ä¸ªç¼“å­˜è¡Œï¼Œæ€§èƒ½ä¼šæœ‰æ‰€ä¸‹é™ï¼Œè¿™å°±æ˜¯ä¼ªå…±äº«ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-06-04 at 23.46.01](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-04%20at%2023.46.01.png)

åœ¨è¯¥å›¾ä¸­ï¼Œå˜é‡ x å’Œ y **åŒæ—¶**è¢«æ”¾åˆ°äº† CPU çš„ä¸€çº§å’ŒäºŒçº§ç¼“å­˜ï¼Œå¯¹å˜é‡ x è¿›è¡Œæ›´æ–°æ—¶ï¼Œé¦–å…ˆä¼šä¿®æ”¹ CPU1 çš„ä¸€çº§ç¼“å­˜å˜é‡ x æ‰€åœ¨çš„ç¼“å­˜è¡Œï¼Œè¿™æ—¶å€™åœ¨ç¼“å­˜ä¸€è‡´æ€§åè®®ä¸‹ï¼ŒCPU2 ä¸­å˜é‡ x å¯¹åº”çš„ç¼“å­˜è¡Œå¤±æ•ˆã€‚é‚£ä¹ˆçº¿ç¨‹ 2 åœ¨å†™å…¥å˜é‡ x æ—¶å°±åªèƒ½å»äºŒçº§ç¼“å­˜é‡ŒæŸ¥æ‰¾ï¼Œè¿™å°±ç ´åäº†ä¸€çº§ç¼“å­˜ã€‚è€Œä¸€çº§ç¼“å­˜æ¯”äºŒçº§ç¼“å­˜æ›´å¿«ï¼Œè¿™ä¹Ÿè¯´æ˜äº†å¤šä¸ªçº¿ç¨‹ä¸å¯èƒ½åŒæ—¶å»ä¿®æ”¹è‡ªå·±æ‰€ä½¿ç”¨çš„ CPU ä¸­ç›¸åŒç¼“å­˜è¡Œé‡Œé¢çš„å˜é‡ã€‚æ›´åçš„æƒ…å†µæ˜¯ï¼Œå¦‚æœ CPU åªæœ‰ä¸€çº§ç¼“å­˜ï¼Œåˆ™ä¼šå¯¼è‡´é¢‘ç¹åœ°è®¿é—®ä¸»å†…å­˜ ã€‚

### ä¸ºä½•å‡ºç°ä¼ªå…±äº«

ä¼ªå…±äº«çš„äº§ç”Ÿæ˜¯å› ä¸ºå¤šä¸ªå˜é‡è¢«æ”¾å…¥äº†ä¸€ä¸ªç¼“å­˜è¡Œä¸­ï¼Œå¹¶ä¸”å¤šä¸ªçº¿ç¨‹åŒæ—¶å»å†™å…¥ç¼“å­˜è¡Œä¸­ä¸åŒçš„å˜é‡ã€‚é‚£ä¹ˆä¸ºä½•å¤šä¸ªå˜é‡ä¼šè¢«æ”¾å…¥ä¸€ä¸ªç¼“å­˜è¡Œå‘¢ï¼Ÿå…¶å®æ˜¯å› ä¸ºç¼“å­˜ä¸å†…å­˜äº¤æ¢æ•°æ®çš„å•ä½å°±æ˜¯ç¼“å­˜è¡Œï¼Œå½“ CPU è¦è®¿é—®çš„å˜é‡æ²¡æœ‰åœ¨ç¼“å­˜ä¸­æ‰¾åˆ°æ—¶ï¼Œæ ¹æ®ç¨‹åºè¿è¡Œçš„å±€éƒ¨æ€§åŸç†ï¼Œä¼šæŠŠè¯¥å˜é‡æ‰€åœ¨å†…å­˜ä¸­å¤§å°ä¸ºç¼“å­˜è¡Œçš„å†…å­˜æ”¾å…¥ç¼“å­˜è¡Œã€‚

long a;	long b;	long c;	long d;

å¦‚ä¸Šä»£ç å£°æ˜äº†å››ä¸ª long å˜é‡ï¼Œå‡è®¾ç¼“å­˜è¡Œçš„å¤§å°ä¸º 32 å­—èŠ‚ï¼Œé‚£ä¹ˆå½“ CPU è®¿é—®å˜é‡ a æ—¶ï¼Œ å‘ç°è¯¥å˜é‡æ²¡æœ‰åœ¨ç¼“å­˜ä¸­ï¼Œå°±ä¼šå»ä¸»å†…å­˜æŠŠå˜é‡ a ä»¥åŠå†…å­˜åœ°å€é™„è¿‘çš„ bã€cã€d æ”¾å…¥ç¼“å­˜è¡Œã€‚ä¹Ÿå°±æ˜¯åœ°å€è¿ç»­çš„å¤šä¸ªå˜é‡æ‰æœ‰å¯èƒ½ä¼šè¢«æ”¾åˆ°ä¸€ä¸ªç¼“å­˜è¡Œä¸­ã€‚å½“åˆ›å»ºæ•°ç»„æ—¶ï¼Œæ•°ç»„é‡Œé¢çš„å¤šä¸ªå…ƒç´ å°±ä¼šè¢«æ”¾å…¥åŒä¸€ ä¸ªç¼“å­˜è¡Œã€‚é‚£ä¹ˆåœ¨å•çº¿ç¨‹ä¸‹å¤šä¸ªå˜é‡è¢«æ”¾å…¥åŒä¸€ä¸ªç¼“å­˜è¡Œå¯¹æ€§èƒ½æœ‰å½±å“å—ï¼Ÿå…¶å®åœ¨æ­£å¸¸æƒ…å†µä¸‹å•çº¿ç¨‹è®¿é—®æ—¶å°†æ•°ç»„å…ƒç´ æ”¾å…¥ä¸€ä¸ªæˆ–è€…å¤šä¸ªç¼“å­˜è¡Œå¯¹ä»£ç æ‰§è¡Œæ˜¯æœ‰åˆ©çš„ï¼Œå› ä¸ºæ•°æ®éƒ½åœ¨ç¼“å­˜ä¸­ï¼Œä»£ç æ‰§è¡Œä¼šæ›´å¿«ï¼Œè¯·å¯¹æ¯”ä¸‹é¢ä»£ç çš„æ‰§è¡Œã€‚

public class TestForContent {  
	static final int LINE NUM = 1024;  
	static final int COLUM NUM = 1024;  
      
	public static VOid main (String [] args) {  
		long [][] array = new long [LINE_NUM][COLUM_NUM);  
		long startTime = System.currentTimeMillis();   
        for(int i = 0; i< LINE_NUM; ++i){  
			for(int j = 0; j < COLUM_NUM; ++j){   
                array[i][j] = i * 2 + j;  
            }  
        }  
		long endTime = System.currentTimeMillis();   
		long cacheTime = endTime - startTime;  
		System.out.println("cache time :â€ + cacheTime);  
	}  
}

public class TestForContent2 {  
	static final int LINE NUM = 1024;  
	static final int COLUM NUM = 1024;  
      
	public static VOid main (String [] args) {  
		long [][] array = new long [LINE_NUM][COLUM_NUM);  
		long startTime = System.currentTimeMillis();   
        for(int i = 0; i < COLUM_NUM; ++i){  
			for(int j = 0; j < System; ++j){   
                array[j][i] = i * 2 + j;  
            }  
        }  
		long endTime = System.currentTimeMillis();   
		long cacheTime = endTime - startTime;  
		System.out.println("cache time :â€ + cacheTime);  
	}  
}

ä»£ç  (1) æ¯”ä»£ç  (2) æ‰§è¡Œå¾—å¿«ï¼Œè¿™æ˜¯å› ä¸ºæ•°ç»„å†…æ•°ç»„å…ƒç´ çš„å†…å­˜åœ°å€æ˜¯è¿ç»­çš„ï¼Œå½“è®¿é—®æ•°ç»„ç¬¬ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œä¼šæŠŠç¬¬ä¸€ä¸ªå…ƒç´ åçš„è‹¥å¹²å…ƒç´ ä¸€å—æ”¾å…¥ç¼“å­˜è¡Œï¼Œè¿™æ ·é¡ºåºè®¿é—®æ•°ç»„å…ƒç´ æ—¶ä¼šåœ¨ç¼“å­˜ä¸­ç›´æ¥å‘½ä¸­ï¼Œå› è€Œå°±ä¸ä¼šå»ä¸»å†…å­˜è¯»å–äº†ï¼Œåç»­è®¿é—®ä¹Ÿæ˜¯è¿™æ ·ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“é¡ºåºè®¿é—®æ•°ç»„é‡Œé¢å…ƒç´ æ—¶ï¼Œå¦‚æœå½“å‰å…ƒç´ åœ¨ç¼“å­˜æ²¡æœ‰å‘½ä¸­ï¼Œé‚£ä¹ˆä¼šä»ä¸»å†…å­˜ä¸€ä¸‹å­è¯»å–åç»­è‹¥å¹²ä¸ªå…ƒç´ åˆ°ç¼“å­˜ï¼Œä¹Ÿå°±æ˜¯ä¸€æ¬¡å†…å­˜è®¿é—®å¯ä»¥è®©åé¢å¤šæ¬¡ è®¿é—®ç›´æ¥åœ¨ç¼“å­˜ä¸­å‘½ä¸­ã€‚è€Œä»£ç  (2) æ˜¯è·³è·ƒå¼è®¿é—®æ•°ç»„å…ƒç´ çš„ï¼Œä¸æ˜¯é¡ºåºçš„ï¼Œè¿™ç ´åäº†ç¨‹åºè®¿é—®çš„å±€éƒ¨æ€§åŸåˆ™ï¼Œå¹¶ä¸”ç¼“å­˜æ˜¯æœ‰å®¹é‡æ§åˆ¶çš„ï¼Œå½“ç¼“å­˜æ»¡äº†æ—¶ä¼šæ ¹æ®ä¸€å®šæ·˜æ±°ç®—æ³•æ›¿æ¢ç¼“å­˜è¡Œï¼Œè¿™ä¼šå¯¼è‡´ä»å†…å­˜ç½®æ¢è¿‡æ¥çš„ç¼“å­˜è¡Œçš„å…ƒç´ è¿˜æ²¡ç­‰åˆ°è¢«è¯»å–å°±è¢«æ›¿æ¢æ‰äº†ã€‚

æ‰€ä»¥åœ¨å•ä¸ªçº¿ç¨‹ä¸‹é¡ºåºä¿®æ”¹ä¸€ä¸ªç¼“å­˜è¡Œä¸­çš„å¤šä¸ªå˜é‡ï¼Œä¼šå……åˆ†åˆ©ç”¨ç¨‹åºè¿è¡Œçš„å±€éƒ¨æ€§åŸåˆ™ï¼Œä»è€ŒåŠ é€Ÿäº†ç¨‹åºçš„è¿è¡Œã€‚è€Œåœ¨å¤šçº¿ç¨‹ä¸‹å¹¶å‘ä¿®æ”¹ä¸€ä¸ªç¼“å­˜è¡Œä¸­çš„å¤šä¸ªå˜é‡æ—¶å°±ä¼šç«äº‰ç¼“å­˜è¡Œï¼Œä»è€Œé™ä½ç¨‹åºè¿è¡Œæ€§èƒ½ ã€‚

### å¦‚ä½•é¿å…ä¼ªå…±äº«

#### å­—èŠ‚å¡«å……

JDK 8 ä¹‹å‰ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨å­—èŠ‚å¡«å……çš„æ–¹å¼ã€‚åˆ›å»ºä¸€ä¸ªå˜é‡æ—¶ä½¿ç”¨å¡«å……å­—æ®µå¡«å……è¯¥å˜é‡æ‰€åœ¨çš„ç¼“å­˜è¡Œï¼Œè¿™æ ·å°±é¿å…äº†å°†å¤šä¸ªå˜é‡å­˜æ”¾åœ¨åŒä¸€ä¸ªç¼“å­˜è¡Œä¸­ï¼Œä¾‹å¦‚å¦‚ä¸‹ä»£ç ï¼š

public final static class FilledLong {  
    public volatile long value = 0L;  
    public long p1, p2, p3, p4, p5, p6;  
}

å‡å¦‚ç¼“å­˜è¡Œä¸º 64 å®‡èŠ‚ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨ FilledLong ç±»é‡Œé¢å¡«å……äº† 6 ä¸ª long ç±»å‹çš„å˜é‡ï¼Œæ¯ä¸ª long ç±»å‹å˜é‡å ç”¨ 8 å­—èŠ‚ï¼ŒåŠ ä¸Š value å˜é‡çš„ 8 å­—èŠ‚æ€»å…± 56 å­—èŠ‚ã€‚å¦å¤–ï¼Œè¿™é‡Œ FilledLong æ˜¯ä¸€ä¸ªç±»å¯¹è±¡ï¼Œè€Œç±»å¯¹è±¡çš„**å­—èŠ‚ç çš„å¯¹è±¡å¤´å ç”¨ 8 å­—èŠ‚**ï¼Œæ‰€ä»¥ä¸€ä¸ª FilledLong å¯¹è±¡å®é™…ä¼šå ç”¨ 64 å­—èŠ‚çš„å†…å­˜ï¼Œè¿™æ­£å¥½å¯ä»¥æ”¾å…¥ä¸€ä¸ªç¼“å­˜è¡Œã€‚

#### æ³¨è§£

JDK 8 æä¾›äº†ä¸€ä¸ª sun.misc.Contended æ³¨è§£ï¼Œç”¨æ¥è§£å†³ä¼ªå…±äº«é—®é¢˜ã€‚å°†ä¸Šé¢ä»£ç ä¿®æ”¹ä¸ºå¦‚ä¸‹ã€‚

@sum.misc.Contended  
public final static class FilledLong {  
    public volatile long value = 0L;  
}

åœ¨è¿™é‡Œæ³¨è§£ç”¨æ¥ä¿®é¥°ç±»ï¼Œä¹Ÿå¯ä»¥ä¿®é¥°å˜é‡ï¼Œæ¯”å¦‚åœ¨ Threadç±»ä¸­ã€‚

/** The current seed for a ThreadLocalRandom */  
@sun.misc.Contended("tlr")  
long threadLocalRandomSeed;  
  
/** Probe hash value; nonzero if threadLocalRandomSeed initialized */  
@sun.misc.Contended("tlr")  
int threadLocalRandomProbe;  
  
/** Secondary seed isolated from public ThreadLocalRandom sequence */  
@sun.misc.Contended("tlr")  
int threadLocalRandomSecondarySeed;

> Thread ç±»é‡Œé¢è¿™ä¸‰ä¸ªå˜é‡é»˜è®¤è¢«åˆå§‹åŒ–ä¸º 0ï¼Œå¹¶ä¼šåœ¨ ThreadLocalRandom ç±»ä¸­ä½¿ç”¨ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œ@Contended æ³¨è§£åªç”¨äº Java æ ¸å¿ƒç±»ï¼Œ æ¯”å¦‚æ­¤åŒ…ä¸‹çš„ ç±»ã€‚å¦‚æœç”¨æˆ·ç±»è·¯å¾„ä¸‹çš„ç±»éœ€è¦ä½¿ç”¨è¿™ä¸ªæ³¨è§£ï¼Œåˆ™éœ€è¦æ·»åŠ  JVM å‚æ•°ï¼š`-XX:-RestrictContended`ã€‚å¡«å……çš„å®½åº¦é»˜è®¤ä¸º 128ï¼Œè¦è‡ªå®šä¹‰å®½åº¦åˆ™å¯ä»¥è®¾ç½® `-XX:ContendPaddingWidth` å‚æ•°

## 2.12 é”çš„æ¦‚è¿°

### æ‚²è§‚é”å’Œä¹è§‚é”

æ‚²è§‚é”å’Œä¹è§‚é”æ˜¯åœ¨æ•°æ®åº“ä¸­å¼•å…¥çš„åè¯ï¼Œå¹¶å‘åŒ…é”é‡Œä¹Ÿå¼•å…¥äº†ç±»ä¼¼çš„æ€æƒ³ã€‚

-   æ‚²è§‚é”çš„å®ç°ä¸€èˆ¬ä¾é æ•°æ®åº“æä¾›çš„é”æœºåˆ¶ã€‚
    
-   ä¹è§‚é”å¹¶ä¸ä¼šä½¿ç”¨æ•°æ®åº“æä¾›çš„é”æœºåˆ¶ï¼Œä¸€èˆ¬åœ¨è¡¨ä¸­æ·»åŠ  version å­—æ®µæˆ–ä½¿ç”¨ä¸šåŠ¡çŠ¶æ€æ¥å®ç°ã€‚ä¹è§‚é”ç›´åˆ°æäº¤æ—¶æ‰é”å®šï¼Œæ‰€ä»¥ä¸ä¼šäº§ç”Ÿä»»ä½•æ­»é”ã€‚
    

### å…¬å¹³é”å’Œéå…¬å¹³é”

-   å…¬å¹³é”ï¼šReentrantLock pairLock = new ReentrantLock(true)ã€‚
    
-   éå…¬å¹³é”ï¼šReentrantLock pairLock = new ReentrantLock(false)ã€‚é»˜è®¤æ„é€ å‡½æ•°æ˜¯éå…¬å¹³é”ã€‚
    

æ²¡æœ‰å…¬å¹³æ€§éœ€æ±‚çš„æƒ…å†µå°½é‡ä½¿ç”¨éå…¬å¹³é”ï¼Œå› ä¸ºå…¬å¹³é”ä¼šå¸¦æ¥æ€§èƒ½å¼€é”€ã€‚

### ç‹¬å é”å’Œå…±äº«é”

-   ç‹¬å é”ï¼šReentrantLockã€‚
    
-   éç‹¬å é”ï¼šReadWriteLockã€‚
    

ç‹¬å é”æ˜¯ä¸€ç§æ‚²è§‚é”ï¼Œè€Œå…±äº«é”æ˜¯ä¸€ç§ä¹è§‚é”ï¼Œå…è®¸å¤šä¸ªçº¿ç¨‹åŒæ—¶è¿›è¡Œè¯»æ“ä½œã€‚

### å¯é‡å…¥é”

synchronized å†…éƒ¨é”æ˜¯å¯é‡å…¥é”ã€‚å¯é‡å…¥é”çš„åŸç†æ˜¯åœ¨é”å†…éƒ¨ç»´æŠ¤ä¸€ä¸ªçº¿ç¨‹æ ‡ç¤ºï¼Œç”¨æ¥æ ‡ç¤ºè¯¥é”ç›®å‰è¢«å“ªä¸ªçº¿ç¨‹å ç”¨ï¼Œç„¶åå…³è”ä¸€ä¸ªè®¡æ•°å™¨ã€‚ä¸€å¼€å§‹è®¡æ•°å™¨å€¼ä¸º 0ï¼Œè¯´æ˜è¯¥é”æ²¡æœ‰è¢«ä»»ä½•çº¿ç¨‹å ç”¨ã€‚å½“ä¸€ä¸ªé’±ç¨‹è·å–äº†è¯¥é”æ—¶ï¼Œè®¡æ•°å™¨çš„å€¼ä¼šå˜æˆ 1ï¼Œè¿™æ—¶å…¶ä»–çº¿ç¨‹å†æ¥è·å–è¯¥é”æ—¶ä¼šå‘ç°é”çš„æ‰€æœ‰è€…ä¸æ˜¯è‡ªå·±è€Œè¢«é˜»å¡æŒ‚èµ·ã€‚

ä½†æ˜¯å½“è·å–äº†è¯¥é”çš„çº¿ç¨‹å†æ¬¡è·å–é”æ—¶å‘ç°é”æ‹¥æœ‰è€…æ˜¯è‡ªå·±ï¼Œå°±ä¼šæŠŠè®¡æ•°å™¨å€¼åŠ  +1ï¼Œå½“é‡Šæ”¾é”åè®¡æ•°å™¨å€¼ -1ã€‚å½“è®¡æ•°å™¨å€¼ä¸º 0 æ—¶ï¼Œé”é‡Œé¢çš„çº¿ç¨‹æ ‡ç¤ºè¢«é‡ç½®ä¸º nullï¼Œè¿™æ—¶å€™è¢«é˜»å¡çš„çº¿ç¨‹ä¼šè¢«å”¤é†’æ¥ç«äº‰è·å–è¯¥é” ã€‚

### è‡ªæ—‹é”

ç”±äº Java ä¸­çš„çº¿ç¨‹æ˜¯ä¸æ“ä½œç³»ç»Ÿä¸­çš„çº¿ç¨‹ä¸€ä¸€å¯¹åº”çš„ï¼Œæ‰€ä»¥å½“ä¸€ä¸ªçº¿ç¨‹åœ¨è·å–é”ï¼ˆæ¯”å¦‚ç‹¬å é”ï¼‰å¤±è´¥åï¼Œä¼šè¢«åˆ‡æ¢åˆ°å†…æ ¸çŠ¶æ€è€Œè¢«æŒ‚èµ·ã€‚å½“è¯¥çº¿ç¨‹è·å–åˆ°é”æ—¶åˆéœ€è¦å°†å…¶åˆ‡æ¢åˆ°å†…æ ¸çŠ¶æ€è€Œå”¤é†’è¯¥çº¿ç¨‹ã€‚è€Œä»ç”¨æˆ·çŠ¶æ€åˆ‡æ¢åˆ°å†…æ ¸çŠ¶æ€çš„å¼€é”€æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šä¼šå½±å“å¹¶å‘æ€§èƒ½ã€‚

è‡ªæ—‹é”åˆ™æ˜¯ï¼Œå½“å‰çº¿ç¨‹åœ¨è·å–é”æ—¶ï¼Œå¦‚æœå‘ç°é”å·²ç»è¢«å…¶ä»–çº¿ç¨‹å æœ‰ï¼Œå®ƒä¸é©¬ä¸Šé˜»å¡è‡ªå·±ï¼Œåœ¨ä¸æ”¾å¼ƒ CPU ä½¿ç”¨æƒçš„æƒ…å†µä¸‹ï¼Œå¤šæ¬¡å°è¯•è·å–ï¼ˆé»˜è®¤æ¬¡æ•°æ˜¯ 10ï¼Œå¯ä»¥ä½¿ç”¨ -XX:PreBlockSpinsh å‚æ•°è®¾ç½®è¯¥å€¼ï¼‰ï¼Œå¾ˆæœ‰å¯èƒ½åœ¨åé¢å‡ æ¬¡å°è¯•ä¸­å…¶ä»–çº¿ç¨‹å·²ç»é‡Šæ”¾äº†é”ã€‚å¦‚æœå°è¯•æŒ‡å®šçš„æ¬¡æ•°åä»æ²¡æœ‰è·å–åˆ°é”åˆ™å½“å‰çº¿ç¨‹æ‰ä¼šè¢«é˜»å¡æŒ‚èµ·ã€‚ç”±æ­¤çœ‹æ¥è‡ªæ—‹é”æ˜¯ä½¿ç”¨ CPU æ—¶é—´æ¢å–çº¿ç¨‹é˜»å¡ä¸è°ƒåº¦çš„å¼€é”€ï¼Œä½†æ˜¯å¾ˆæœ‰å¯èƒ½è¿™äº› CPU æ—¶é—´ç™½ç™½æµªè´¹äº†ã€‚

# 3. ThreadLocalRandom ç±»

## 3.1 Random ç±»åŠå…¶å±€é™æ€§

éšæœºæ•°çš„ç”Ÿæˆéœ€è¦ä¸€ä¸ªé»˜è®¤çš„ç§å­ï¼Œè¿™ä¸ªç§å­å…¶å®æ˜¯ä¸€ä¸ª long ç±»å‹çš„æ•°å­—ï¼Œå¯ä»¥åœ¨åˆ›å»º Random å¯¹è±¡æ—¶é€šè¿‡æ„é€ å‡½æ•°æŒ‡å®šï¼Œå¦‚æœä¸æŒ‡å®šåˆ™åœ¨é»˜è®¤æ„é€ å‡½æ•°å†…éƒ¨ç”Ÿæˆä¸€ä¸ªé»˜è®¤çš„å€¼ã€‚ æœ‰äº†é»˜è®¤çš„ç§å­åï¼Œå¦‚ä½•ç”Ÿæˆéšæœºæ•°å‘¢ï¼Ÿ

	public int nextInt(int bound) {  
        if (bound <= 0)  
            throw new IllegalArgumentException(BadBound);  
		  
        // 1. æ ¹æ®è€çš„ç§å­ç”Ÿæˆæ–°çš„ç§å­  
        int r = next(31);  
        int m = bound - 1;  
          
        // 2. ä¸‹é¢æ‰€æœ‰æ˜¯æ ¹æ®æ–°çš„ç§å­è®¡ç®—éšæœºæ•°  
        if ((bound & m) == 0)  // i.e., bound is a power of 2  
            r = (int)((bound * (long)r) >> 31);  
        else {  
            for (int u = r;  
                 u - (r = u % bound) + m < 0;  
                 u = next(31));  
        }  
        return r;  
    }

åœ¨å•çº¿ç¨‹æƒ…å†µä¸‹æ¯æ¬¡è°ƒç”¨ nextInt éƒ½æ˜¯æ ¹æ®è€çš„ç§å­è®¡ç®—å‡ºæ–°çš„ç§å­ï¼Œè¿™æ˜¯å¯ä»¥ä¿è¯éšæœºæ•°äº§ç”Ÿçš„éšæœºæ€§çš„ã€‚ä½†æ˜¯åœ¨å¤šçº¿ç¨‹ä¸‹å¤šä¸ªçº¿ç¨‹å¯èƒ½éƒ½æ‹¿åŒä¸€ä¸ªè€çš„ç§å­å»æ‰§è¡Œæ­¥éª¤ (1) ä»¥è®¡ç®—æ–°çš„ç§å­ï¼Œè¿™ä¼šå¯¼è‡´å¤šä¸ªçº¿ç¨‹äº§ç”Ÿçš„æ–°ç§å­æ˜¯ä¸€æ ·çš„ï¼Œç”±äºæ­¥éª¤ (2) çš„ç®—æ³•æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥ä¼šå¯¼è‡´å¤šä¸ªçº¿ç¨‹äº§ç”Ÿ**ç›¸åŒçš„éšæœºå€¼**ã€‚æ‰€ä»¥æ­¥éª¤ (1) è¦ä¿è¯åŸå­æ€§ï¼Œä¹Ÿå°±æ˜¯è¯´å½“å¤šä¸ªçº¿ç¨‹æ ¹æ®åŒä¸€ä¸ªè€ç§å­è®¡ç®—æ–°ç§å­æ—¶ï¼Œç¬¬ä¸€ä¸ªçº¿ç¨‹çš„æ–°ç§å­è¢«è®¡ç®—å‡ºæ¥åï¼Œç¬¬äºŒä¸ªçº¿ç¨‹è¦ä¸¢å¼ƒè‡ªå·±è€çš„ç§å­ï¼Œè€Œä½¿ç”¨ç¬¬ ä¸€ ä¸ªçº¿ç¨‹çš„æ–°ç§å­æ¥è®¡ç®—è‡ªå·±çš„æ–°ç§å­ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯åœ¨å¤šçº¿ç¨‹ä¸‹äº§ç”Ÿçš„éšæœºæ•°æ˜¯éšæœºçš„ã€‚

Random å‡½æ•°ä½¿ç”¨ä¸€ä¸ªåŸå­å˜é‡è¾¾åˆ°äº†è¿™ä¸ªæ•ˆæœï¼Œåœ¨åˆ›å»º Random å¯¹è±¡æ—¶åˆå§‹åŒ–çš„ç§å­å°±è¢«ä¿å­˜åˆ°äº†ç§å­åŸå­å˜é‡é‡Œé¢ï¼Œä¸‹é¢çœ‹ next() çš„ä»£ç ã€‚

	protected int next(int bits) {  
        long oldseed, nextseed;  
        AtomicLong seed = this.seed;  
        do {  
            // 3.   
            oldseed = seed.get();  
            // 4.   
            nextseed = (oldseed * multiplier + addend) & mask;  
            // 5.    
        } while (!seed.compareAndSet(oldseed, nextseed));  
        // 6.  
        return (int)(nextseed >>> (48 - bits));  
    }

ä»£ç  (3) è·å–å½“å‰åŸå­å˜é‡ç§å­çš„å€¼ã€‚

ä»£ç  (4) æ ¹æ®å½“å‰ç§å­å€¼è®¡ç®—æ–°çš„ç§å­ã€‚

ä»£ç  (5) ä½¿ç”¨ CAS æ“ä½œï¼Œå®ƒä½¿ç”¨æ–°çš„ç§å­å»æ›´æ–°è€çš„ç§å­ï¼Œåœ¨å¤šçº¿ç¨‹ä¸‹å¯èƒ½å¤šä¸ªçº¿ç¨‹éƒ½åŒæ—¶æ‰§è¡Œåˆ°äº†ä»£ç  (3)ï¼Œé‚£ä¹ˆå¯èƒ½å¤šä¸ªçº¿ç¨‹æ‹¿åˆ°çš„å½“å‰ç§å­çš„å€¼æ˜¯åŒä¸€ä¸ªï¼Œç„¶åæ‰§è¡Œæ­¥éª¤ (4) è®¡ç®—çš„æ–°ç§å­ä¹Ÿéƒ½æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯æ­¥éª¤ (5) çš„ CAS æ“ä½œä¼šä¿è¯åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ›´æ–°è€çš„ç§å­ä¸ºæ–°çš„ ï¼Œå¤±è´¥çš„çº¿ç¨‹ä¼šé€šè¿‡å¾ªç¯é‡æ–°è·å–æ›´æ–°åçš„ç§å­ä½œä¸ºå½“å‰ç§å­å»è®¡ç®—è€çš„ç§å­ï¼Œè¿™å°±è§£å†³äº†ä¸Šé¢æåˆ°çš„é—®é¢˜ï¼Œä¿è¯äº†éšæœºæ•°çš„éšæœºæ€§ã€‚

ä»£ç  (6) ä½¿ç”¨å›ºå®šç®—æ³•æ ¹æ®æ–°çš„ç§å­è®¡ç®—éšæœºæ•°ã€‚

æ€»ç»“ï¼šæ¯ä¸ª Random å®ä¾‹é‡Œé¢éƒ½æœ‰ä¸€ä¸ªåŸå­æ€§çš„ç§å­å˜é‡ç”¨æ¥è®°å½•å½“å‰çš„ç§å­å€¼ï¼Œå½“è¦ç”Ÿæˆæ–°çš„éšæœºæ•°æ—¶éœ€è¦æ ¹æ®å½“å‰ç§å­è®¡ç®—æ–°çš„ç§å­å¹¶æ›´æ–°å›åŸå­å˜é‡ã€‚åœ¨å¤šçº¿ç¨‹ä¸‹ä½¿ç”¨å•ä¸ª Random å®ä¾‹ç”Ÿæˆéšæœºæ•°æ—¶ï¼Œå½“å¤šä¸ªçº¿ç¨‹åŒæ—¶è®¡ç®—éšæœºæ•°æ¥è®¡ç®—æ–°çš„ç§å­æ—¶ï¼Œå¤šä¸ªçº¿ç¨‹ä¼šç«äº‰åŒä¸€ä¸ªåŸå­å˜é‡çš„æ›´æ–°æ“ä½œï¼Œç”±äºåŸå­å˜é‡çš„æ›´æ–°æ˜¯ CAS æ“ä½œï¼ŒåŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹ä¼šæˆåŠŸï¼Œæ‰€ä»¥ä¼šé€ æˆå¤§é‡çº¿ç¨‹è¿›è¡Œè‡ªæ—‹é‡è¯•ï¼Œè¿™ä¼šé™ä½å¹¶å‘æ€§èƒ½ã€‚

## 3.2 ThreadLocalRandom

ä½¿ç”¨ `ThreadLocalRandom.current()` æ¥è·å–å½“å‰çº¿ç¨‹çš„éšæœºæ•°ç”Ÿæˆå™¨ã€‚ThreadLocalRandom çš„å®ç°åŸç†å’Œ ThreadLocal ç±»ä¼¼ã€‚æ¯ä¸ªçº¿ç¨‹éƒ½ç»´æŠ¤ä¸€ä¸ªç§å­å˜é‡ï¼Œåˆ™æ¯ä¸ªçº¿ç¨‹ç”Ÿæˆéšæœºæ•°æ—¶éƒ½æ ¹æ®è‡ªå·±è€çš„ç§å­è®¡ç®—æ–°çš„ç§å­ï¼Œå¹¶ä½¿ç”¨æ–°ç§å­æ›´æ–°è€çš„ç§å­ï¼Œå†æ ¹æ®æ–°ç§å­è®¡ç®—éšæœºæ•°ï¼Œå°±ä¸ä¼šå­˜åœ¨ç«äº‰é—®é¢˜äº†ï¼Œè¿™ä¼šå¤§å¤§æé«˜å¹¶å‘æ€§èƒ½ã€‚

![Screen Shot 2021-06-05 at 10.45.02](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-05%20at%2010.45.02.png)

## 3.3 æºç 

![Screen Shot 2021-06-05 at 10.45.40](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-05%20at%2010.45.40.png)

ThreadLocalRandom ç±»ç»§æ‰¿äº† Random ç±»å¹¶é‡å†™äº† nextlnt æ–¹æ³•ï¼Œåœ¨ ThreadLocalRandom ç±»ä¸­å¹¶æ²¡æœ‰ä½¿ç”¨ç»§æ‰¿è‡ª Random ç±»çš„åŸå­æ€§ç§å­å˜é‡ã€‚åœ¨ ThreadLocalRandom ä¸­å¹¶æ²¡æœ‰å­˜æ”¾å…·ä½“çš„ç§å­ï¼Œå…·ä½“çš„ç§å­å­˜æ”¾åœ¨å…·ä½“çš„è°ƒç”¨çº¿ç¨‹çš„ `threadLocalRandomSeed` å˜é‡é‡Œé¢ã€‚ ThreadLocalRandom ç±»ä¼¼äº ThreadLocal ç±»ï¼Œå°±æ˜¯ä¸ªå·¥å…·ç±»ã€‚å½“çº¿ç¨‹è°ƒç”¨ ThreadLocalRandom çš„ current() æ–¹æ³•æ—¶ï¼ŒThreadLocalRandom è´Ÿè´£åˆå§‹åŒ–è°ƒç”¨çº¿ç¨‹çš„ threadLocalRandomSeed å˜é‡ï¼Œä¹Ÿå°±æ˜¯åˆå§‹åŒ–ç§å­ã€‚

å½“è°ƒç”¨ ThreadLocalRandom çš„ nextlnt æ–¹æ³•æ—¶ï¼Œå®é™…ä¸Šæ˜¯è·å–å½“å‰çº¿ç¨‹çš„ `threadLocalRandomSeed` å˜é‡ä½œä¸ºå½“å‰ç§å­æ¥è®¡ç®—æ–°çš„ç§å­ï¼Œç„¶åæ›´æ–°æ–°çš„ç§å­åˆ°å½“å‰çº¿ç¨‹çš„ threadLocalRandomSeed å˜é‡ï¼Œè€Œåå†æ ¹æ®æ–°ç§å­å¹¶ä½¿ç”¨å…·ä½“ç®—æ³•è®¡ç®—éšæœºæ•°ã€‚è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒthreadLocalRandomSeed å˜é‡åªæ˜¯ Thread ç±»é‡Œé¢çš„ä¸€ä¸ªæ™®é€š long å˜é‡ï¼Œå®ƒå¹¶ä¸éœ€è¦æ˜¯åŸå­æ€§å˜é‡ã€‚

å…¶ä¸­ seeder å’Œ probeGenerator æ˜¯ä¸¤ä¸ªåŸå­æ€§å˜é‡ï¼Œåœ¨åˆå§‹åŒ–è°ƒç”¨çº¿ç¨‹çš„ç§å­å’Œæ¢é’ˆå˜é‡æ—¶ä¼šç”¨åˆ°å®ƒä»¬ï¼Œ æ¯ä¸ªçº¿ç¨‹åªä¼šä½¿ç”¨ä¸€æ¬¡ã€‚

å¦å¤–ï¼Œå˜é‡ instance æ˜¯ ThreadLocalRandom çš„ä¸€ä¸ªå®ä¾‹ï¼Œè¯¥å˜é‡æ˜¯ static çš„ã€‚å½“å¤šçº¿ç¨‹é€šè¿‡ ThreadLocalRandom çš„ current æ–¹æ³•è·å– ThreadLocalRandom çš„å®ä¾‹æ—¶ï¼Œ**å…¶å®è·å–çš„æ˜¯åŒä¸€ä¸ªå®ä¾‹ã€‚**ä½†**æ˜¯ç”±äºå…·ä½“çš„ç§å­æ˜¯å­˜æ”¾åœ¨çº¿ç¨‹é‡Œé¢çš„**ï¼Œæ‰€ä»¥åœ¨ ThreadLocaIRandom çš„å®ä¾‹é‡Œé¢åªåŒ…å«ä¸çº¿ç¨‹æ— å…³çš„é€šç”¨ç®—æ³•ï¼Œ æ‰€ä»¥å®ƒæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

### Unsafe æœºåˆ¶

	// Unsafe mechanics  
    private static final sun.misc.Unsafe UNSAFE;  
    private static final long SEED;  
    private static final long PROBE;  
    private static final long SECONDARY;  
    static {  
        try {  
            // è·å– Unsafe å®ä¾‹  
            UNSAFE = sun.misc.Unsafe.getUnsafe();  
            Class<?> tk = Thread.class;  
            /*  
            åˆ†åˆ«è·å– Thread ç±»é‡Œé¢ threadLocalRandomSeedã€threadLocalRandomProbe  
            å’Œ threadLocalRandomSecondarySeed å˜é‡åœ¨ Thread å®ä¾‹é‡Œé¢çš„åç§»é‡  
            */  
            SEED = UNSAFE.objectFieldOffset  
                (tk.getDeclaredField("threadLocalRandomSeed"));  
            PROBE = UNSAFE.objectFieldOffset  
                (tk.getDeclaredField("threadLocalRandomProbe"));  
            SECONDARY = UNSAFE.objectFieldOffset  
                (tk.getDeclaredField("threadLocalRandomSecondarySeed"));  
        } catch (Exception e) {  
            throw new Error(e);  
        }  
    }

### ThreadLocalRandom current() æ–¹æ³•

è¯¥æ–¹æ³•è·å– ThreadLocalRandom å®ä¾‹ï¼Œå¹¶åˆå§‹åŒ–è°ƒç”¨çº¿ç¨‹ä¸­çš„ threadLocalRandomSeed å’Œ threadLocalRandomProbe å˜é‡ã€‚

	static final ThreadLocalRandom instance = new ThreadLocalRandom();  
  
	public static ThreadLocalRandom current() {  
        // 1.  
        if (UNSAFE.getInt(Thread.currentThread(), PROBE) == 0)  
            // 2.  
            localInit();  
        // 3.  
        return instance;  
    }  
  
	static final void localInit() {  
        int p = probeGenerator.addAndGet(PROBE_INCREMENT);  
        int probe = (p == 0) ? 1 : p; // skip 0  
        long seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));  
        Thread t = Thread.currentThread();  
        UNSAFE.putLong(t, SEED, seed);  
        UNSAFE.putInt(t, PROBE, probe);  
    }

åœ¨å¦‚ä¸Šä»£ç  (1) ä¸­ï¼Œå¦‚æœå½“å‰çº¿ç¨‹ä¸­ threadLocalRandomProbe çš„å˜é‡å€¼ä¸º 0ï¼ˆé»˜è®¤æƒ…å†µä¸‹çº¿ç¨‹çš„è¿™ä¸ªå˜é‡å€¼ä¸º 0ï¼‰ï¼Œåˆ™è¯´æ˜å½“å‰çº¿ç¨‹æ˜¯ç¬¬ä¸€æ¬¡è°ƒç”¨ ThreadLocalRandom çš„ current æ–¹æ³•ï¼Œé‚£ä¹ˆå°±éœ€è¦è°ƒç”¨ locallnitæ–¹æ³•è®¡ç®—å½“å‰çº¿ç¨‹çš„åˆå§‹åŒ–ç§å­å˜é‡ï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰ã€‚

ä»£ç  (2) é¦–å…ˆæ ¹æ® probeGenerator è®¡ç®—å½“å‰çº¿ç¨‹ä¸­ threadLocalRandomProbe çš„åˆå§‹åŒ–å€¼ï¼Œç„¶åæ ¹æ® seeder è®¡ç®—å½“å‰çº¿ç¨‹çš„åˆå§‹åŒ–ç§å­ï¼Œè€ŒåæŠŠè¿™ä¸¤ä¸ªå˜é‡è®¾ç½®åˆ°å½“å‰çº¿ç¨‹ã€‚ ä»£ç  (3) è¿”å› ThreadLocalRandom çš„å®ä¾‹ã€‚è¿™ä¸ªæ–¹æ³•æ˜¯é™æ€æ–¹æ³•ï¼Œå¤šä¸ªçº¿ç¨‹è¿”å›çš„æ˜¯åŒä¸€ä¸ª ThreadLocalRandom å®ä¾‹ã€‚

### int nextInt(int bound) æ–¹æ³•

è®¡ç®—å½“å‰çº¿ç¨‹çš„ä¸‹ä¸€ä¸ªéšæœºæ•°ã€‚

	public int nextInt(int bound) {  
        if (bound <= 0)  
            throw new IllegalArgumentException(BadBound);  
        // æ ¹æ®å½“å‰çº¿ç¨‹ä¸­çš„ç§å­è®¡ç®—æ–°ç§å­  
        int r = mix32(nextSeed());  
        // æ ¹æ®æ–°ç§å­å’Œ bound è®¡ç®—éšæœºæ•°  
        int m = bound - 1;  
        if ((bound & m) == 0) // power of two  
            r &= m;  
        else { // reject over-represented candidates  
            for (int u = r >>> 1;  
                 u + m - (r = u % bound) < 0;  
                 u = mix32(nextSeed()) >>> 1)  
                ;  
        }  
        return r;  
    }

å¦‚ä¸Šä»£ç çš„é€»è¾‘æ­¥éª¤ä¸ Random ç›¸ä¼¼ï¼Œé‡ç‚¹çœ‹ nextSeed() æ–¹æ³•ï¼š

	final long nextSeed() {  
        Thread t; long r; // read and update per-thread seed  
        UNSAFE.putLong(t = Thread.currentThread(), SEED,  
                       r = UNSAFE.getLong(t, SEED) + GAMMA);  
        return r;  
    }

é¦–å…ˆä½¿ç”¨ r = UNSAFE.getLong(t, SEED) è·å–å½“å‰çº¿ç¨‹ä¸­ threadLocalRandomSeed å˜é‡çš„å€¼ï¼Œç„¶ååœ¨ç§å­çš„åŸºç¡€ä¸Šç´¯åŠ  GAMMA å€¼ä½œä¸ºæ–°ç§å­ï¼Œè€Œåä½¿ç”¨ UNSAFE çš„ putLong æ–¹æ³•æŠŠæ–°ç§å­æ”¾å…¥å½“å‰çº¿ç¨‹çš„ threadLocalRandomSeed å˜é‡ä¸­ã€‚

# 4. åŸå­æ“ä½œç±»

## 4.1 åŸå­å˜é‡æ“ä½œç±»

`AtomicLong` æ˜¯åŸå­æ€§é€’å¢æˆ–è€…é€’å‡ç±»ï¼Œå…¶å†…éƒ¨ä½¿ç”¨ `Unsafe` æ¥å®ç°ã€‚

public class AtomicLong extends Number implements java.io.Serializable {  
    private static final long serialVersionUID = 1927816293512124184L;  
  
    private static final Unsafe unsafe = Unsafe.getUnsafe();  
    private static final long valueOffset;  
  
    // åˆ¤æ–­ JVM æ˜¯å¦æ”¯æŒ Long ç±»å‹æ— é” CAS  
    static final boolean VM_SUPPORTS_LONG_CAS = VMSupportsCS8();  
    private static native boolean VMSupportsCS8();  
  
    static {  
        try {  
            valueOffset = unsafe.objectFieldOffset  
                (AtomicLong.class.getDeclaredField("value"));  
        } catch (Exception ex) { throw new Error(ex); }  
    }  
  
    private volatile long value;  
  
    public AtomicLong(long initialValue) {  
        value = initialValue;  
    }  
    ...  
}

`value` è¢«å£°æ˜ä¸º `volatile` çš„ï¼Œè¿™æ˜¯ä¸ºäº†åœ¨å¤šçº¿ç¨‹ä¸‹ä¿è¯å†…å­˜å¯è§æ€§ï¼Œ`value` æ˜¯å…·ä½“å­˜æ”¾è®¡æ•°çš„å˜é‡ã€‚

### ä¸»è¦å‡½æ•°

#### é€’å¢å’Œé€’å‡

	public final long getAndIncrement() {  
        return unsafe.getAndAddLong(this, valueOffset, 1L);  
    }  
	public final long getAndDecrement() {  
        return unsafe.getAndAddLong(this, valueOffset, -1L);  
    }  
  
	public final long incrementAndGet() {  
        return unsafe.getAndAddLong(this, valueOffset, 1L) + 1L;  
    }  
    public final long decrementAndGet() {  
        return unsafe.getAndAddLong(this, valueOffset, -1L) - 1L;  
    }

ä¸Šè¿°æ–¹æ³•éƒ½æ˜¯é€šè¿‡è°ƒç”¨ `Unsafe` çš„ `getAndAddLong` æ–¹æ³•å®ç°çš„ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯åŸå­æ€§æ“ä½œã€‚

å…¶ä¸­ `getAndIncrement` åœ¨ JDK7 ä¸­çš„å®ç°é€»è¾‘ä¸ºï¼š

	public final long getAndIncrement() {  
        while (true) {  
            long current = get();  
            long next = current + 1;  
            if (compareAndSet(current, next))  
                return current;  
        }  
    }

JDK8 ä¸­å°†è¿™ä¸ªå¾ªç¯é€»è¾‘å·²ç»è¢« `Unsafe` å†…ç½®äº†ï¼Œæé«˜å¤ç”¨æ€§ã€‚

	// Unsafe  
	public final long getAndAddLong(Object var1, long var2, long var4) {  
        long var6;  
        do {  
            var6 = this.getLongVolatile(var1, var2);  
        } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));  
  
        return var6;  
    }

#### boolean compareAndSet(long expect, long update)

å¦‚æœåŸå­å˜é‡ä¸­çš„ value å€¼ç­‰äº expectï¼Œåˆ™ä½¿ç”¨ update å€¼æ›´æ–°è¯¥å€¼å¹¶è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚

	public final boolean compareAndSet(long expect, long update) {  
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);  
    }

`Unsafe` çš„ `compareAndSwapLong` æ˜¯ä¸ª native æ–¹æ³•ã€‚

AtomicLong è¿™äº›åŸå­æ“ä½œéƒ½ä½¿ç”¨äº† CAS éé˜»å¡ç®—æ³•ï¼Œæ€§èƒ½æ¯” synchronzied ç­‰é˜»å¡ç®—æ³•å¥½ï¼Œä½†æ˜¯åœ¨é«˜å¹¶å‘æƒ…å†µä¸‹è¿˜æ˜¯ä¼šå­˜åœ¨æ€§èƒ½é—®é¢˜ã€‚

## 4.2 JDK 8 æ–°å¢çš„åŸå­æ“ä½œç±» LongAdder

### ç®€å•ä»‹ç»

åœ¨é«˜å¹¶å‘ä¸‹ä½¿ç”¨ `AtomicLong` æ—¶ï¼Œå¤§é‡çº¿ç¨‹ä¼šåŒæ—¶ç«äº‰åŒä¸€ä¸ªåŸå­å˜é‡ã€‚

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-06%20at%2013.40.10.png" alt="Screen Shot 2021-06-06 at 13.40.10" style="zoom:50%;" />

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-06%20at%2013.39.36.png" alt="Screen Shot 2021-06-06 at 13.39.36" style="zoom: 36.6%;" />

ä½¿ç”¨ `LongAdder` æ—¶ï¼Œæ˜¯åœ¨å†…éƒ¨ç»´æŠ¤å¤šä¸ª `Cell` å˜é‡ï¼Œæ¯ä¸ª `Cell` é‡Œé¢æœ‰ä¸€ ä¸ªåˆå§‹å€¼ä¸º 0 çš„ long å‹å˜é‡ ï¼Œè¿™æ ·ï¼Œåœ¨åŒç­‰å¹¶å‘é‡çš„æƒ…å†µä¸‹ï¼Œäº‰å¤ºå•ä¸ªå˜é‡æ›´æ–°æ“ä½œçš„çº¿ç¨‹é‡ä¼šå‡å°‘ã€‚å¦å¤–ï¼Œå¤šä¸ªçº¿ç¨‹åœ¨äº‰å¤ºåŒä¸€ä¸ª `Cell` åŸå­å˜é‡æ—¶å¦‚æœå¤±è´¥äº†ï¼Œå®ƒå¹¶ä¸æ˜¯åœ¨å½“å‰ `Cell` å˜é‡ä¸Šä¸€ç›´è‡ªæ—‹ CAS é‡è¯•ï¼Œè€Œæ˜¯å°è¯•åœ¨å…¶ä»– Cell çš„å˜é‡ä¸Šè¿›è¡Œ CAS å°è¯•ï¼Œè¿™ä¸ªæ”¹å˜å¢åŠ äº†å½“å‰çº¿ç¨‹é‡è¯• CAS æˆåŠŸçš„å¯èƒ½æ€§ã€‚æœ€åï¼Œåœ¨è·å– `LongAdder` å½“å‰å€¼æ—¶ï¼Œ æ˜¯æŠŠæ‰€æœ‰ `Cell` å˜é‡çš„ valueå€¼ç´¯åŠ åå†åŠ ä¸Š `base` è¿”å›çš„ã€‚

`LongAdder` ç»´æŠ¤äº†ä¸€ä¸ªå»¶è¿Ÿåˆå§‹åŒ–çš„åŸå­æ€§æ›´æ–°æ•°ç»„ï¼ˆå› ä¸º `Cells` å ç”¨çš„å†…å­˜æ˜¯ç›¸å¯¹æ¯”è¾ƒå¤§çš„ã€‚é»˜è®¤æƒ…å†µä¸‹ `Cell` æ•°ç»„æ˜¯ nullï¼‰å’Œä¸€ä¸ªåŸºå€¼å˜é‡ `base`ã€‚

å½“ä¸€å¼€å§‹åˆ¤æ–­ `Cell` æ•°ç»„æ˜¯ null å¹¶ä¸”å¹¶å‘çº¿ç¨‹è¾ƒå°‘æ—¶ï¼Œæ‰€æœ‰çš„ç´¯åŠ æ“ä½œéƒ½æ˜¯å¯¹ `base` å˜é‡è¿›è¡Œçš„ã€‚ä¿æŒ `Cell` æ•°ç»„çš„å¤§å°ä¸º 2 çš„ N æ¬¡æ–¹ï¼Œåœ¨åˆå§‹åŒ–æ—¶ `Cell` æ•°ç»„ä¸­çš„ `Cell` å…ƒç´ ä¸ªæ•°ä¸º 2ï¼Œæ•°ç»„é‡Œé¢çš„å˜é‡å®ä½“æ˜¯ `Cell` ç±»å‹ã€‚`Cell` ç±»å‹æ˜¯ `AtomicLong` çš„ä¸€ä¸ªæ”¹è¿›ï¼Œç”¨æ¥å‡å°‘ç¼“å­˜çš„äº‰ç”¨ï¼Œä¹Ÿå°±æ˜¯è§£å†³ä¼ªå…±äº«é—®é¢˜ ã€‚

å¯¹äºå¤§å¤šæ•°å­¤ç«‹çš„å¤šä¸ªåŸå­æ“ä½œè¿›è¡Œå­—èŠ‚å¡«å……æ˜¯æµªè´¹çš„ï¼Œå› ä¸ºåŸå­æ€§æ“ä½œéƒ½æ˜¯æ— è§„å¾‹åœ°åˆ†æ•£åœ¨å†…å­˜ä¸­çš„ï¼ˆä¹Ÿå°±æ˜¯è¯´å¤šä¸ªåŸå­æ€§å˜é‡çš„å†…å­˜åœ°å€æ˜¯ä¸è¿ç»­çš„ï¼‰ï¼Œå¤šä¸ªåŸå­å˜é‡è¢«æ”¾å…¥åŒä¸€ä¸ªç¼“å­˜è¡Œçš„å¯èƒ½æ€§å¾ˆå°ã€‚ä½†æ˜¯åŸå­æ€§æ•°ç»„å…ƒç´ çš„å†…å­˜åœ°å€æ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥æ•°ç»„å†…çš„å¤šä¸ªå…ƒç´ èƒ½ç»å¸¸å…±äº«ç¼“å­˜è¡Œï¼Œå› æ­¤è¿™é‡Œä½¿ç”¨ `@sun.misc.Contended` æ³¨è§£å¯¹ `Cell` ç±»è¿›è¡Œå­—èŠ‚å¡«å……ï¼Œè¿™é˜²æ­¢äº†æ•°ç»„ä¸­å¤šä¸ªå…ƒç´ å…±äº«ä¸€ä¸ªç¼“å­˜è¡Œï¼Œåœ¨æ€§èƒ½ä¸Šæ˜¯ä¸€ ä¸ªæå‡ ã€‚

### æºç 

#### LongAdder ç»“æ„

![Screen Shot 2021-06-06 at 13.46.18](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-06%20at%2013.46.18.png)

`LongAdder` ç±»ç»§æ‰¿è‡ª `Striped64` ç±»ï¼Œåœ¨ `Striped64` å†…éƒ¨ç»´æŠ¤ç€ä¸‰ä¸ªå˜é‡ã€‚

-   `LongAdder` çš„çœŸå®å€¼å…¶å®æ˜¯ `base` çš„å€¼ä¸ `Cell` æ•°ç»„é‡Œé¢æ‰€æœ‰ `Cell` å…ƒç´ ä¸­çš„ `value` å€¼çš„ç´¯åŠ ï¼Œ `base` æ˜¯ä¸ªåŸºç¡€å€¼ï¼Œé»˜è®¤ä¸º 0ã€‚
    
-   `cellsBusy` ç”¨æ¥å®ç°è‡ªæ—‹é”ï¼ŒçŠ¶æ€å€¼åªæœ‰ 0 å’Œ 1ï¼Œå½“åˆ›å»º `Cell` å…ƒç´ ï¼Œ æ‰©å®¹ `Cell` æ•°ç»„æˆ–è€…åˆå§‹åŒ– `Cell` æ•°ç»„æ—¶ï¼Œä½¿ç”¨ CAS æ“ä½œè¯¥å˜é‡æ¥ä¿è¯åŒæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è¿›è¡Œå…¶ä¸­ä¹‹ä¸€çš„æ“ä½œã€‚
    

`Cell` æ„é€ ï¼š

	// Striped64  
	@sun.misc.Contended static final class Cell {  
        volatile long value;  
        Cell(long x) { value = x; }  
        final boolean cas(long cmp, long val) {  
            return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);  
        }  
  
        // Unsafe mechanics  
        private static final sun.misc.Unsafe UNSAFE;  
        private static final long valueOffset;  
        static {  
            try {  
                UNSAFE = sun.misc.Unsafe.getUnsafe();  
                Class<?> ak = Cell.class;  
                valueOffset = UNSAFE.objectFieldOffset  
                    (ak.getDeclaredField("value"));  
            } catch (Exception e) {  
                throw new Error(e);  
            }  
        }  
    }

å¯ä»¥çœ‹åˆ°ï¼Œ `Cell` çš„æ„é€ å¾ˆç®€å•ï¼Œå…¶å†…éƒ¨ç»´æŠ¤ä¸€ä¸ªè¢«å£°æ˜ä¸º `volatile` çš„å˜é‡ï¼Œè¿™é‡Œå£°æ˜ä¸º `volatile` æ˜¯å› ä¸ºçº¿ç¨‹æ“ä½œ `value` å˜é‡æ—¶æ²¡æœ‰ä½¿ç”¨é”ï¼Œ ä¸ºäº†ä¿è¯å˜é‡çš„å†…å­˜å¯è§æ€§è¿™é‡Œå°†å…¶å£°æ˜ä¸º `volatile` çš„ã€‚å¦å¤– cas å‡½æ•°é€šè¿‡ CAS æ“ä½œï¼Œä¿è¯äº†å½“å‰çº¿ç¨‹æ›´æ–°æ—¶è¢«åˆ†é…çš„ `Cell` å…ƒç´ ä¸­ `value` å€¼çš„åŸå­æ€§ã€‚å¦å¤–ï¼Œ`Cell` ç±»ä½¿ç”¨ `@sun.misc.Contended` ä¿®é¥°æ˜¯ä¸ºäº†é¿å…ä¼ªå…±äº«ã€‚

#### long sum()

è¿”å›å½“å‰çš„å€¼ï¼Œç´¯åŠ æ‰€æœ‰ `Cell` å†…éƒ¨çš„ `value` å€¼åå†ç´¯åŠ  `base`ã€‚ä¾‹å¦‚ä¸‹é¢çš„ä»£ç ï¼Œ**ç”±äºè®¡ç®—æ€»å’Œæ—¶æ²¡æœ‰å¯¹ Cell æ•°ç»„è¿›è¡ŒåŠ é”ï¼Œæ‰€ä»¥åœ¨ç´¯åŠ è¿‡ç¨‹ä¸­å¯èƒ½æœ‰å…¶ä»–çº¿ç¨‹å¯¹ Cell ä¸­çš„å€¼è¿›è¡Œäº†ä¿®æ”¹ï¼Œä¹Ÿæœ‰å¯èƒ½å¯¹æ•°ç»„è¿›è¡Œäº†æ‰©å®¹ï¼Œæ‰€ä»¥ `sum` è¿”å›çš„å€¼å¹¶ä¸æ˜¯éå¸¸ç²¾ç¡®çš„**ï¼Œå…¶è¿”å›å€¼å¹¶ä¸æ˜¯ä¸€ä¸ªè°ƒç”¨ `sum` æ–¹æ³•æ—¶çš„åŸå­å¿«ç…§å€¼ ã€‚

	public long sum() {  
        Cell[] as = cells; Cell a;  
        long sum = base;  
        if (as != null) {  
            for (int i = 0; i < as.length; ++i) {  
                if ((a = as[i]) != null)  
                    sum += a.value;  
            }  
        }  
        return sum;  
    }

#### void reset()

é‡ç½®æ“ä½œï¼ŒæŠŠ `base` ç½®ä¸º 0ï¼Œå¦‚æœ `Cell` æ•°ç»„æœ‰å…ƒç´ ï¼Œåˆ™å…ƒç´ å€¼è¢«é‡ç½®ä¸º 0ã€‚

	public void reset() {  
        Cell[] as = cells; Cell a;  
        base = 0L;  
        if (as != null) {  
            for (int i = 0; i < as.length; ++i) {  
                if ((a = as[i]) != null)  
                    a.value = 0L;  
            }  
        }  
    }

#### long sumThenReset()

ç­‰äº `sum()` å’Œ `rest()` ä¸€èµ·è¿›è¡Œã€‚å½“å¤šçº¿ç¨‹è°ƒç”¨è¯¥æ–¹æ³•æ—¶ä¼šæœ‰é—®é¢˜ï¼Œæ¯”å¦‚è€ƒè™‘ç¬¬ä¸€ä¸ªè°ƒç”¨çº¿ç¨‹æ¸…ç©º `Cell` çš„å€¼ï¼Œåˆ™åä¸€ä¸ªçº¿ç¨‹è°ƒç”¨æ—¶ç´¯åŠ çš„éƒ½æ˜¯ 0 å€¼ã€‚

	public long sumThenReset() {  
        Cell[] as = cells; Cell a;  
        long sum = base;  
        base = 0L;  
        if (as != null) {  
            for (int i = 0; i < as.length; ++i) {  
                if ((a = as[i]) != null) {  
                    sum += a.value;  
                    a.value = 0L;  
                }  
            }  
        }  
        return sum;  
    }

#### long value()

	public long longValue() {  
        return sum();  
    }

#### void add(long x)

	public void add(long x) {  
        Cell[] as; long b, v; int m; Cell a;  
        if ((as = cells) != null || !casBase(b = base, b + x)) {	// 1.  
            boolean uncontended = true;  
            if (as == null || (m = as.length - 1) < 0 ||			// 2.  
                (a = as[getProbe() & m]) == null ||					// 3.  
                !(uncontended = a.cas(v = a.value, v + x)))			// 4.  
                  
                longAccumulate(x, null, uncontended);				// 5.  
        }  
    }  
  
	final boolean casBase(long cmp, long val) {  
        return UNSAFE.compareAndSwapLong(this, BASE, cmp, val);  
    }

ä»£ç  (1) é¦–å…ˆçœ‹ `cells` æ˜¯å¦ä¸º nullï¼Œå¦‚æœä¸º null åˆ™å½“å‰åœ¨åŸºç¡€å˜é‡ `base` ä¸Šè¿›è¡Œç´¯åŠ ï¼Œ è¿™æ—¶å€™å°±ç±»ä¼¼ `AtomicLong` çš„æ“ä½œã€‚

å¦‚æœ `cells` ä¸ä¸º null æˆ–è€…çº¿ç¨‹æ‰§è¡Œä»£ç  (1) çš„ CAS æ“ä½œå¤±è´¥äº†ï¼Œåˆ™ä¼šå»æ‰§è¡Œä»£ç  (2)ã€‚

ä»£ç  (2) (3) å†³å®šå½“å‰çº¿ç¨‹åº”è¯¥è®¿é—® `cells` æ•°ç»„é‡Œé¢çš„å“ªä¸€ä¸ª `Cell` å…ƒç´ ã€‚

å¦‚æœå½“å‰çº¿ç¨‹æ˜ å°„çš„å…ƒç´ å­˜åœ¨åˆ™æ‰§è¡Œä»£ç  (4)ï¼Œä½¿ç”¨ CAS æ“ä½œå»æ›´æ–°åˆ†é…çš„ Cell å…ƒç´ çš„ value å€¼ï¼Œå¦‚æœå½“å‰çº¿ç¨‹æ˜ å°„çš„å…ƒç´ ä¸å­˜åœ¨æˆ–è€…å­˜åœ¨ä½†æ˜¯ CAS æ“ä½œå¤±è´¥åˆ™æ‰§è¡Œä»£ç  (5)ã€‚

å…¶å®å°†ä»£ç  (2) (3) (4) åˆèµ·æ¥çœ‹å°±æ˜¯è·å–å½“å‰çº¿ç¨‹åº”è¯¥è®¿é—®çš„ cells æ•°ç»„çš„ Cell å…ƒç´ ï¼Œç„¶åè¿›è¡Œ CAS æ›´æ–°æ“ä½œï¼Œåªæ˜¯åœ¨è·å–æœŸé—´å¦‚æœæœ‰äº›æ¡ä»¶ä¸æ»¡è¶³åˆ™ä¼šè·³è½¬åˆ°ä»£ç  (5) æ‰§è¡Œã€‚

å¦å¤–å½“å‰çº¿ç¨‹åº”è¯¥è®¿é—® cells æ•°ç»„çš„å“ªä¸€ä¸ª Cell å…ƒç´ æ˜¯é€šè¿‡ `getProbe() & m` è¿›è¡Œè®¡ç®—çš„ï¼Œå…¶ä¸­ m æ˜¯å½“å‰ cells æ•°ç»„å…ƒç´ ä¸ªæ•° -1ï¼ŒgetProbe() åˆ™ç”¨äºè·å–å½“å‰çº¿ç¨‹ä¸­å˜é‡ `threadLocalRandomProbe` çš„å€¼ï¼Œè¿™ä¸ªå€¼ä¸€å¼€å§‹ä¸º 0ï¼Œåœ¨ä»£ç  (5) é‡Œé¢ä¼šå¯¹å…¶è¿›è¡Œåˆå§‹åŒ–ã€‚å¹¶ä¸”å½“å‰çº¿ç¨‹é€šè¿‡åˆ†é…çš„ Cell å…ƒç´ çš„ cas å‡½æ•°æ¥ä¿è¯å¯¹ Cell å…ƒç´  value å€¼æ›´æ–°çš„åŸå­æ€§ã€‚

> è¿™é‡Œå°±èƒ½è¯´æ˜ä¸ºä»€ä¹ˆå‰é¢è¯´ â€œ `Cell` æ•°ç»„æ˜¯ null å¹¶ä¸”å¹¶å‘çº¿ç¨‹è¾ƒå°‘æ—¶ï¼Œæ‰€æœ‰çš„ç´¯åŠ æ“ä½œéƒ½æ˜¯å¯¹ `base` å˜é‡è¿›è¡Œçš„â€ã€‚å› ä¸ºä»£ç  (1) å¯çŸ¥ï¼Œå¦‚æœå¹¶å‘é‡å°‘ï¼ŒcasBase å¯èƒ½æ¯æ¬¡éƒ½ä¼šç›´æ¥æˆåŠŸï¼Œè¿™æ ·æœ‰ä¼šå¯¼è‡´ `cells` ä¸€ç›´ä¸ä¼šè¢«åˆå§‹åŒ–ã€‚

#### void longAccumulate(long x, LongBinaryOperation fn, boolean wasUncontended)`

	final void longAccumulate(long x, LongBinaryOperator fn,  
                              boolean wasUncontended) {  
        // (6) åˆå§‹åŒ–å½“å‰çº¿ç¨‹å˜é‡ threadLocalRandomProbe çš„å€¼  
        int h;  
        if ((h = getProbe()) == 0) {  
            ThreadLocalRandom.current(); // force initialization  
            h = getProbe();  
            wasUncontended = true;  
        }  
        boolean collide = false;                // True if last slot nonempty  
        for (;;) {  
            Cell[] as; Cell a; int n; long v;  
            if ((as = cells) != null && (n = as.length) > 0) {		// (7)  
                if ((a = as[(n - 1) & h]) == null) {				// (8)  
                    if (cellsBusy == 0) {       // Try to attach new Cell  
                        Cell r = new Cell(x);   // Optimistically create  
                        if (cellsBusy == 0 && casCellsBusy()) {  
                            boolean created = false;  
                            try {               // Recheck under lock  
                                Cell[] rs; int m, j;  
                                if ((rs = cells) != null &&  
                                    (m = rs.length) > 0 &&  
                                    rs[j = (m - 1) & h] == null) {  
                                    rs[j] = r;  
                                    created = true;  
                                }  
                            } finally {  
                                cellsBusy = 0;  
                            }  
                            if (created)  
                                break;  
                            continue;           // Slot is now non-empty  
                        }  
                    }  
                    collide = false;  
                }  
                else if (!wasUncontended)       // CAS already known to fail  
                    wasUncontended = true;      // Continue after rehash  
                  
                // (9) å½“å‰ Cell å­˜åœ¨ï¼Œåˆ™æ‰§è¡Œ CAS è®¾ç½®  
                else if (a.cas(v = a.value, ((fn == null) ? v + x :  
                                             fn.applyAsLong(v, x))))  
                    break;  
                  
                // (10) å½“å‰ Cell æ•°ç»„ä¸ªæ•°å¤§äº CPU ä¸ªæ•°  
                else if (n >= NCPU || cells != as)  
                    collide = false;            // At max size or stale  
                  
                // (11) æ˜¯å¦æœ‰å†²çª  
                else if (!collide)  
                    collide = true;  
                  
                // (12) å¦‚æœå½“å‰å…ƒç´ ä¸ªæ•°æ²¡æœ‰è¾¾åˆ° CPU ä¸ªæ•°å¹¶ä¸”æœ‰å†²çªåˆ™æ‰©å®¹  
                else if (cellsBusy == 0 && casCellsBusy()) {  
                    try {  
                        // ï¼ˆ12.1ï¼‰  
                        if (cells == as) {      // Expand table unless stale  
                            Cell[] rs = new Cell[n << 1];  
                            for (int i = 0; i < n; ++i)  
                                rs[i] = as[i];  
                            cells = rs;  
                        }  
                    } finally {  
                        // ï¼ˆ12.2ï¼‰  
                        cellsBusy = 0;  
                    }  
                    // (12.3)  
                    collide = false;  
                    continue;                   // Retry with expanded table  
                }  
                // (13) ä¸ºäº†èƒ½å¤Ÿæ‰¾åˆ°ä¸€ä¸ªç©ºé—²çš„ Cellï¼Œ  
                // é‡æ–°è®¡ç®— hash å€¼ï¼Œxorshift ç®—æ³•ç”Ÿæˆéšæœºæ•°  
                h = advanceProbe(h);  
            }  
              
            // (14) åˆå§‹åŒ– Cell æ•°ç»„  
            else if (cellsBusy == 0 && cells == as && casCellsBusy()) {  
                boolean init = false;  
                try {                           // Initialize table  
                    if (cells == as) {  
                        // 14.1  
                        Cell[] rs = new Cell[2];  
                        // 14.2  
                        rs[h & 1] = new Cell(x);  
                        cells = rs;  
                        init = true;  
                    }  
                } finally {  
                    // 14.3  
                    cellsBusy = 0;  
                }  
                if (init)  
                    break;  
            }  
            else if (casBase(v = base, ((fn == null) ? v + x :  
                                        fn.applyAsLong(v, x))))  
                break;                          // Fall back on using base  
        }  
    }

å½“æ¯ä¸ªçº¿ç¨‹ç¬¬ ä¸€æ¬¡ æ‰§è¡Œåˆ°ä»£ç  (6) æ—¶ï¼Œä¼šåˆå§‹åŒ–å½“å‰çº¿ç¨‹å˜é‡ `threadLocalRandomProbe` çš„å€¼ï¼Œä¸Šé¢ä¹Ÿè¯´äº†ï¼Œè¿™ä¸ªå˜é‡åœ¨è®¡ç®—å½“å‰çº¿ç¨‹åº”è¯¥è¢«åˆ†é…åˆ° `cells` æ•°ç»„çš„å“ªä¸€ä¸ª `Cell` å…ƒç´ æ—¶ä¼šç”¨åˆ°ã€‚

`cells` æ•°ç»„çš„åˆå§‹åŒ–ï¼šåœ¨ä»£ç  (14) ä¸­è¿›è¡Œï¼Œå…¶ä¸­ `cellsBusy` æ˜¯ä¸€ä¸ªæ ‡ç¤ºï¼Œä¸º 0 è¯´æ˜å½“å‰ `cells` æ•°ç»„æ²¡æœ‰åœ¨è¢«åˆå§‹åŒ–æˆ–è€…æ‰©å®¹ï¼Œä¹Ÿæ²¡æœ‰åœ¨æ–°å»º `Cell` å…ƒç´ ï¼Œä¸º 1 åˆ™è¯´æ˜ `cells` æ•°ç»„åœ¨è¢«åˆå§‹åŒ–æˆ–è€…æ‰©å®¹ï¼Œæˆ–è€…å½“å‰åœ¨åˆ›å»ºæ–°çš„ `Cell` å…ƒç´ ï¼Œé€šè¿‡ CAS æ“ä½œæ¥è¿›è¡Œ 0 æˆ– 1 çŠ¶æ€çš„åˆ‡æ¢ï¼Œè¿™é‡Œä½¿ç”¨ `casCellsBusy` å‡½æ•°ã€‚ä»£ç  (14.1) åˆå§‹åŒ– `cells` æ•°ç»„å…ƒç´ ä¸ªæ•°ä¸º 2ï¼Œç„¶åä½¿ç”¨ `h&1` è®¡ç®—å½“å‰çº¿ç¨‹åº”è¯¥è®¿é—® `cell` æ•°ç»„çš„å“ªä¸ªä½ç½®ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨å½“å‰çº¿ç¨‹çš„ `threadLocalRandomProbeå˜é‡å€¼ & (cellsæ•°ç»„å…ƒç´ ä¸ªæ•°-1)`ï¼Œç„¶åæ ‡ç¤º cells æ•°ç»„å·²ç»è¢«åˆå§‹åŒ–ï¼Œæœ€åä»£ç  (14.3) é‡ç½®äº† `cellsBusy` æ ‡è®°ã€‚æ˜¾ç„¶è¿™é‡Œæ²¡æœ‰ä½¿ç”¨ CAS æ“ä½œï¼Œå´æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ŒåŸå› æ˜¯ `cellsBusy` æ˜¯ `volatile` ç±»å‹çš„ï¼Œè¿™ä¿è¯äº†å˜é‡çš„å†…å­˜å¯è§æ€§ï¼Œå¦å¤–æ­¤æ—¶å…¶ä»–åœ°æ–¹çš„ä»£ç æ²¡æœ‰æœºä¼šä¿®æ”¹ `cellsBusy` çš„å€¼ã€‚åœ¨è¿™é‡Œåˆå§‹åŒ–çš„ `cells` æ•°ç»„é‡Œé¢çš„ä¸¤ä¸ªå…ƒç´ çš„å€¼ç›®å‰è¿˜æ˜¯ nullã€‚

`cells` æ•°ç»„çš„æ‰©å®¹ï¼šåœ¨ä»£ç  (12) ä¸­è¿›è¡Œï¼Œå¯¹ `cells` æ‰©å®¹æ˜¯æœ‰æ¡ä»¶çš„ï¼Œä¹Ÿå°±æ˜¯ä»£ç  (10) (11) çš„æ¡ä»¶éƒ½ä¸æ»¡è¶³çš„æ—¶å€™ã€‚å…·ä½“å°±æ˜¯å½“å‰ cells çš„å…ƒç´ ä¸ªæ•°å°äºå½“å‰æœºå™¨ CPU ä¸ªæ•°å¹¶ä¸”å½“å‰å¤šä¸ªçº¿ç¨‹è®¿é—®äº† cells ä¸­åŒä¸€ä¸ªå…ƒç´ ä»è€Œå¯¼è‡´å†²çªä½¿å…¶ä¸­ ä¸€ä¸ªçº¿ç¨‹ CAS å¤±è´¥æ—¶æ‰ä¼šè¿›è¡Œæ‰©å®¹æ“ä½œã€‚è¿™é‡Œä¸ºä½•è¦æ¶‰åŠ CPU ä¸ªæ•°å‘¢ï¼Ÿå…¶å®åœ¨åŸºç¡€ç¯‡ä¸­å·±ç»è®²è¿‡ï¼Œåªæœ‰å½“æ¯ä¸ª CPU éƒ½è¿è¡Œä¸€ä¸ªçº¿ç¨‹æ—¶æ‰ä¼šä½¿å¤šçº¿ç¨‹çš„æ•ˆæœæœ€ä½³ï¼Œä¹Ÿå°±æ˜¯å½“ `cells` æ•°ç»„å…ƒç´ ä¸ªæ•°ä¸ CPU ä¸ªæ•°ä¸€è‡´æ—¶ï¼Œæ¯ä¸ª Cell éƒ½ä½¿ç”¨ä¸€ä¸ª CPU è¿›è¡Œå¤„ç†ï¼Œè¿™æ—¶æ€§èƒ½æ‰æ˜¯æœ€ä½³çš„ã€‚ä»£ç  (12) ä¸­çš„æ‰©å®¹æ“ ä½œä¹Ÿæ˜¯å…ˆé€šè¿‡ CAS è®¾ç½® `cellsBusy` ä¸º 1ï¼Œç„¶åæ‰èƒ½è¿›è¡Œæ‰©å®¹ã€‚å‡è®¾ CAS æˆåŠŸåˆ™æ‰§è¡Œä»£ç  (12.1) å°†å®¹é‡æ‰©å……ä¸ºä¹‹å‰çš„ 2 å€ï¼Œå¹¶å¤åˆ¶ `Cell` å…ƒç´ åˆ°æ‰©å®¹åæ•°ç»„ã€‚å¦å¤–ï¼Œæ‰©å®¹å `cells` æ•°ç»„é‡Œé¢é™¤äº†åŒ…å«å¤åˆ¶è¿‡æ¥çš„å…ƒç´ å¤–ï¼Œè¿˜åŒ…å«å…¶ä»–æ–°å…ƒç´ ï¼Œè¿™äº›å…ƒç´ çš„å€¼ç›®å‰è¿˜æ˜¯ nullã€‚

åœ¨ä»£ç  (7)(8) ä¸­ï¼Œå½“å‰çº¿ç¨‹è°ƒç”¨ `add` æ–¹æ³•å¹¶æ ¹æ®å½“å‰çº¿ç¨‹çš„éšæœºæ•° `threadLocalRandomProbe` å’Œ `cells` å…ƒç´ ä¸ªæ•°è®¡ç®—è¦è®¿é—®çš„ `Cell` å…ƒç´ ä¸‹æ ‡ï¼Œç„¶åå¦‚æœå‘ç°å¯¹åº”ä¸‹æ ‡å…ƒç´ çš„å€¼ä¸º nullï¼Œåˆ™æ–°å¢ä¸€ä¸ª `Cell` å…ƒç´ åˆ° `cells` æ•°ç»„ï¼Œå¹¶ä¸”åœ¨å°†å…¶æ·»åŠ åˆ° `cells` æ•°ç»„ä¹‹å‰è¦ç«äº‰è®¾ç½® `cellsBusy` ä¸º 1ã€‚

ä»£ç  (13) å¯¹ CAS å¤±è´¥çš„çº¿ç¨‹é‡æ–°è®¡ç®—å½“å‰çº¿ç¨‹çš„éšæœºå€¼ `threadLocalRandomProbe`, ä»¥å‡å°‘ä¸‹æ¬¡è®¿é—® `cells`å…ƒç´ æ—¶çš„å†²çªæœºä¼šã€‚

## 4.3 LongAccumulator ç±»

	public LongAccumulator(LongBinaryOperator accumulatorFunction,  
                           long identity) {  
        this.function = accumulatorFunction;  
        base = this.identity = identity;  
    }  
  
  
    @FunctionalInterface  
    public interface LongBinaryOperator {  
        long applyAsLong(long left, long right);  
    }

`accumulatorFunction`æ˜¯ä¸€ä¸ªåŒç›®è¿ç®—å™¨æ¥å£ï¼Œå…¶æ ¹æ®è¾“å…¥çš„ä¸¤ä¸ªå‚æ•°è¿”å›ä¸€ä¸ªè®¡ç®—å€¼ï¼Œ`identity` åˆ™æ˜¯ `LongAccumulator` ç´¯åŠ å™¨çš„åˆå§‹å€¼ã€‚

`LongAdder` ç±»æ—¶ `LongAccumulator` ç±»çš„ä¸€ä¸ªç‰¹ä¾‹ï¼Œåœ¨äºå‰è€…å›ºå®šäº†åªèƒ½è¿›è¡Œé€’å¢ã€‚è°ƒç”¨ `LongAdder` å°±ç›¸å½“äºï¼š

	LongAdder adder = new LongAdder();  
  
	LongAccumulator accumulator = new LongAccumulator(new LongBinaryOperator() {  
            @Override  
            public long applyAsLong(long left, long right) {  
                return left + right;  
            }  
        }, 0);

`LongAccumulator` ç›¸æ¯”äº `LongAdder`ï¼Œå¯ä»¥ä¸ºç´¯åŠ å™¨æä¾›é 0çš„åˆå§‹å€¼ï¼Œåè€…åªèƒ½æä¾›é»˜è®¤çš„ 0 å€¼ ã€‚ å¦å¤–ï¼Œå‰è€…è¿˜å¯ä»¥æŒ‡å®šç´¯åŠ è§„åˆ™ï¼Œæ¯”å¦‚ä¸è¿›è¡Œç´¯åŠ è€Œè¿›è¡Œç›¸ä¹˜ï¼Œåªéœ€è¦åœ¨æ„é€  LongAccumulator æ—¶ä¼ å…¥è‡ªå®šä¹‰çš„åŒç›®è¿ç®—å™¨å³å¯ï¼Œåè€…åˆ™å†…ç½®ç´¯åŠ çš„è§„åˆ™ã€‚

ä»ä¸‹é¢ä»£ç æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œ LongAccumulatorç›¸æ¯”äº LongAdderçš„ä¸åŒåœ¨äºï¼Œåœ¨è°ƒç”¨ casBase æ—¶åè€…ä¼ é€’çš„æ˜¯ b+xï¼Œå‰è€…åˆ™ä½¿ç”¨äº† r = function.applyAsLong(b = base, x) æ¥è®¡ç®—ã€‚

	// LongAdder  
	public void add(long x) {  
        Cell[] as; long b, v; int m; Cell a;  
        if ((as = cells) != null || !casBase(b = base, b + x)) {	  
            boolean uncontended = true;  
            if (as == null || (m = as.length - 1) < 0 ||			  
                (a = as[getProbe() & m]) == null ||					  
                !(uncontended = a.cas(v = a.value, v + x)))			  
                  
                longAccumulate(x, null, uncontended);				  
        }  
    }  
  
  
	// LongAccumulator  
	public void accumulate(long x) {  
        Cell[] as; long b, v, r; int m; Cell a;  
        if ((as = cells) != null ||  
            (r = function.applyAsLong(b = base, x)) != b && !casBase(b, r)) {  
            boolean uncontended = true;  
            if (as == null || (m = as.length - 1) < 0 ||  
                (a = as[getProbe() & m]) == null ||  
                !(uncontended =  
                  (r = function.applyAsLong(v = a.value, x)) == v ||  
                  a.cas(v, r)))  
                longAccumulate(x, function, uncontended);  
        }  
    }

å¦å¤–ï¼Œå‰è€…åœ¨è°ƒç”¨ `longAccumulate` æ—¶ä¼ é€’çš„æ˜¯ `function`ï¼Œè€Œåè€…æ˜¯ `null`ã€‚ä»ä¸‹é¢çš„ä»£ç å¯çŸ¥ï¼Œå½“ fnä¸º `null` æ—¶å°±ä½¿ç”¨ v+x åŠ æ³•è¿ç®—ï¼Œè¿™æ—¶å€™å°±ç­‰ä»·äº `LongAdder`ï¼Œå½“ fnä¸ä¸º null æ—¶åˆ™ä½¿ç”¨ä¼ é€’çš„ fn å‡½æ•°è®¡ç®—ã€‚

else if(casBase(v = base, ((fn==null) ? v+x : fn.applyAsLong(v, x))))  
		break; // Fall back on using base

# 5. å¹¶å‘ List

## 5.1 ä»‹ç»

å¹¶å‘åŒ…ä¸­çš„å¹¶å‘ List åªæœ‰ `CopyOnWriteArrayList`ï¼Œè¿™æ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„ `ArrayList`ï¼Œå¯¹å…¶è¿›è¡Œçš„ä¿®æ”¹æ“ä½œéƒ½æ˜¯åœ¨åº•å±‚çš„ä¸€ä¸ªå¤åˆ¶çš„æ•°ç»„ï¼ˆå¿«ç…§ï¼‰ä¸Šè¿›è¡Œçš„ ï¼Œä¹Ÿå°±æ˜¯ä½¿ç”¨äº†å†™æ—¶å¤åˆ¶ç­–ç•¥ã€‚

ç±»å›¾ï¼š

![Screen Shot 2021-06-11 at 22.48.23](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-11%20at%2022.48.23.png)

æ¯ä¸ª `CopyOnWriteArrayList` å¯¹è±¡é‡Œé¢æœ‰ä¸€ä¸ª `array` æ•°ç»„å¯¹è±¡ç”¨æ¥å­˜æ”¾å…·ä½“å…ƒç´ ï¼Œ `ReentrantLock` ç‹¬å é”å¯¹è±¡ç”¨æ¥ä¿è¯åŒæ—¶åªæœ‰ä»¥ä¸ªçº¿ç¨‹ å¯¹ `array` è¿›è¡Œä¿®æ”¹ã€‚

## 5.2 ä¸»è¦æ–¹æ³•

### åˆå§‹åŒ–

ä¸»è¦æ˜¯åˆå§‹åŒ–å†…éƒ¨å˜é‡ arrayã€‚

    private transient volatile Object[] array;  
  
	final void setArray(Object[] a) {  
        array = a;  
    }  
  
	public CopyOnWriteArrayList() {  
        setArray(new Object[0]);  
    }  
  
    public CopyOnWriteArrayList(E[] toCopyIn) {  
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));  
    }  
  
	public CopyOnWriteArrayList(Collection<? extends E> c) {  
        Object[] elements;  
        if (c.getClass() == CopyOnWriteArrayList.class)  
            elements = ((CopyOnWriteArrayList<?>)c).getArray();  
        else {  
            elements = c.toArray();  
            // c.toArray might (incorrectly) not return Object[] (see 6260652)  
            if (elements.getClass() != Object[].class)  
                elements = Arrays.copyOf(elements,   
                                         elements.length, Object[].class);  
        }  
        setArray(elements);  
    }

### æ·»åŠ å…ƒç´ 

æ·»åŠ å…ƒç´ æœ‰ `add(E e)`ã€`add(int index, E element)`ã€`addIfAbsent(E e)` å’Œ `addAllAbsent(Collection<? extends E> c)` ç­‰ã€‚

	public boolean add(E e) {  
        // è·å–ç‹¬å é”  
        final ReentrantLock lock = this.lock;  
        lock.lock();  
        try {  
            // è·å– array  
            Object[] elements = getArray();  
            // å¤åˆ¶ array åˆ°æ–°æ•°ç»„ï¼Œå¹¶æ·»åŠ æ–°å…ƒç´   
            int len = elements.length;  
            Object[] newElements = Arrays.copyOf(elements, len + 1);  
            newElements[len] = e;  
              
            // ç”¨æ–°æ•°ç»„æ›¿æ¢ array  
            setArray(newElements);  
            return true;  
        } finally {  
            lock.unlock();  
        }  
    }

### è·å–å…ƒç´ 

	public E get(int index) {  
        return get(getArray(), index);  
    }  
  
	final Object[] getArray() {  
        return array;  
    }  
  
	private E get(Object[] a, int index) {  
        return (E) a[index];  
    }

çº¿ç¨‹ x åœ¨è°ƒç”¨ get æ–¹æ³•çš„æ—¶å€™åˆ†ä¸ºä¸¤æ­¥ï¼š

1.  è·å– array
    
2.  è·å–å¯¹åº”ä¸‹æ ‡çš„å…ƒç´ 
    

ä½†æ²¡æœ‰åŠ é”ã€‚å¦‚æœ x åœ¨ç¬¬ä¸€æ­¥å’Œç¬¬äºŒæ­¥çš„ä¸­é—´ï¼Œæœ‰ä¸ªçº¿ç¨‹ y è°ƒç”¨äº† remove æ–¹æ³•ï¼Œæ­£å¥½åˆ é™¤äº† x è¦ get çš„å…ƒç´ ï¼Œä½†ä¸ä¼šå½±å“åˆ° x è·å–ã€‚å› ä¸º remove å’Œ add ä¸€æ ·ï¼Œå…ˆè·å–ç‹¬å é”ï¼Œç„¶åå¤åˆ¶ä¸€ä»½ arrayï¼Œåœ¨å¤åˆ¶çš„æ•°ç»„é‡Œåˆ é™¤äº† x è¦è®¿é—®å…ƒç´ çš„å¯¹åº”å…ƒç´ ï¼Œå†å°† array æŒ‡å‘å¤åˆ¶çš„æ•°ç»„ã€‚è€Œè¿™æ—¶å€™ array ä¹‹å‰æŒ‡å‘çš„æ•°ç»„å¼•ç”¨è®¡æ•°ä¸º 1ï¼Œå› ä¸ºçº¿ç¨‹ x è¿˜åœ¨ä½¿ç”¨å®ƒï¼Œæ‰€ä»¥ä¸å½±å“ x çš„è¯»ã€‚

![Screen Shot 2021-06-11 at 00.04.14](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-11%20at%2000.04.14.png)

æ‰€ä»¥ï¼Œè™½ç„¶çº¿ç¨‹ y å·²ç»åˆ é™¤äº† index å¤„çš„å…ƒç´ ï¼Œä½†æ˜¯çº¿ç¨‹ x çš„ç¬¬äºŒæ­¥è¿˜æ˜¯ä¼šè¿”å› index å¤„çš„å…ƒç´ ï¼Œè¿™å…¶å®å°±æ˜¯**å†™æ—¶å¤åˆ¶ç­–ç•¥äº§ç”Ÿçš„å¼±ä¸€è‡´æ€§é—®é¢˜**ã€‚

### ä¿®æ”¹æŒ‡å®šå…ƒç´ 

	public E set(int index, E element) {  
        final ReentrantLock lock = this.lock;  
        lock.lock();  
        try {  
            Object[] elements = getArray();  
            E oldValue = get(elements, index);  
  
            if (oldValue != element) {  
                int len = elements.length;  
                Object[] newElements = Arrays.copyOf(elements, len);  
                newElements[index] = element;  
                setArray(newElements);  
            } else {  
                // Not quite a no-op; ensures volatile write semantics  
                setArray(elements);  
            }  
            return oldValue;  
        } finally {  
            lock.unlock();  
        }  
    }

æ³¨æ„ï¼Œå¦‚æœæŒ‡å®šä½ç½®å…ƒç´ å’Œæ–°å€¼ä¸€æ ·ï¼Œä¸ºäº†ä¿è¯ volatile è¯­ä¹‰ï¼Œè¿˜æ˜¯éœ€è¦é‡æ–°è®¾ç½® arrayï¼Œè™½ç„¶ array å¹¶æ²¡æœ‰æ”¹å˜ã€‚

### åˆ é™¤å…ƒç´ 

	public E remove(int index) {  
        final ReentrantLock lock = this.lock;  
        lock.lock();  
        try {  
            Object[] elements = getArray();  
            int len = elements.length;  
            E oldValue = get(elements, index);  
            int numMoved = len - index - 1;  
            if (numMoved == 0)  
                setArray(Arrays.copyOf(elements, len - 1));  
            else {  
                Object[] newElements = new Object[len - 1];  
                System.arraycopy(elements, 0, newElements, 0, index);  
                System.arraycopy(elements, index + 1, newElements, index,  
                                 numMoved);  
                setArray(newElements);  
            }  
            return oldValue;  
        } finally {  
            lock.unlock();  
        }  
    }

### å¼±ä¸€è‡´æ€§çš„è¿­ä»£å™¨

	public Iterator<E> iterator() {  
        return new COWIterator<E>(getArray(), 0);  
    }  
  
	static final class COWIterator<E> implements ListIterator<E> {  
        private final Object[] snapshot;  
        private int cursor;  
  
        private COWIterator(Object[] elements, int initialCursor) {  
            cursor = initialCursor;  
            snapshot = elements;  
        }  
  
        public boolean hasNext() {  
            return cursor < snapshot.length;  
        }  
  
        public E next() {  
            if (! hasNext())  
                throw new NoSuchElementException();  
            return (E) snapshot[cursor++];  
        }  
    }

`snapshot` å˜é‡ä¿å­˜äº†å½“å‰ list çš„å†…å®¹ï¼Œè™½ç„¶æ˜¯æŒ‡é’ˆä¼ é€’çš„å¼•ç”¨ï¼Œä½† snapshot å¯ä»¥æ˜¯ list çš„å‰¯æœ¬ã€‚

-   å¦‚æœè¿­ä»£å™¨åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œæ²¡æœ‰å…¶ä»–çº¿ç¨‹å¯¹ list è¿›è¡Œå¢åˆ æ”¹ï¼Œé‚£ä¹ˆ snapshot æœ¬èº«å°±æ˜¯ list çš„ arrayã€‚
    
-   å¦‚æœæœ‰å…¶ä»–çº¿ç¨‹è¿›è¡Œäº†å¢åˆ æ”¹ï¼Œé‚£ä¹ˆ snapshot å°±æ˜¯å¿«ç…§äº†ã€‚å› ä¸ºå¢åˆ æ”¹ä¹‹å list çš„ array è¢«æ–°æ•°ç»„æ›¿æ¢äº†ï¼Œä½†è¿™æ—¶å€™è€æ•°ç»„è¢« snapshot å¼•ç”¨ã€‚è¿™ä¹Ÿè¯´æ˜è·å–è¿­ä»£å™¨å¹¶ä½¿ç”¨æ—¶ï¼Œå…¶ä»–çº¿ç¨‹å¯¹è¯¥ list è¿›è¡Œçš„å¢åˆ æ”¹ä¸å¯è§ï¼Œå› ä¸ºå®ƒä»¬æ“ä½œçš„æ˜¯ä¸¤ä¸ªä¸åŒçš„æ•°ç»„ï¼Œè¿™å°±æ˜¯**å¼±ä¸€è‡´æ€§**ã€‚
    

public class CopyList {  
    private static volatile CopyOnWriteArrayList<String> arrayList   
        			= new CopyOnWriteArrayList<>();  
  
    public static void main(String[] args) throws InterruptedException {  
        arrayList.add("hello");  
        arrayList.add("alibaba");  
        arrayList.add("welcome");  
        arrayList.add("to");  
        arrayList.add("hangzhou");  
        Thread threadOne = new Thread(()->{  
            arrayList.set(1, "baba");  
            arrayList.remove(2);  
            arrayList.remove(3);  
        });  
        Iterator<String> itr = arrayList.iterator();  
        threadOne.start();  
        threadOne.join();  
  
        while (itr.hasNext()) {  
            System.out.print(itr.next() + " ");  
        }  
    }  
}  
  
  
è¾“å‡ºï¼šhello alibaba welcome to hangzhou 

> å¼±ä¸€è‡´æ€§çš„ä¸€äº›æ€è€ƒï¼š
> 
> å•çº¿ç¨‹ä¸‹ï¼Œç»å¸¸ä¼šå†™å‡ºä¸‹é¢è¿™ç§ä»£ç ã€‚å°† a çš„å¼•ç”¨ä¼ é€’ç»™äº† bï¼Œäºæ˜¯ b å’Œ a éƒ½æŒ‡å‘å †ä¸­çš„åŒä¸€ä¸ªå¯¹è±¡ï¼Œé‚£ä¹ˆä¿®æ”¹ b ä¹Ÿå°±ç›¸å½“äºä¿®æ”¹äº† aï¼š
> 
> int[] a = new int[]{1, 2, 3};  
> int[] b = a;  
> b[0] = -1;  
> // a = [-1, 2, 3]
> 
> ä½†æ˜¯å¦‚æœä¿®æ”¹ b æ‰€æŒ‡çš„å†…å­˜åœ°å€ï¼Œé‚£ä¹ˆ a å’Œ b å°±æŒ‡å‘ä¸åŒçš„å¯¹è±¡äº†ï¼š
> 
> int[] a = new int[]{1, 2, 3};  
> int[] b = a;  
> b = new int[]{-1, 2, 3};  
> // a = [1, 2, 3]
> 
> ä½†æ˜¯åœ¨å¤šçº¿ç¨‹æƒ…å†µä¸‹ï¼Œå…ˆå°† a æŒ‡å‘çš„å¯¹è±¡ä¼ é€’ç»™å¦ä¸€ä¸ªçº¿ç¨‹çš„ bï¼Œå¦‚æœæ­¤æ—¶ a çš„æŒ‡å‘äº†å¦ä¸€ä¸ªå¯¹è±¡ï¼Œb æ˜¯ä¸çŸ¥æƒ…çš„ï¼Œè¿˜æ˜¯æŒ‡å‘ a æœ€å¼€å§‹æŒ‡å‘çš„å¯¹è±¡ã€‚

# 6. é”

## 6.1 LockSupport å·¥å…·ç±»

å®ƒçš„ä¸»è¦ä½œç”¨æ˜¯æŒ‚èµ·å’Œå”¤é†’çº¿ç¨‹ï¼Œä¹Ÿæ˜¯åˆ›å»ºé”å’Œå…¶ä»–åŒæ­¥ç±»çš„åŸºç¡€ã€‚LockSupport ç±»ä¸æ¯ä¸ªä½¿ç”¨å®ƒçš„çº¿ç¨‹éƒ½ä¼šå…³è”ä¸€ä¸ªè®¸å¯è¯ï¼Œåœ¨é»˜è®¤æƒ…å†µä¸‹è°ƒç”¨ LockSupport ç±»çš„æ–¹æ³•çš„çº¿ç¨‹æ˜¯ä¸æŒæœ‰è®¸å¯è¯çš„ã€‚ LockSupport æ˜¯ä½¿ç”¨ Unsafe ç±»å®ç°çš„ã€‚

### void park()

å¦‚æœè°ƒç”¨ `park` æ–¹æ³•çš„çº¿ç¨‹å·²ç»æ‹¿åˆ°äº†ä¸ LockSupport å…³è”çš„è®¸å¯è¯ï¼Œåˆ™è°ƒç”¨ `Locksupport.park()` æ—¶ä¼šé©¬ä¸Šè¿”å›ï¼Œå¦åˆ™è°ƒç”¨çº¿ç¨‹ä¼šè¢«é˜»å¡æŒ‚èµ·ã€‚

åœ¨é»˜è®¤æƒ…å†µä¸‹è°ƒç”¨çº¿ç¨‹æ˜¯ä¸æŒæœ‰è®¸å¯è¯çš„ï¼š

	public static void main(String[] args){  
        System.out.println("begin park");  
        LockSupport.park();  
        System.out.println("end park");  
    }  
	è¾“å‡ºï¼šbegin park

åœ¨å…¶ä»–çº¿ç¨‹è°ƒç”¨ `unpark(Thread thread)` æ–¹æ³•å¹¶ä¸”å°†å½“å‰çº¿ç¨‹ä½œä¸ºå‚æ•°æ—¶ï¼Œè°ƒç”¨ `park` æ–¹æ³•è€Œè¢«é˜»å¡çš„çº¿ç¨‹ä¼šè¿”å›ã€‚å¦å¤–ï¼Œå¦‚æœå…¶ä»–çº¿ç¨‹è°ƒç”¨äº†é˜»å¡çº¿ç¨‹çš„ `interrupt()` æ–¹æ³• ï¼Œè®¾ç½®äº†ä¸­æ–­æ ‡å¿—æˆ–è€…çº¿ç¨‹è¢«è™šå‡å”¤é†’ï¼Œåˆ™é˜»å¡çº¿ç¨‹ä¹Ÿä¼šè¿”å›ã€‚æ‰€ä»¥åœ¨è°ƒç”¨ park æ–¹æ³•æ—¶æœ€å¥½ä¹Ÿä½¿ç”¨å¾ªç¯æ¡ä»¶åˆ¤æ–­æ–¹å¼ã€‚

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå› è°ƒç”¨ `park()` æ–¹æ³•è€Œè¢«é˜»å¡çš„çº¿ç¨‹è¢«å…¶ä»–çº¿ç¨‹ä¸­æ–­è€Œè¿”å›æ—¶å¹¶ä¸ä¼šæŠ›å‡º `InterruptedException` å¼‚å¸¸ï¼ˆè€Œ sleepã€wait ç­‰æ–¹æ³•ä¼šï¼‰ã€‚

park æ–¹æ³•è¿”å›æ—¶ä¸ä¼šå‘Šè¯‰ä½ å› ä½•ç§åŸå› è¿”å›ï¼Œæ‰€ä»¥è°ƒç”¨è€…éœ€è¦æ ¹æ®ä¹‹å‰è°ƒç”¨ park æ–¹æ³•çš„åŸå› ï¼Œå†æ¬¡æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³ï¼Œå¦‚æœä¸æ»¡è¶³åˆ™è¿˜éœ€è¦å†æ¬¡è°ƒç”¨ park æ–¹æ³•ã€‚ä¸‹é¢ä»£ç å°±æ˜¯æ ¹æ®è°ƒç”¨å‰åä¸­æ–­çŠ¶æ€çš„å¯¹æ¯”å°±å¯ä»¥åˆ¤æ–­æ˜¯ä¸æ˜¯å› ä¸ºè¢«ä¸­æ–­æ‰è¿”å›çš„ã€‚åªæœ‰ä¸­æ–­å­çº¿ç¨‹ï¼Œå­çº¿ç¨‹æ‰ä¼šè¿è¡Œç»“æŸï¼Œå¦‚æœå­çº¿ç¨‹ä¸è¢«ä¸­æ–­ ï¼Œ å³ä½¿è°ƒç”¨ `unpark(thread)` æ–¹æ³•å­çº¿ç¨‹ä¹Ÿä¸ä¼šç»“æŸã€‚

	public static void main(String[] args) throws InterruptedException {  
        Thread thread = new Thread(()->{  
            System.out.println("child thread begin park");  
  
            while (!Thread.currentThread().isInterrupted()) {  
                LockSupport.park();  
            }  
            System.out.println("child thread unpark");  
        });  
  
        thread.start();  
        Thread.sleep(1000);  
        System.out.println("main thread begin unpark");  
        thread.interrupt();  
    }  
	è¾“å‡ºï¼š  
    child thread begin park  
	main thread begin unpark  
	child thread unpark

### void unpark(Thread thread)

å½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ `unpark` æ—¶ï¼š

-   å¦‚æœå‚æ•° `thread` çº¿ç¨‹æ²¡æœ‰æŒæœ‰ `thread` ä¸ `LockSupport` ç±»å…³è”çš„è®¸å¯è¯ï¼Œ åˆ™è®© `thread` çº¿ç¨‹æŒæœ‰ã€‚
    
-   å¦‚æœ `thread` ä¹‹å‰å› è°ƒç”¨ `park()` è€Œè¢«æŒ‚èµ·ï¼Œåˆ™è°ƒç”¨ `unpark` åï¼Œè¯¥çº¿ç¨‹ä¼šè¢«å”¤é†’ã€‚å¦‚æœ `thread` ä¹‹å‰æ²¡æœ‰è°ƒç”¨ `park`ï¼Œåˆ™è°ƒç”¨ `unpark` æ–¹æ³•å ï¼Œ å†è°ƒç”¨ `park` æ–¹æ³•ï¼Œå…¶ä¼šç«‹åˆ»è¿”å›ã€‚
    

	public static void main(String[] args){  
        System.out.println("begin park");  
        LockSupport.unpark(Thread.currentThread());  
        LockSupport.park();  
        System.out.println("end park");  
    }  
	è¾“å‡ºï¼š  
    begin park  
	end park

### void park(long nanos)

å¦‚æœè¢«æŒ‚èµ·çš„çº¿ç¨‹åœ¨ nanos æ—¶é—´åè¿˜æ²¡æœ‰æ‹¿åˆ°è®¸å¯è¯ï¼Œä¼šè‡ªåŠ¨è¿”å›ã€‚

### void park(Object blocker)

å½“çº¿ç¨‹ç¨‹åœ¨æ²¡æœ‰æŒæœ‰è®¸å¯è¯çš„æƒ…å†µä¸‹è°ƒç”¨ park æ–¹æ³•è€Œè¢«é˜»å¡æŒ‚èµ·æ—¶ï¼Œè¿™ä¸ª blocker å¯¹è±¡ä¼šè¢«è®°å½•åˆ°è¯¥çº¿ç¨‹ å†…éƒ¨ã€‚

ä½¿ç”¨è¯Šæ–­å·¥å…·å¯ä»¥è§‚å¯Ÿçº¿ç¨‹è¢«é˜»å¡çš„åŸå› ï¼Œè¯Šæ–­å·¥å…·æ˜¯é€šè¿‡è°ƒç”¨ getBlocker(Thread) æ–¹æ³•æ¥è·å– blocker å¯¹ è±¡çš„ï¼Œæ‰€ä»¥ JDK æ¨èæˆ‘ä»¬ä½¿ç”¨å¸¦æœ‰ blocker å‚æ•°çš„ park æ–¹æ³•ï¼Œå¹¶ä¸” blocker è¢«è®¾ç½®ä¸º thisï¼Œè¿™æ ·å½“åœ¨æ‰“å°çº¿ç¨‹å †æ ˆæ’æŸ¥é—®é¢˜æ—¶å°±èƒ½çŸ¥é“æ˜¯å“ªä¸ªç±»è¢«é˜»å¡äº†ã€‚

public class TestPark {  
    private void testPark() {  
        LockSupport.park();  
    }  
    public static void main(String[] args){  
        TestPark testPark = new TestPark();  
        testPark.testPark();  
    }  
}

è¿è¡Œåï¼Œä½¿ç”¨ `jstack pid` å‘½ä»¤æŸ¥çœ‹çº¿ç¨‹å †æ ˆå¯ä»¥çœ‹åˆ°ï¼š

![Screen Shot 2021-06-12 at 00.17.27](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-12%20at%2000.17.27.png)

ä¿®æ”¹æˆï¼š`LockSupport.park(this)` ä¹‹åï¼š

![Screen Shot 2021-06-12 at 00.17.23](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-12%20at%2000.17.23.png)

æºç ï¼š

    public static void park(Object blocker) {  
        Thread t = Thread.currentThread();  
        setBlocker(t, blocker);  
        // æŒ‚èµ·çº¿ç¨‹  
        UNSAFE.park(false, 0L);  
        // çº¿ç¨‹è¢«æ¿€æ´»åï¼Œæ¸…é™¤ blocker å˜é‡ï¼Œå› ä¸ºä¸€èˆ¬éƒ½æ˜¯åœ¨çº¿ç¨‹é˜»å¡æ—¶æ‰ä½¿ç”¨  
        setBlocker(t, null);  
    }

Thread ç±»é‡Œé¢æœ‰ä¸ªå˜é‡ `volatile Object parkBlocker`ï¼Œ ç”¨æ¥å­˜æ”¾ park æ–¹æ³•ä¼ é€’çš„ blocker å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯æŠŠ blocker å˜é‡å­˜æ”¾åˆ°äº†è°ƒç”¨ `park` æ–¹æ³•çš„çº¿ç¨‹çš„æˆå‘˜å˜é‡é‡Œé¢ã€‚

### void parkNanos(Object blocker, long nanos)

### void parkUntil(Object blocker, long deadline)

	public static void parkUntil(Object blocker, long deadline) {  
        Thread t = Thread.currentThread();  
        setBlocker(t, blocker);  
        UNSAFE.park(true, deadline);  
        setBlocker(t, null);  
    }

å…¶ä¸­å‚æ•° deadline çš„æ—¶é—´å•ä½ä¸º msï¼Œè¯¥æ—¶é—´æ˜¯ä» 1970 å¹´åˆ°ç°åœ¨æŸä¸€ä¸ªæ—¶é—´ç‚¹çš„æ¯«ç§’å€¼ã€‚

### ä¾‹å­

public class FIFOMutex {  
    private final AtomicBoolean locked = new AtomicBoolean(false);  
    private final Queue<Thread> waiters = new ConcurrentLinkedQueue<>();  
  
    private void lock() {  
        boolean wasInterrupted = false;  
        Thread current = Thread.currentThread();  
        waiters.add(current);  
  
        // (1)  
        while (waiters.peek() != current || !locked.compareAndSet(false, true)) {  
            LockSupport.park(this);  
            if (Thread.interrupted()) {			// (2)  
                wasInterrupted = true;  
            }  
        }  
  
        waiters.remove();  
        if (wasInterrupted) {					// (3)  
            current.interrupt();  
        }  
    }  
  
    private void unlock() {  
        locked.set(false);  
        LockSupport.unpark(waiters.peek());  
    }  
}

è¿™æ˜¯ ä¸€ ä¸ªå…ˆè¿›å…ˆå‡ºçš„é”ã€‚ åœ¨ä»£ç  (1) å¤„ï¼Œå¦‚æœå½“å‰çº¿ç¨‹ä¸æ˜¯é˜Ÿé¦–æˆ–è€…å½“å‰é”å·±ç»è¢«å…¶ä»–çº¿ç¨‹è·å–ï¼Œåˆ™è°ƒç”¨ park æ–¹æ³•æŒ‚èµ·è‡ªå·±ã€‚

ç„¶ååœ¨ä»£ç  (2) å¤„åˆ¤æ–­ï¼Œå¦‚æœ park æ–¹æ³•æ˜¯å› ä¸ºè¢«ä¸­æ–­è€Œè¿”å›ï¼Œåˆ™å¿½ç•¥ä¸­æ–­ï¼Œå¹¶ä¸”é‡ç½®ä¸­æ–­æ ‡å¿—ï¼Œåšä¸ªæ ‡è®°ï¼Œç„¶åå†æ¬¡åˆ¤æ–­å½“å‰çº¿ç¨‹æ˜¯ä¸æ˜¯é˜Ÿé¦–å…ƒç´ æˆ–è€…å½“å‰é”æ˜¯å¦å·±ç»è¢«å…¶ä»–çº¿ç¨‹è·å–ï¼Œå¦‚æœæ˜¯åˆ™ç»§ç»­è°ƒç”¨ park æ–¹æ³•æŒ‚èµ·è‡ªå·±ã€‚

ç„¶ååœ¨ä»£ç  (3) ä¸­ï¼Œåˆ¤æ–­æ ‡è®°ï¼Œå¦‚æœæ ‡è®°ä¸º true åˆ™ä¸­æ–­è¯¥çº¿ç¨‹ï¼Œè¿™ä¸ªæ€ä¹ˆç†è§£å‘¢ï¼Ÿå…¶å®å°±æ˜¯å…¶ä»–çº¿ç¨‹ä¸­æ–­äº†è¯¥çº¿ç¨‹ï¼Œè™½ç„¶æˆ‘å¯¹ä¸­æ–­ä¿¡å·ä¸æ„Ÿå…´è¶£ï¼Œå¿½ç•¥å®ƒï¼Œä½†æ˜¯ä¸ä»£è¡¨å…¶ä»–çº¿ç¨‹å¯¹è¯¥æ ‡å¿—ä¸æ„Ÿå…´è¶£ï¼Œæ‰€ä»¥è¦æ¢å¤ä¸‹ã€‚

## 6.2 æŠ½è±¡åŒæ­¥é˜Ÿåˆ— AQS

### AbstractQueuedSynchronizer

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612092219117.png" alt="image-20210612092219117" style="zoom: 33%;" />

å®ƒæ˜¯åŒæ­¥å™¨çš„åŸºæœ¬ç»„ä»¶ï¼Œå¹¶å‘åŒ…ä¸­é”çš„åº•å±‚å°±æ˜¯ç”¨ AQS å®ç°çš„ã€‚

AQS æ˜¯ä¸€ä¸ªåŒå‘ Node é˜Ÿåˆ—ï¼Œæœ‰ `head` å’Œ `tail`ï¼›

Node ä¸­çš„ `thread` å˜é‡ç”¨æ¥å­˜æ”¾è¿›å…¥ AQS é‡Œçš„çº¿ç¨‹ï¼›Node å†…éƒ¨çš„ `SHARED` ç”¨æ¥æ ‡è®°è¯¥çº¿ç¨‹æ˜¯è·å–å…±äº«èµ„æºæ—¶è¢«é˜»å¡æŒ‚èµ·åæ”¾å…¥ AQS é˜Ÿåˆ—çš„ï¼Œ `EXCLUSIVE` ç”¨æ¥æ ‡è®°çº¿ç¨‹æ˜¯è·å–ç‹¬å èµ„æºæ—¶è¢«æŒ‚èµ·åæ”¾å…¥ AQS é˜Ÿåˆ—çš„ï¼›

`waitStatus` è®°å½•å½“å‰çº¿ç¨‹ç­‰å¾…çŠ¶æ€ï¼Œå¯ä»¥ä¸º `CANCELLED`ï¼ˆçº¿ç¨‹è¢«å–æ¶ˆäº†ï¼‰ã€`SIGNAL`ï¼ˆçº¿ç¨‹éœ€è¦è¢«å”¤é†’ï¼‰ã€ `CONDITION`ï¼ˆçº¿ç¨‹åœ¨æ¡ä»¶é˜Ÿåˆ—é‡Œé¢ç­‰å¾…ï¼‰ã€`PROPAGATE`ï¼ˆé‡Šæ”¾å…±äº«èµ„æºæ—¶éœ€è¦é€šçŸ¥å…¶ä»–èŠ‚ç‚¹ï¼‰ã€‚

AQS ä¸­ç»´æŒäº†ä¸€ä¸ªå•ä¸€å•çŠ¶æ€ä¿¡æ¯ `state`ï¼Œç›¸å…³æ–¹æ³•æœ‰ `getState`ã€`setState` å’Œ `compareAndSetState`ã€‚

> -   å¯¹äº ReentrantLockï¼Œstate è¡¨ç¤ºå½“å‰çº¿ç¨‹è·å–é”çš„å¯é‡å…¥æ¬¡æ•°ï¼›
>     
> -   å¯¹äº ReentrantReadWriteLock æ¥è¯´ï¼Œstate çš„é«˜ 16 ä½è¡¨ç¤ºè·å–è¯»é”çš„çº¿ç¨‹å¯é‡å…¥æ¬¡æ•°ï¼Œä½ 16 ä½è¡¨ç¤ºè·å–åˆ°å†™é”çš„çº¿ç¨‹å¯é‡å…¥æ¬¡æ•°ï¼›
>     
> -   å¯¹äº Semaphore æ¥è¯´ï¼Œstate è¡¨ç¤ºå½“å‰å¯ç”¨ä¿¡å·ä¸ªæ•°ï¼›
>     
> -   å¯¹äº CountDownLatch æ¥è¯´ï¼Œstate è¡¨ç¤ºè®¡æ•°å™¨å½“å‰çš„å€¼ã€‚
>     

AQS æœ‰ä¸ªå†…éƒ¨ç±» `ConditionObject`ï¼Œç”¨æ¥ç»“åˆé”å®ç°çº¿ç¨‹åŒæ­¥ã€‚`ConditionObject` å¯ä»¥ç›´æ¥è®¿é—® AQS å¯¹è±¡å†…éƒ¨çš„å˜é‡ï¼Œæ¯”å¦‚ state å’Œ AQS é˜Ÿåˆ—ã€‚`ConditionObject` æ˜¯æ¡ä»¶å˜é‡ï¼Œæ¯ä¸ªæ¡ä»¶å˜é‡å¯¹åº”ä¸€ä¸ªæ¡ä»¶é˜Ÿåˆ—ï¼ˆå•å‘é“¾è¡¨é˜Ÿåˆ—ï¼‰ï¼Œå…¶ç”¨æ¥å­˜æ”¾è°ƒç”¨æ¡ä»¶å˜é‡çš„ `await` æ–¹æ³•åè¢«é˜»å¡çš„çº¿ç¨‹ï¼Œè¿™ä¸ªæ¡ä»¶é˜Ÿåˆ—çš„å¤´ã€å°¾å…ƒç´ åˆ†åˆ«ä¸º `firstWaiter` å’Œ `lastWaiter`ã€‚

å¯¹äº AQS æ¥è¯´ï¼Œçº¿ç¨‹åŒæ­¥çš„å…³é”®æ˜¯å¯¹çŠ¶æ€å€¼ `state` è¿›è¡Œæ“ä½œã€‚æ ¹æ® `state` æ˜¯å¦å±äºä¸€ä¸ªçº¿ç¨‹ï¼Œæ“ä½œ `state` çš„æ–¹å¼åˆ†ä¸ºç‹¬å æ–¹å¼å’Œå…±äº«æ–¹å¼ï¼š

-   åœ¨ç‹¬å æ–¹å¼ä¸‹è·å–å’Œé‡Šæ”¾èµ„æºä½¿ç”¨çš„æ–¹æ³•ä¸ºï¼š`void acquire(int arg)`ã€`void acquireInterruptibly(int arg)`ã€ `boolean release(int arg)`ã€‚
    
-   åœ¨å…±äº«æ–¹å¼ä¸‹è·å–å’Œé‡Šæ”¾èµ„æºçš„æ–¹æ³•ä¸ºï¼š`void acquireShared(int arg)`ã€`void acquireSharedInterruptibly(int arg)`ã€`boolean releaseShared(int arg)`ã€‚
    

#### å®ç°ç‹¬å é”å’Œå…±äº«é”

##### ç‹¬å æ–¹å¼

ä½¿ç”¨ç‹¬å æ–¹å¼è·å–çš„èµ„æºæ˜¯ä¸å…·ä½“çº¿ç¨‹ç»‘å®šçš„ï¼Œå°±æ˜¯è¯´å¦‚æœä¸€ä¸ªçº¿ç¨‹è·å–åˆ°äº†èµ„æºï¼Œå°±ä¼šæ ‡è®°æ˜¯è¿™ä¸ªçº¿ç¨‹è·å–åˆ°äº†ï¼Œå…¶ä»–çº¿ç¨‹å†å°è¯•æ“ä½œ `state` è·å–èµ„æºæ—¶ä¼šå‘ç°å½“å‰è¯¥èµ„æºä¸æ˜¯è‡ªå·±æŒæœ‰çš„ï¼Œå°±ä¼šåœ¨è·å–å¤±è´¥åè¢«é˜»å¡ã€‚

è·å–ä¸é‡Šæ”¾èµ„æºçš„æµç¨‹å¦‚ä¸‹ï¼š

1.  å½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ `acquire(int arg)` æ–¹æ³•è·å–ç‹¬å èµ„æºæ—¶ï¼Œä¼šé¦–å…ˆä½¿ç”¨ `tryAcquire` æ–¹æ³•å°è¯•è·å–èµ„æºï¼Œ å…·ä½“æ˜¯è®¾ç½®çŠ¶æ€å˜é‡ `state` çš„å€¼ï¼ŒæˆåŠŸåˆ™ç›´æ¥è¿”å›ï¼Œå¤±è´¥åˆ™å°†å½“å‰çº¿ç¨‹å°è£…ä¸ºç±»å‹ä¸º `Node.EXCLUSIVE` çš„ Node èŠ‚ç‚¹åæ’å…¥åˆ° AQS é˜»å¡é˜Ÿåˆ—çš„å°¾éƒ¨ï¼Œå¹¶è°ƒç”¨ `LockSupport.park(this)` æ–¹æ³•æŒ‚èµ·è‡ªå·± ã€‚
    
    	public final void acquire(int arg) {  
            if (!tryAcquire(arg) &&  
                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  
                selfInterrupt();  
        }
    
2.  å½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ `release(int arg)` æ–¹æ³•æ—¶ä¼šå°è¯•ä½¿ç”¨ `tryRelease` æ“ä½œé‡Šæ”¾èµ„æºï¼Œè¿™é‡Œæ˜¯è®¾ç½®çŠ¶æ€å˜é‡ `state` çš„å€¼ï¼Œç„¶åè°ƒç”¨ `LockSupport.unpark(thread)` æ–¹æ³•æ¿€æ´» AQS é˜Ÿåˆ—é‡Œé¢è¢«é˜»å¡çš„ä¸€ä¸ªçº¿ç¨‹ã€‚ è¢«æ¿€æ´»çš„çº¿ç¨‹åˆ™ä½¿ç”¨ `tryAcquire` å°è¯•ï¼Œçœ‹å½“å‰çŠ¶æ€å˜é‡ `state` çš„å€¼æ˜¯å¦èƒ½æ»¡è¶³è‡ªå·±çš„éœ€è¦ï¼Œæ»¡è¶³åˆ™è¯¥çº¿ç¨‹è¢«æ¿€æ´»ï¼Œç„¶åç»§ç»­å‘ä¸‹è¿è¡Œï¼Œå¦åˆ™è¿˜æ˜¯ä¼šè¢«æ”¾å…¥ AQS é˜Ÿåˆ—å¹¶è¢«æŒ‚èµ·ã€‚
    
    	public final boolean release(int arg) {  
            if (tryRelease(arg)) {  
                Node h = head;  
                if (h != null && h.waitStatus != 0)  
                    unparkSuccessor(h);  
                return true;  
            }  
            return false;  
        }
    

`trAcquire` å’Œ `tryRelease` éœ€è¦ç”±å…·ä½“çš„å­ç±»æ¥å®ç°ã€‚ å­ç±»åœ¨å®ç° tryAcquireå’Œ tryReleaseæ—¶è¦æ ¹æ®å…·ä½“åœºæ™¯ä½¿ç”¨ CAS ç®—æ³•å°è¯•ä¿®æ”¹ stateçŠ¶æ€å€¼ï¼Œ æˆåŠŸåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚ å­ç±»è¿˜éœ€è¦å®šä¹‰ï¼Œåœ¨è°ƒç”¨ `acquire` å’Œ `release` æ–¹æ³•æ—¶ `state` çŠ¶æ€å€¼çš„å¢å‡ä»£è¡¨ä»€ä¹ˆå«ä¹‰ ã€‚

> æ¯”å¦‚ç‹¬å é” `ReentrantLock`ï¼Œ å®šä¹‰å½“ `state` ä¸º 0 æ—¶è¡¨ç¤ºé”ç©ºé—²ï¼Œä¸º 1 æ—¶è¡¨ç¤ºé”å·±ç»è¢«å ç”¨ã€‚åœ¨é‡å†™ `tryAcquire` æ—¶ï¼Œåœ¨å†…éƒ¨éœ€è¦ä½¿ç”¨ CAS ç®—æ³•æŸ¥çœ‹å½“å‰ state æ˜¯å¦ä¸º 0ï¼Œå¦‚æœä¸º 0 åˆ™ ä½¿ç”¨ CAS è®¾ç½®ä¸º 1ï¼Œå¹¶è®¾ç½®å½“å‰é”çš„æŒæœ‰è€…ä¸ºå½“å‰çº¿ç¨‹ï¼Œè€Œåè¿”å› trueï¼Œå¦‚æœ CAS å¤±è´¥åˆ™è¿”å› falseã€‚
> 
> æ¯”å¦‚ç»§æ‰¿è‡ª AQS å®ç°çš„ç‹¬å é”åœ¨å®ç° `tryRelease` æ—¶ï¼Œåœ¨å†…éƒ¨éœ€è¦ä½¿ç”¨ CAS ç®—æ³•æŠŠå½“å‰ state çš„å€¼ä» 1 ä¿®æ”¹ä¸º 0ï¼Œå¹¶è®¾ç½®å½“å‰é”çš„æŒæœ‰è€…ä¸º nullï¼Œç„¶åè¿”å› trueï¼Œ å¦‚æœ CAS å¤±è´¥ åˆ™è¿”å› falseã€‚

##### å…±äº«æ–¹å¼

å¯¹åº”å…±äº«æ–¹å¼çš„èµ„æºä¸å…·ä½“çº¿ç¨‹æ˜¯ä¸ç›¸å…³çš„ï¼Œå½“å¤šä¸ªçº¿ç¨‹å»è¯·æ±‚èµ„æºæ—¶é€šè¿‡ CAS æ–¹å¼ç«äº‰è·å–èµ„æºï¼Œå½“ ä¸€ä¸ªçº¿ç¨‹è·å–åˆ°äº†èµ„æºåï¼Œå¦å¤–ä¸€ä¸ªçº¿ç¨‹å†æ¬¡å»è·å–æ—¶å¦‚æœå½“å‰èµ„æºè¿˜èƒ½æ»¡è¶³å®ƒçš„éœ€è¦ï¼Œåˆ™å½“å‰çº¿ç¨‹åªéœ€è¦ä½¿ç”¨ CAS æ–¹å¼è¿›è¡Œè·å–å³å¯ã€‚æ¯”å¦‚ `Semaphore` ä¿¡å·é‡ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹é€šè¿‡ `acquire()` æ–¹æ³•è·å–ä¿¡å·é‡æ—¶ï¼Œä¼šé¦–å…ˆçœ‹å½“å‰ä¿¡å·é‡ä¸ªæ•°æ˜¯å¦æ»¡è¶³éœ€è¦ï¼Œä¸æ»¡è¶³åˆ™æŠŠå½“å‰çº¿ç¨‹æ”¾å…¥é˜»å¡é˜Ÿåˆ—ï¼Œå¦‚æœæ»¡è¶³åˆ™é€šè¿‡è‡ªæ—‹ CAS è·å–ä¿¡å·é‡ã€‚

è·å–ä¸é‡Šæ”¾èµ„æºçš„æµç¨‹å¦‚ä¸‹ï¼š

1.  å½“çº¿ç¨‹è°ƒç”¨ `acquireShared(int arg)` è·å–å…±äº«èµ„æºæ—¶ï¼Œä¼šé¦–å…ˆä½¿ç”¨ `tryAcquireShared` å°è¯•è·å–èµ„æºï¼Œå…·ä½“æ˜¯è®¾ç½®çŠ¶æ€å˜é‡ `state` çš„å€¼ï¼ŒæˆåŠŸåˆ™ç›´æ¥è¿”å›ï¼Œå¤±è´¥åˆ™å°†å½“å‰çº¿ç¨‹å°è£…ä¸ºç±»å‹ä¸º `Node.SHARED` çš„ Node èŠ‚ç‚¹åæ’å…¥åˆ° AQS é˜»å¡é˜Ÿåˆ—çš„å°¾éƒ¨ï¼Œå¹¶ä½¿ç”¨ `LockSupport.park(this)` æ–¹æ³•æŒ‚èµ·è‡ªå·±ã€‚
    
    	public final void acquireShared(int arg) {  
            if (tryAcquireShared(arg) < 0)  
                doAcquireShared(arg);  
        }
    
2.  å½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨ `releaseShared(int arg)` æ—¶ä¼šå°è¯•ä½¿ç”¨ `tryReleaseShared` æ“ä½œé‡Šæ”¾èµ„æºï¼Œè¿™é‡Œæ˜¯è®¾ç½®çŠ¶æ€å˜é‡ `state` çš„å€¼ï¼Œç„¶åä½¿ç”¨ `LockSupport.unpark(thread)` æ¿€æ´» AQS é˜Ÿåˆ—é‡Œé¢è¢«é˜»å¡çš„ä¸€ä¸ªçº¿ç¨‹ã€‚è¢«æ¿€æ´»çš„çº¿ç¨‹åˆ™ä½¿ç”¨ `tryAcquireShared` æŸ¥çœ‹å½“å‰çŠ¶æ€å˜é‡ `state` çš„å€¼æ˜¯å¦èƒ½æ»¡è¶³è‡ªå·±çš„ éœ€è¦ï¼Œæ»¡è¶³åˆ™è¯¥çº¿ç¨‹è¢«æ¿€æ´»ï¼Œç„¶åç»§ç»­å‘ä¸‹è¿è¡Œï¼Œå¦åˆ™è¿˜æ˜¯ä¼šè¢«æ”¾å…¥ AQS é˜Ÿåˆ—å¹¶è¢«æŒ‚èµ·ã€‚
    
        public final boolean releaseShared(int arg) {  
            if (tryReleaseShared(arg)) {  
                doReleaseShared();  
                return true;  
            }  
            return false;  
        }
    

`tryAcquireShared` å’Œ `tryReleaseShared` éœ€è¦ç”±å…·ä½“çš„å­ç±»æ¥å®ç°ã€‚å­ç±»åœ¨å®ç° `tryAcquireShared` å’Œ `tryReleaseShared` æ—¶è¦æ ¹æ®å…·ä½“åœºæ™¯ä½¿ç”¨ CAS ç®—æ³•å°è¯•ä¿®æ”¹ `state` çŠ¶æ€å€¼ï¼ŒæˆåŠŸåˆ™è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚

> æ¯”å¦‚ç»§æ‰¿è‡ª AQS å®ç°çš„è¯»å†™é” ReentrantReadWriteLock é‡Œé¢çš„è¯»é”åœ¨é‡å†™ tryAcquireShared æ—¶ï¼Œé¦–å…ˆæŸ¥çœ‹å†™é”æ˜¯å¦è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰ï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥è¿”å› falseï¼Œ å¦åˆ™ä½¿ç”¨ CAS é€’å¢ state çš„é«˜ 16 ä½ã€‚é‡å†™ tryReleaseShared æ—¶ï¼Œåœ¨å†…éƒ¨éœ€è¦ä½¿ç”¨ CAS ç®—æ³•æŠŠå½“å‰ state å€¼çš„é«˜ 16 ä½å‡ 1ï¼Œ ç„¶åè¿”å› trueï¼Œå¦‚æœ CAS å¤±è´¥åˆ™è¿”å› falseã€‚

åŸºäº AQS å®ç°çš„é”é™¤äº†éœ€è¦é‡å†™ä¸Šé¢ä¸­çš„ä¸€ç±»æ–¹æ³•å¤–ï¼Œ**è¿˜éœ€è¦é‡å†™ `isHeldExclusively` æ–¹æ³•**ï¼Œæ¥åˆ¤æ–­é”æ˜¯è¢«å½“å‰çº¿ç¨‹ç‹¬å è¿˜æ˜¯è¢«å…±äº«ã€‚

`void acquireInterruptibly(int arg)` ä¸ `void acquireSharedInterruptibly(int arg)` è¿™ä¸¤ä¸ªå‡½æ•°ä¸­éƒ½æœ‰ä¸€ä¸ªå¸¦æœ‰ Interruptibly å…³é”®å­—ã€‚ä¸å¸¦ Interruptibly å…³é”®å­—çš„æ–¹æ³•çš„æ„æ€æ˜¯ä¸å¯¹ä¸­æ–­è¿›è¡Œå“åº”ï¼Œä¹Ÿå°±æ˜¯çº¿ç¨‹åœ¨è°ƒç”¨ä¸å¸¦ Interruptibly å…³é”®å­—çš„æ–¹æ³•è·å–èµ„æºæ—¶æˆ–è€…è·å–èµ„æºå¤±è´¥è¢«æŒ‚èµ·æ—¶ï¼Œå…¶ä»–çº¿ç¨‹ä¸­æ–­äº†è¯¥çº¿ç¨‹ï¼Œé‚£ä¹ˆè¯¥çº¿ç¨‹ä¸ä¼šå› ä¸ºè¢«ä¸­æ–­è€ŒæŠ›å‡ºå¼‚å¸¸ï¼Œå®ƒè¿˜æ˜¯ç»§ç»­è·å–èµ„æºæˆ–è€…è¢«æŒ‚èµ·ï¼Œå¿½ç•¥ä¸­æ–­ã€‚å¦åˆ™ï¼Œä¼šæŠ›å‡º InterruptedExceptionã€‚

#### ç»´æŠ¤ AQS æä¾›çš„é˜Ÿåˆ—

ä¸»è¦çœ‹å…¥é˜Ÿæ“ä½œï¼š

å½“ä¸€ä¸ªçº¿ç¨‹è·å–é”å¤±è´¥åè¯¥çº¿ç¨‹ä¼šè¢«è½¬æ¢ä¸º Node èŠ‚ç‚¹ï¼Œç„¶åå°±ä¼šä½¿ç”¨ `enq(final Node node)` æ–¹æ³•å°†è¯¥èŠ‚ç‚¹æ’å…¥åˆ° AQS çš„é˜»å¡é˜Ÿåˆ—ã€‚

    private Node enq(final Node node) {  
        for (;;) {  
            Node t = tail;  
            if (t == null) { // Must initialize  
                if (compareAndSetHead(new Node()))  
                    tail = head;  
            } else {  
                // node æ’å…¥é˜Ÿå°¾ï¼Œè¿”å›ä¹‹å‰çš„é˜Ÿå°¾  
                node.prev = t;  
                if (compareAndSetTail(t, node)) {  
                    t.next = node;  
                    return t;  
                }  
            }  
        }  
    }

![image-20210612104917370](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612104917370.png)

### æ¡ä»¶å˜é‡

notify å’Œ wait æ˜¯é…åˆ synchronized å†…ç½®é”å®ç°çº¿ç¨‹é—´åŒæ­¥çš„åŸºç¡€è®¾æ–½ï¼Œæ¡ä»¶å˜é‡çš„ signal å’Œ await æ–¹æ³•ä¹Ÿæ˜¯ç”¨æ¥é…åˆä½¿ç”¨ AQS å®ç°çš„é”å®ç°çº¿ç¨‹é—´åŒæ­¥çš„åŸºç¡€è®¾æ–½ã€‚å®ƒä»¬çš„ä¸åŒåœ¨äºï¼Œsynchronized åŒæ—¶åªèƒ½ä¸ä¸€ä¸ªå…±äº«å˜é‡çš„ notify æˆ– wait æ–¹æ³•å®ç°åŒæ­¥ï¼Œè€Œ AQS çš„ä¸€ä¸ªé”å¯ä»¥å¯¹åº”å¤šä¸ªæ¡ä»¶å˜é‡ã€‚

åœ¨è°ƒç”¨å…±äº«å˜é‡çš„ notify å’Œ wait æ–¹æ³•å‰å¿…é¡»å…ˆè·å–è¯¥å…±äº«å˜é‡çš„å†…ç½®é”ï¼ŒåŒç†ï¼Œåœ¨è°ƒç”¨æ¡ä»¶å˜é‡çš„ signal å’Œ await æ–¹æ³•å‰ä¹Ÿå¿…é¡»å…ˆè·å–æ¡ä»¶å˜é‡å¯¹åº”çš„é”ã€‚

        ReentrantLock lock = new ReentrantLock();  
        Condition condition = lock.newCondition();  
  
		// ç¨‹åº 1  
        lock.lock();  
        try {  
            System.out.println("begin wait");  
            condition.await();  
            System.out.println("end wait");  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            lock.unlock();  
        }  
  
		// ç¨‹åº 2  
        lock.lock();  
        try {  
            System.out.println("begin signal");  
            condition.signal();  
            System.out.println("end signal");  
        } catch (Exception e) {  
            e.printStackTrace();  
        } finally {  
            lock.unlock();  
        }

é€šè¿‡è°ƒç”¨ `newCondition` æ–¹æ³•åˆ›å»ºä¸€ä¸ªæ¡ä»¶å˜é‡ ConditionObjectï¼ˆè¿™æ˜¯ AQS çš„å†…éƒ¨ç±»ï¼Œå®ç°äº† Condition æ¥å£ï¼Œå¯ä»¥è®¿é—® AQS çš„å˜é‡å’Œæ–¹æ³•ï¼‰ã€‚åœ¨æ¯ä¸ªæ¡ä»¶å˜é‡å†…éƒ¨éƒ½ç»´æŠ¤äº†ä¸€ä¸ªæ¡ä»¶é˜Ÿåˆ—ï¼Œç”¨æ¥å­˜æ”¾è°ƒç”¨æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•æ—¶è¢«é˜»å¡çš„çº¿ç¨‹ã€‚

å¦‚æœçº¿ç¨‹è°ƒç”¨äº†æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•é˜»å¡æŒ‚èµ·äº†å½“å‰çº¿ç¨‹ã€‚å½“å…¶ä»–çº¿ç¨‹è°ƒç”¨æ¡ä»¶å˜é‡çš„ signal æ–¹æ³•æ—¶ï¼Œè¢«é˜»å¡çš„çº¿ç¨‹æ‰æœ‰å¯èƒ½ä¼šä» await å¤„è¿”å›ã€‚å’Œè°ƒç”¨ Object çš„ wait æ–¹æ³•ä¸€æ ·ï¼Œå¦‚æœåœ¨æ²¡æœ‰è·å–åˆ°é”å‰è°ƒç”¨äº†æ¡ä»¶å˜é‡çš„ await æ–¹æ³•åˆ™ä¼šæŠ›å‡º java.lang.IllegalMonitorStateException å¼‚å¸¸ã€‚è°ƒç”¨æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•å°±ç›¸å½“äºè°ƒç”¨å…±äº«å˜é‡çš„ wait() æ–¹æ³•ï¼Œsignal å’Œ notifyã€signalAll å’Œ notifyAll åŒç†ã€‚

#### await

åœ¨å¦‚ä¸‹ä»£ç ä¸­ï¼Œå½“çº¿ç¨‹è°ƒç”¨æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•æ—¶ï¼ˆå¿…é¡»å…ˆè°ƒç”¨é”çš„ lock() æ–¹æ³•è·å–é”ï¼‰ï¼Œåœ¨å†…éƒ¨ä¼šæ„é€ ä¸€ä¸ªç±»å‹ä¸º `Node.CONDITION` çš„ node èŠ‚ç‚¹ï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹æ’å…¥æ¡ä»¶é˜Ÿåˆ—æœ«å°¾ï¼Œä¹‹åå½“å‰çº¿ç¨‹ä¼šé‡Šæ”¾è·å–çš„é”ï¼ˆä¹Ÿå°±æ˜¯ä¼šæ“ä½œé”å¯¹åº”çš„ state å˜é‡çš„å€¼ï¼‰ï¼Œå¹¶è¢«é˜»å¡æŒ‚èµ·ã€‚è¿™æ—¶å€™å¦‚æœæœ‰å…¶ä»–çº¿ç¨‹è°ƒç”¨ lock.lock() å°è¯•è·å–é”ï¼Œå°±ä¼šæœ‰ä¸€ä¸ªçº¿ç¨‹è·å–åˆ°é”ï¼Œå¦‚æœè·å–åˆ°é”çš„çº¿ç¨‹è°ƒç”¨äº†æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•ï¼Œåˆ™è¯¥çº¿ç¨‹ä¹Ÿä¼šè¢«æ”¾å…¥æ¡ä»¶å˜é‡çš„é˜»å¡é˜Ÿåˆ—ï¼Œç„¶åé‡Šæ”¾è·å–åˆ°çš„é”ï¼Œåœ¨ await() æ–¹æ³•å¤„é˜»å¡ã€‚

        public final void await() throws InterruptedException {  
            if (Thread.interrupted())  
                throw new InterruptedException();  
            Node node = addConditionWaiter();  
            int savedState = fullyRelease(node);  
            int interruptMode = 0;  
            while (!isOnSyncQueue(node)) {  
                LockSupport.park(this);  
              	if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)  
                    break;  
            }  
            if (acquireQueued(node, savedState) && interruptMode != THROW_IE)  
                interruptMode = REINTERRUPT;  
            if (node.nextWaiter != null) // clean up if cancelled  
                unlinkCancelledWaiters();  
            if (interruptMode != 0)  
                reportInterruptAfterWait(interruptMode);  
        }

åœ¨å¦‚ä¸‹ä»£ç ä¸­ï¼Œå½“å¦å¤–ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨æ¡ä»¶å˜é‡çš„ signal æ–¹æ³•æ—¶ï¼ˆå¿…é¡»å…ˆè°ƒç”¨é”çš„ lock() æ–¹æ³•è·å–é”ï¼‰ï¼Œåœ¨å†…éƒ¨ä¼šæŠŠæ¡ä»¶é˜Ÿåˆ—é‡Œé¢é˜Ÿå¤´çš„ä¸€ä¸ªçº¿ç¨‹èŠ‚ç‚¹ä»æ¡ä»¶é˜Ÿåˆ—é‡Œé¢ç§»é™¤å¹¶æ”¾å…¥ AQS çš„é˜»å¡é˜Ÿåˆ—é‡Œé¢ï¼Œç„¶åæ¿€æ´»è¿™ä¸ªçº¿ç¨‹ã€‚

#### signal

        public final void signal() {  
            if (!isHeldExclusively())  
                throw new IllegalMonitorStateException();  
            Node first = firstWaiter;  
            if (first != null)  
                doSignal(first);  
        }

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒAQS åªæä¾›äº† ConditionObject çš„å®ç°ï¼Œå¹¶æ²¡æœ‰æä¾› `newCondition` å‡½æ•°ï¼Œè¯¥å‡½æ•°ç”¨æ¥ new ä¸€ä¸ª ConditionObject å¯¹è±¡ã€‚éœ€è¦ç”± AQS çš„å®ç°æ¥æä¾› `newCondition` å‡½æ•°ã€‚

> ä¸€èˆ¬è¦å®ç°ä¸€ä¸ªåŒæ­¥ç±»ï¼Œéƒ½å›å»å®ç° Lock æ¥å£ï¼ŒLock æ¥å£æœ‰æŠ½è±¡çš„ newConditionã€lockã€unlock ç­‰æ–¹æ³•ã€‚ç„¶åå®ç°ä¸€ä¸ªå†…éƒ¨ç±»æ¥ç»§æ‰¿ AQSï¼Œå¹¶å®ç° newCondition æ–¹æ³•ï¼Œä¾›å¤–éƒ¨ç±»æ¥è°ƒç”¨ã€‚

#### addConditionWaiter

ä¸‹é¢æ¥çœ‹å½“ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•è€Œè¢«é˜»å¡åï¼Œå¦‚ä½•å°†å…¶æ”¾å…¥æ¡ä»¶é˜Ÿåˆ— ã€‚

        private Node addConditionWaiter() {  
            Node t = lastWaiter;  
            // If lastWaiter is cancelled, clean out.  
            if (t != null && t.waitStatus != Node.CONDITION) {  
                unlinkCancelledWaiters();  
                t = lastWaiter;  
            }  
            Node node = new Node(Thread.currentThread(), Node.CONDITION);  
            if (t == null)  
                firstWaiter = node;  
            else  
                t.nextWaiter = node;  
            lastWaiter = node;  
            return node;  
        }

æ³¨æ„ï¼šå½“å¤šä¸ªçº¿ç¨‹åŒæ—¶è°ƒç”¨ lock.lock() æ–¹æ³•è·å–é”æ—¶ï¼Œåªæœ‰ä¸€ä¸ªçº¿ç¨‹è·å–åˆ°äº†é”ï¼Œå…¶ä»–çº¿ç¨‹ä¼šè¢«è½¬æ¢ä¸º Node èŠ‚ç‚¹æ’å…¥åˆ° lock é”å¯¹åº”çš„ AQS é˜»å¡é˜Ÿåˆ—é‡Œé¢ï¼Œå¹¶åšè‡ªæ—‹ CAS å°è¯•è·å–é”ã€‚

å¦‚æœè·å–åˆ°é”çš„çº¿ç¨‹åˆè°ƒç”¨äº†å¯¹åº”çš„æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•ï¼Œåˆ™è¯¥çº¿ç¨‹ä¼šé‡Šæ”¾è·å–åˆ°çš„é”ï¼Œå¹¶è¢«è½¬æ¢ä¸º Node èŠ‚ç‚¹æ’å…¥åˆ°æ¡ä»¶å˜é‡å¯¹åº”çš„æ¡ä»¶é˜Ÿåˆ—é‡Œé¢ ã€‚

è¿™æ—¶å€™å› ä¸ºè°ƒç”¨ lock.lock() æ–¹æ³•è¢«é˜»å¡åˆ° AQS é˜Ÿåˆ—é‡Œé¢çš„ä¸€ä¸ªçº¿ç¨‹ä¼šè·å–åˆ°è¢«é‡Šæ”¾çš„é”ï¼Œå¦‚æœè¯¥çº¿ç¨‹ä¹Ÿè°ƒç”¨äº†æ¡ä»¶å˜é‡çš„ await() æ–¹æ³•åˆ™è¯¥çº¿ç¨‹ä¹Ÿä¼šè¢«æ”¾å…¥æ¡ä»¶å˜é‡çš„æ¡ä»¶é˜Ÿåˆ—é‡Œé¢ã€‚

å½“å¦å¤–ä¸€ä¸ªçº¿ç¨‹è°ƒç”¨æ¡ä»¶å˜é‡çš„ `signal()` æˆ–è€… `signalAll()` æ–¹æ³•æ—¶ï¼Œä¼šæŠŠæ¡ä»¶é˜Ÿåˆ—é‡Œé¢çš„ä¸€ä¸ªæˆ–è€…å…¨éƒ¨ NodeèŠ‚ç‚¹ç§»åŠ¨åˆ° AQS çš„é˜»å¡é˜Ÿåˆ—é‡Œé¢ï¼Œ**ç­‰å¾…æ—¶æœºè·å–é”**ã€‚

ä¸‹å›¾è¯´æ˜äº†ï¼š ä¸€ä¸ªé”å¯¹åº”ä¸€ä¸ª AQS é˜»å¡é˜Ÿåˆ—ï¼Œå¯¹åº”å¤šä¸ªæ¡ä»¶å˜é‡ï¼Œ æ¯ä¸ªæ¡ä»¶å˜é‡æœ‰è‡ªå·±çš„ä¸€ä¸ªæ¡ä»¶é˜Ÿåˆ—ã€‚

![Screen Shot 2021-06-12 at 14.17.23](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-12%20at%2014.17.23.png)

### åŸºäº AQS å®ç°è‡ªå®šä¹‰åŒæ­¥å™¨

å®ç°ä¸€ä¸ªä¸å¯é‡å…¥ç‹¬å é”ã€‚å®šä¹‰ state = 0 è¡¨ç¤ºç›®å‰æ²¡æœ‰é”è¢«çº¿ç¨‹æŒæœ‰ï¼Œstate = 1 è¡¨ç¤ºæœ‰ä¸€ä¸ªçº¿ç¨‹æŒæœ‰é”ï¼Œstate ä¸ä¼šå¤§äº 1ã€‚

NonReentrantLock å®šä¹‰äº†ä¸€ä¸ªå†…éƒ¨ç±» Sync ç”¨æ¥å®ç°å…·ä½“çš„é”çš„æ“ä½œï¼ŒSync åˆ™ç»§æ‰¿äº† AQSã€‚ç”±äºæˆ‘ä»¬ ç°çš„æ˜¯ç‹¬å æ¨¡å¼çš„é”ï¼Œæ‰€ ä»¥ Sync é‡å†™äº† tryAcquireã€ tryRelease å’Œ isHeldExclusively 3 ä¸ªæ–¹æ³•ã€‚å¦å¤–ï¼ŒSync æä¾›äº† newCondition è¿™ä¸ªæ–¹æ³•ç”¨æ¥æ”¯æŒæ¡ä»¶å˜é‡ã€‚

public class NonReentrantLock implements Lock, Serializable {  
    private static class Sync extends AbstractQueuedSynchronizer {  
        @Override  
        protected boolean isHeldExclusively() {  
            return getState() == 1;  
        }  
  
        @Override  
        protected boolean tryAcquire(int acquires) {  
            assert acquires == 1;  
            if (compareAndSetState(0, 1)) {  
                setExclusiveOwnerThread(Thread.currentThread());  
                return true;  
            }  
            return false;  
        }  
  
        @Override  
        protected boolean tryRelease(int releases) {  
            assert releases == 1;  
            if (getState() == 0) {  
                throw new IllegalMonitorStateException();  
            }  
            setExclusiveOwnerThread(null);  
            setState(0);  
            return true;  
        }  
  
        Condition newCondition() {  
            return new ConditionObject();  
        }  
    }  
  
    private final Sync sync = new Sync();  
      
    @Override  
    public void lock() {  
        sync.acquire(1);  
    }  
  
    @Override  
    public boolean tryLock() {  
        return sync.tryAcquire(1);  
    }  
  
    @Override  
    public void unlock() {  
        sync.release(1);  
    }  
  
    @Override  
    public Condition newCondition() {  
        return sync.newCondition();  
    }  
  
    public boolean isLocked() {  
        return sync.isHeldExclusively();  
    }  
  
    @Override  
    public void lockInterruptibly() throws InterruptedException {  
        sync.acquireInterruptibly(1);  
    }  
      
    @Override  
    public boolean tryLock(long time, TimeUnit unit) throws InterruptedException {  
        return sync.tryAcquireNanos(1, unit.toNanos(time));  
    }  
}

#### ä½¿ç”¨ NonReentrantLock å®ç°ç”Ÿäº§-æ¶ˆè´¹æ¨¡å‹

	final static NonReentrantLock lock = new NonReentrantLock();  
    final static Condition notFull = lock.newCondition();  
    final static Condition notEmpty = lock.newCondition();  
  
    final static Queue<String> queue = new LinkedBlockingQueue<>();  
    final static int queueSize = 10;  
  
    public static void main(String[] args) {  
        Thread producer = new Thread(() -> {  
            lock.lock();  
            try {  
                while (queue.size() == queueSize) {  
                    notEmpty.await();  
                }  
                queue.add("ele");  
                notFull.signalAll();  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                lock.unlock();  
            }  
        });  
  
        Thread consumer = new Thread(() -> {  
            lock.lock();  
            try {  
                while (0 == queue.size()) {  
                    notFull.await();  
                }  
                String ele = queue.poll();  
                System.out.println(ele);  
                notEmpty.signalAll();  
            } catch (Exception e) {  
                e.printStackTrace();  
            } finally {  
                lock.unlock();  
            }  
        });  
  
        producer.start();  
        consumer.start();  
    }

è¿™é‡Œ `notEmpty` å’Œ `notFull` åº”è¯¥åˆ†åˆ«æŒ‡çš„æ˜¯ã€Œæ»¡ã€å’Œã€Œç©ºã€ã€‚

ä½¿ç”¨ while è€Œä¸æ˜¯ if æ˜¯ä¸ºäº†é¿å…è™šå‡å”¤é†’ã€‚

## 6.3 ç‹¬å é” ReentrantLock åŸç†

### ç±»å›¾

![image-20210612144357143](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612144357143.png)

ReentrantLock æœ€ç»ˆè¿˜æ˜¯ä½¿ç”¨ AQS æ¥å®ç°çš„ï¼Œå¹¶ä¸”æ ¹æ®å‚æ•°æ¥å†³å®šå…¶å†…éƒ¨æ˜¯ä¸€ä¸ªå…¬å¹³è¿˜æ˜¯éå…¬å¹³é”ï¼Œé»˜è®¤æ˜¯éå…¬å¹³é”ã€‚

	public ReentrantLock() {  
        sync = new NonfairSync();  
    }  
  
    public ReentrantLock(boolean fair) {  
        sync = fair ? new FairSync() : new NonfairSync();  
    }

å…¶ä¸­ Sync ç±»ç»§æ‰¿è‡ª AQSï¼Œå®ƒçš„å­ç±» NonfairSync å’Œ FairSync åˆ†åˆ«å®ç°äº†è·å–é”çš„éå…¬å¹³ä¸å…¬å¹³ç­–ç•¥ ã€‚

> ä¸å¯é‡å…¥é”ï¼Œå¦‚æœçº¿ç¨‹å°è¯•åœ¨å·²è·å¾—é”çš„æƒ…å†µä¸‹å†å»è·å¾—é”ï¼Œä¼šé˜»å¡è‡ªå·±ï¼Œå…·ä½“çœ‹ NonReentrantLock çš„ tryAcquire æ–¹æ³•ã€‚

### è·å–é”

#### void lock()

å½“ä¸€ä¸ªçº¿ç¨‹ç¬¬ä¸€æ¬¡è·å–è¯¥é”æ—¶ä¼šå°è¯•ä½¿ç”¨ CAS è®¾ç½® state çš„å€¼ä¸º 1ï¼Œå¦‚æœ CAS æˆåŠŸåˆ™å½“å‰çº¿ç¨‹è·å–äº†è¯¥é”ï¼Œç„¶åè®°å½•è¯¥é”çš„æŒæœ‰è€…ä¸ºå½“å‰çº¿ç¨‹ã€‚åœ¨è¯¥çº¿ç¨‹æ²¡æœ‰é‡Šæ”¾é”çš„æƒ…å†µä¸‹ç¬¬äºŒæ¬¡è·å–è¯¥é”åï¼ŒçŠ¶æ€å€¼è¢«è®¾ç½®ä¸º 2ã€‚åœ¨è¯¥çº¿ç¨‹é‡Šæ”¾è¯¥é”æ—¶ï¼Œä¼šå°è¯•ä½¿ç”¨ CAS è®©çŠ¶æ€å€¼å‡ 1ï¼Œ å¦‚æœå‡ 1 åçŠ¶æ€å€¼ä¸º 0ï¼Œåˆ™å½“å‰çº¿ç¨‹é‡Šæ”¾è¯¥é”ã€‚

	public void lock() {  
        sync.lock();  
    }

Sync æ˜¯æŠ½è±¡ç±»ï¼Œlock æ˜¯æŠ½è±¡æ–¹æ³•ï¼Œå…ˆçœ‹ NonfairSync çš„å®ç°ï¼š

	final void lock() {  
		if (compareAndSetState(0, 1))  
            setExclusiveOwnerThread(Thread.currentThread());  
        else  
            acquire(1);  
    }  
  
	protected final boolean tryAcquire(int acquires) {  
        return nonfairTryAcquire(acquires);  
    }  
	  
	final boolean nonfairTryAcquire(int acquires) {  
        final Thread current = Thread.currentThread();  
        int c = getState();  
        // ä¸ªäººç†è§£ï¼šå…ˆåˆ¤æ–­æ˜¯å¦ä¸º 0ï¼Œå¯ä»¥é¿å…å¾ˆå¤šæ¬¡ CAS æ“ä½œ  
        if (c == 0) {  
            // é˜²æ­¢æ­¤æ—¶å…¶ä»–çº¿ç¨‹æå‰è·å¾—é”  
            if (compareAndSetState(0, acquires)) {  
                setExclusiveOwnerThread(current);  
                return true;  
            }  
        }  
        // è¯¥çº¿ç¨‹å·²ç»æœ‰é”äº†ï¼Œå°±ä¸éœ€è¦ä½¿ç”¨ CAS äº†  
        else if (current == getExclusiveOwnerThread()) {  
            int nextc = c + acquires;  
            if (nextc < 0) // overflow  
                throw new Error("Maximum lock count exceeded");  
            setState(nextc);  
            return true;  
        }  
        return false;  
    }  
  
	// è´´å‡º AQS çš„ acquire  
    public final void acquire(int arg) {  
        if (!tryAcquire(arg) &&  
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  
            selfInterrupt();  
    }

éå…¬å¹³çš„ä½“ç°ï¼š

é¦–å…ˆå‡è®¾æ­¤æ—¶é”è¢«çº¿ç¨‹ A å æœ‰ï¼Œçº¿ç¨‹ B æœ€ç»ˆè°ƒç”¨ nonfairTryAcquire è¿”å› false ç„¶åè¢«æ”¾å…¥ AQS é˜»å¡é˜Ÿåˆ—ã€‚ä¹‹åçº¿ç¨‹ C è°ƒç”¨ nonfairTryAcquire æ—¶ï¼Œçº¿ç¨‹ A æ­£å¥½é‡Šæ”¾äº†é”ï¼ŒC å¯ä»¥é¡ºåˆ©è·å¾—é”ï¼Œè¿™å°±æ˜¯ä¸å…¬å¹³çš„ä½“ç°ã€‚å› ä¸ºçº¿ç¨‹ C åœ¨è·å–é”çš„æ—¶å€™å¹¶æ²¡æœ‰æŸ¥çœ‹å½“å‰ AQS é˜Ÿåˆ—é‡Œæ˜¯å¦æœ‰æ¯”è‡ªå·±æ›´æ—©è¯·æ±‚è¯¥é”çš„çº¿ç¨‹ã€‚

ç„¶åæ˜¯ FairSync çš„å®ç°ï¼š

	final void lock() {  
		acquire(1);  
	}  
  
	protected final boolean tryAcquire(int acquires) {  
        final Thread current = Thread.currentThread();  
        int c = getState();  
        if (c == 0) {  
            if (!hasQueuedPredecessors() &&  
                compareAndSetState(0, acquires)) {  
                setExclusiveOwnerThread(current);  
                return true;  
            }  
        }  
        else if (current == getExclusiveOwnerThread()) {  
            int nextc = c + acquires;  
            if (nextc < 0)  
                throw new Error("Maximum lock count exceeded");  
            setState(nextc);  
            return true;  
        }  
        return false;  
    }  
  
	// AQS  
    public final boolean hasQueuedPredecessors() {  
        // The correctness of this depends on head being initialized  
        // before tail and on head.next being accurate if the current  
        // thread is first in queue.  
        Node t = tail; // Read fields in reverse initialization order  
        Node h = head;  
        Node s;  
        return h != t &&  
            ((s = h.next) == null || s.thread != Thread.currentThread());  
    }

FairSync åœ¨ CAS æ“ä½œä¹‹å‰å¤šäº†AQS å®ç°çš„ `hasQueuedPredecessors` æ–¹æ³•ã€‚

-   å¦‚æœ h==t åˆ™è¯´æ˜å½“å‰é˜Ÿåˆ—ä¸ºç©ºï¼Œç›´æ¥è¿”å› falseï¼›
    
-   å¦‚æœ h!=t å¹¶ä¸” s==null åˆ™è¯´æ˜æœ‰ä¸€ä¸ªå…ƒç´ å°†è¦ä½œä¸º AQS çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å…¥é˜Ÿåˆ—ï¼ˆå›é¡¾å‰é¢çš„å†…å®¹ï¼Œenq å‡½æ•°çš„ç¬¬ä¸€ä¸ªå…ƒç´ å…¥é˜Ÿåˆ—æ˜¯ä¸¤æ­¥æ“ä½œï¼šé¦–å…ˆåˆ›å»ºä¸€ä¸ªå“¨å…µå¤´èŠ‚ç‚¹ï¼Œç„¶åå°†ç¬¬ä¸€ä¸ªå…ƒç´ æ’å…¥å“¨å…µèŠ‚ç‚¹åé¢ï¼‰ï¼Œé‚£ä¹ˆè¿”å› trueï¼›
    
-   å¦‚æœ h!=t å¹¶ä¸” s!=null å’Œ s.thread != Thread.cunentThread() åˆ™è¯´æ˜é˜Ÿåˆ—é‡Œé¢çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¸æ˜¯å½“å‰çº¿ç¨‹ï¼Œé‚£ä¹ˆè¿” å› trueã€‚
    

#### void lockInterruptibly()

    public void lockInterruptibly() throws InterruptedException {  
        sync.acquireInterruptibly(1);  
    }  
  
	public final void acquireInterruptibly(int arg) throws InterruptedException {  
        if (Thread.interrupted())  
            throw new InterruptedException();  
        if (!tryAcquire(arg))  
            doAcquireInterruptibly(arg);  
    }

#### void tryLock()

å°è¯•è·å–é”ï¼Œå¦‚æœå½“å‰è¯¥é”æ²¡æœ‰è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰ï¼Œåˆ™å½“å‰çº¿ç¨‹è·å–è¯¥é”äº•è¿”å› trueï¼Œå¦åˆ™è¿”å› falseã€‚è¯¥æ–¹æ³•ä¸ä¼šå¼•èµ·å½“å‰çº¿ç¨‹é˜»å¡ã€‚tryLock() ä½¿ç”¨éå…¬å¹³ç­–ç•¥ã€‚

    public boolean tryLock() {  
        return sync.nonfairTryAcquire(1);  
    }

#### boolean tryLock(long timeout, TimeUnit unit)

å¦‚æœè¶…æ—¶æ—¶é—´åˆ°äº†æ²¡æœ‰è·å–åˆ°é”åˆ™è¿”å› falseã€‚

    public boolean tryLock(long timeout, TimeUnit unit)  
            throws InterruptedException {  
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));  
    }

### é‡Šæ”¾é”

#### void unlock()

    public void unlock() {  
        sync.release(1);  
    }  
  
	// AQS  
    public final boolean release(int arg) {  
        if (tryRelease(arg)) {  
            Node h = head;  
            if (h != null && h.waitStatus != 0)  
                unparkSuccessor(h);  
            return true;  
        }  
        return false;  
    }  
	          
	protected final boolean tryRelease(int releases) {  
        int c = getState() - releases;  
        if (Thread.currentThread() != getExclusiveOwnerThread())  
            throw new IllegalMonitorStateException();  
        boolean free = false;  
        if (c == 0) {  
            free = true;  
            setExclusiveOwnerThread(null);  
        }  
        setState(c);  
        return free;  
    }

### æ¡ˆä¾‹

ä½¿ç”¨ ReentrantLock å®ç°çº¿ç¨‹å®‰å…¨çš„ Listã€‚

public class ReentrantLockList {  
    private ArrayList<String> array = new ArrayList<>();  
    private volatile ReentrantLock lock = new ReentrantLock();  
  
    public void add(String e) {  
        lock.lock();  
        try { array.add(e); }   
        finally { lock.unlock(); }  
    }  
  
    public void remove(String e) {  
        lock.lock();  
        try { array.remove(e); }   
        finally { lock.unlock(); }  
    }  
  
    public String get(int index) {  
        lock.lock();  
        try { return array.get(index); }   
        finally { lock.unlock(); }  
    }  
}  

## 6.4 ReentrantReadWriteLock

é€‚åˆ ReentrantLock æ•ˆç‡ä½çš„è¯»å¤šå†™å°‘åœºæ™¯ï¼ŒReentrantReadWriteLock é‡‡ç”¨è¯»å†™åˆ†ç¦»çš„ç­–ç•¥ã€‚

### ç±»å›¾

![image-20210612163225016](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612163225016.png)

è¯»å†™é”çš„å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ª ReadLock å’Œä¸€ä¸ª WriteLockï¼Œå®ƒä»¬ä¾èµ– Sync å®ç°å…·ä½“åŠŸèƒ½ã€‚è€Œ Sync ç»§æ‰¿è‡ªAQSï¼Œå¹¶ä¸”ä¹Ÿæä¾›äº†å…¬å¹³å’Œéå…¬å¹³çš„å®ç°ã€‚ä¸‹é¢åªä»‹ç»éå…¬å¹³çš„è¯»å†™é”å®ç°ã€‚

	// Sync  
	static final int SHARED_SHIFT   = 16;  
	// å…±äº«é”ï¼ˆè¯»é”ï¼‰çŠ¶æ€å•ä½å€¼ 65536  
    static final int SHARED_UNIT    = (1 << SHARED_SHIFT);  
	// å…±äº«é”çº¿ç¨‹æœ€å¤§ä¸ªæ•° 65535  
    static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;  
	// æ’ä»–é”ï¼ˆå†™é”ï¼‰æ©ç ï¼ŒäºŒè¿›åˆ¶ï¼Œ15 ä¸ª 1  
    static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;  
  
    /** è¿”å›è¯»é”çº¿ç¨‹æ•°  */  
    static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }  
    /** è¿”å›å†™é”å¯é‡å…¥ä¸ªæ•°  */  
    static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }

Sync ä¸­æœ‰ä¸ª Thread firstReader å˜é‡æ¥è®°å½•ç¬¬ä¸€ä¸ªè·å–åˆ°è¯»é”çš„çº¿ç¨‹ï¼›int firstReaderHoldCount è®°å½•ç¬¬ä¸€ä¸ªè·å–åˆ°è¯»é”çš„çº¿ç¨‹å¯é‡å…¥æ¬¡æ•°ï¼›HoldCounter cachedHoldCounter å˜é‡æ¥è®°å½•æœ€åä¸€ä¸ªè·å–è¯»é”çš„çº¿ç¨‹ï¼›ThreadLocalHoldCounter readHolds ç”¨æ¥è®°å½•é™¤äº†ç¬¬ä¸€ä¸ªè·å–è¯»é”çº¿ç¨‹å¤–å…¶ä»–è·å–è¯»é”çš„çº¿ç¨‹å¯é‡å…¥æ¬¡æ•°ã€‚

HoldCounter å’Œ ThreadLocalHoldCounter æ˜¯ Sync çš„å†…éƒ¨ç±»ã€‚

	static final class HoldCounter {  
        int count = 0;  
        // Use id, not reference, to avoid garbage retention  
        final long tid = getThreadId(Thread.currentThread());  
    }  
  
	static final class ThreadLocalHoldCounter extends ThreadLocal<HoldCounter> {  
        public HoldCounter initialValue() {  
            return new HoldCounter();  
        }  
    }

### å†™é”çš„è·å–ä¸é‡Šæ”¾

å†™é”ä½¿ç”¨ WriteLock å®ç°ã€‚

#### void lock()

å†™é”æ˜¯ä¸ªç‹¬å é”ï¼ŒæŸæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–è¯¥é”ã€‚å¦‚æœå½“å‰æ²¡æœ‰çº¿ç¨‹è·å–åˆ°è¯»é”å’Œå†™é”ï¼Œåˆ™å½“å‰çº¿ç¨‹å¯ä»¥è·å–åˆ°å†™é”ç„¶åè¿”å›ã€‚ å¦‚æœå½“å‰å·±ç»æœ‰çº¿ç¨‹è·å–åˆ°è¯»é”æˆ–å†™é”ï¼Œåˆ™å½“å‰è¯·æ±‚å†™é”çš„çº¿ç¨‹ä¼šè¢«é˜»å¡æŒ‚èµ·ã€‚å†™é”æ˜¯å¯é‡å…¥é”ã€‚

// WriteLock  
public void lock() {  
    sync.acquire(1);  
}  
  
// Sync  
protected final boolean tryAcquire(int acquires) {  
    Thread current = Thread.currentThread();  
    int c = getState();  
    int w = exclusiveCount(c);  
    // c!=0 è¯´æ˜æœ‰çº¿ç¨‹è·å¾—é”  
    if (c != 0) {  
        // w==0 è¯´æ˜æœ‰çº¿ç¨‹è·å¾—äº†è¯»é”ï¼ˆæ­¤æ—¶ state ä½ 16 ä½ä¸º 0ï¼‰  
        // w!=0 è¯´æ˜æœ‰çº¿ç¨‹è·å¾—äº†å†™é”ï¼Œç„¶ååˆ¤æ–­æ˜¯ä¸æ˜¯å½“å‰çº¿ç¨‹è·å¾—çš„  
        if (w == 0 || current != getExclusiveOwnerThread())  
            return false;  
        if (w + exclusiveCount(acquires) > MAX_COUNT)  
            throw new Error("Maximum lock count exceeded");  
        // è®¾ç½®å¯é‡å…¥æ¬¡æ•°ï¼ˆä¸éœ€è¦ CASï¼‰  
        setState(c + acquires);  
        return true;  
    }  
    // åˆ°è¿™é‡Œè¯´æ˜å½“å‰æ²¡æœ‰çº¿ç¨‹è·å¾—é”  
    if (writerShouldBlock() ||  
        !compareAndSetState(c, c + acquires))  
        return false;  
    setExclusiveOwnerThread(current);  
}

writeShouldBolck æ˜¯ Sync çš„æŠ½è±¡æ–¹æ³•ï¼ŒNonfairSync çš„å®ç°ï¼š

final boolean writerShouldBlock() {  
    return false; // writers can always barge  
}

FairSync çš„å®ç°ï¼š

final boolean writerShouldBlock() {  
    return hasQueuedPredecessors();  
}

#### void lockInterruptibly()

// WriteLock  
public void lockInterruptibly() throws InterruptedException {  
    sync.acquireInterruptibly(1);  
}

#### boolean tryLock()

// WriteLock  
public boolean tryLock() {  
    return sync.tryWriteLock();  
}  
  
// Sync  
final boolean tryWriteLock() {  
    Thread current = Thread.currentThread();  
    int c = getState();  
    if (c != 0) {  
        int w = exclusiveCount(c);  
        if (w == 0 || current != getExclusiveOwnerThread())  
            return false;  
        if (w == MAX_COUNT)  
            throw new Error("Maximum lock count exceeded");  
    }  
    if (!compareAndSetState(c, c + 1))  
        return false;  
    setExclusiveOwnerThread(current);  
    return true;  
}

è¿™é‡Œ tryWriteLock å’Œ tryAcquire ç±»ä¼¼ï¼Œä½† tryWriteLock ä½¿ç”¨äº†éå…¬å¹³ç­–ç•¥ã€‚

#### boolean tryLock(long timeout, TimeUnit unit)

é™¤äº†æœ‰è¶…æ—¶ä¹‹å¤–ï¼Œè¯¥æ–¹æ³•ä¼šå¯¹ä¸­æ–­è¿›è¡Œå“åº”ï¼Œä¹Ÿå°±æ˜¯å½“å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†è¯¥çº¿ç¨‹çš„ interrupt() æ–¹æ³•ä¸­æ–­äº†å½“å‰çº¿ç¨‹æ—¶ï¼Œå½“å‰çº¿ç¨‹ä¼šæŠ›å‡º InterruptedException å¼‚å¸¸ã€‚

// WriteLock  
public boolean tryLock(long timeout, TimeUnit unit)  
    		throws InterruptedException {  
    return sync.tryAcquireNanos(1, unit.toNanos(timeout));  
}

#### void unlock()

// WriteLock  
public void unlock() {  
    sync.release(1);  
}  
  
// Sync  
protected final boolean tryRelease(int releases) {  
    // æ£€æŸ¥æ˜¯å¦æ˜¯å†™é”æ‹¥æœ‰è€…è°ƒç”¨çš„ unlock  
    if (!isHeldExclusively())  
        throw new IllegalMonitorStateException();  
    // æ²¡æœ‰è€ƒè™‘é«˜ 16 ä½ï¼Œå› ä¸ºè·å–å†™é”æ—¶è¯»é”çŠ¶æ€å€¼è‚¯å®šå…¨ä¸º 0  
    int nextc = getState() - releases;  
    boolean free = exclusiveCount(nextc) == 0;  
    if (free)  
        setExclusiveOwnerThread(null);  
    setState(nextc);  
    return free;  
}

### è¯»é”çš„è·å–å’Œé‡Šæ”¾

è¯»é”ä½¿ç”¨ ReadLock æ¥å®ç°ã€‚

#### void lock()

// ReadLock  
public void lock() {  
    sync.acquireShared(1);  
}  
  
// AQS  
public final void acquireShared(int arg) {  
    if (tryAcquireShared(arg) < 0)  
        doAcquireShared(arg);  
}  
  
// Sync  
protected final int tryAcquireShared(int unused) {  
    Thread current = Thread.currentThread();  
    int c = getState();  
    // åˆ¤æ–­ 1.å½“å‰æ˜¯å¦å†™é”ï¼Œ2.å¦‚æœæœ‰å†™é”ï¼Œåˆ¤æ–­å†™é”æ‹¥æœ‰è€…æ˜¯ä¸æ˜¯zi j  
    if (exclusiveCount(c) != 0 &&  
        getExclusiveOwnerThread() != current)  
        return -1;  
      
    int r = sharedCount(c);  
    if (!readerShouldBlock() &&  
        r < MAX_COUNT &&  
        // æŠ¢å å¼å°† state é«˜ 16 ä½åŠ  1  
        compareAndSetState(c, c + SHARED_UNIT)) {  
        if (r == 0) {  
            firstReader = current;  
            firstReaderHoldCount = 1;  
        } else if (firstReader == current) {  
            firstReaderHoldCount++;  
        } else {  
            HoldCounter rh = cachedHoldCounter;  
            // rh == null è¯´æ˜å½“å‰åªæœ‰ä¸€ä¸ª firstReader  
            // ç¬¬äºŒä¸ªæ¡ä»¶è¯´æ˜å½“å‰çº¿ç¨‹ä¸æ˜¯æœ€åä¸€ä¸ªè·å¾—è¯»é”çš„çº¿ç¨‹  
            // æ»¡è¶³æ¡ä»¶ååˆå§‹åŒ– cachedHoldCounter  
            if (rh == null || rh.tid != getThreadId(current))  
                cachedHoldCounter = rh = readHolds.get();  
            // TODOï¼šè¿™é‡Œæ²¡æ˜ç™½ï¼Œè·å¾—ç„¶åé‡Šæ”¾è¯»é”çš„çº¿ç¨‹å†è·å–çš„æ—¶å€™ï¼Œrh.count == 0ï¼Ÿ  
            else if (rh.count == 0)  
                readHolds.set(rh);  
            rh.count++;  
        }  
        return 1;  
    }  
    //  ç±»ä¼¼ tryAcquireSharedï¼Œä½†æ˜¯æ˜¯è‡ªæ—‹è·å–ï¼Œä»£ç åœ¨ä¸‹é¢  
    return fullTryAcquireShared(current);  
}  
  

åŒæ ·ï¼ŒreaderShouldBlock æ˜¯ Sync æä¾›çš„æŠ½è±¡æ–¹æ³•ï¼ŒNonfairSync çš„å®ç°ï¼š

// NonfairSync  
final boolean readerShouldBlock() {  
    return apparentlyFirstQueuedIsExclusive();  
}  
  
// AQS  
// å¦‚æœé˜Ÿåˆ—éç©ºï¼Œåˆ¤æ–­ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯ä¸æ˜¯æ­£åœ¨å°è¯•è·å¾—å†™é”  
final boolean apparentlyFirstQueuedIsExclusive() {  
    Node h, s;  
    return (h = head) != null &&	// å¦‚æœé˜Ÿåˆ—è¿˜æ²¡æ·»åŠ è¿‡å…ƒç´   
        (s = h.next)  != null &&	// å¦‚æœé˜Ÿåˆ—éç©º  
        !s.isShared()         &&	// å¦‚æœé˜Ÿåˆ—ç¬¬ä¸€ä¸ªå…ƒç´ è¯•å›¾è·å–å†™é”  
        s.thread != null;			// å¦‚æœç¬¬ä¸€ä¸ªå…ƒç´ å†…éƒ¨è®°å½•äº† thread  
}

// Sync   
final int fullTryAcquireShared(Thread current) {  
    HoldCounter rh = null;  
    for (;;) {  
        int c = getState();  
        if (exclusiveCount(c) != 0) {  
            if (getExclusiveOwnerThread() != current)  
                return -1;  
            // else we hold the exclusive lock; blocking here  
            // would cause deadlock.  
        } else if (readerShouldBlock()) {  
            // Make sure we're not acquiring read lock reentrantly  
            if (firstReader == current) {  
                // assert firstReaderHoldCount > 0;  
            } else {  
                if (rh == null) {  
                    rh = cachedHoldCounter;  
                    if (rh == null || rh.tid != getThreadId(current)) {  
                        rh = readHolds.get();  
                        if (rh.count == 0)  
                            readHolds.remove();  
                    }  
                }  
                if (rh.count == 0)  
                    return -1;  
            }  
        }  
        if (sharedCount(c) == MAX_COUNT)  
            throw new Error("Maximum lock count exceeded");  
        if (compareAndSetState(c, c + SHARED_UNIT)) {  
            if (sharedCount(c) == 0) {  
                firstReader = current;  
                firstReaderHoldCount = 1;  
            } else if (firstReader == current) {  
                firstReaderHoldCount++;  
            } else {  
                if (rh == null)  
                    rh = cachedHoldCounter;  
                if (rh == null || rh.tid != getThreadId(current))  
                    rh = readHolds.get();  
                else if (rh.count == 0)  
                    readHolds.set(rh);  
                rh.count++;  
                cachedHoldCounter = rh; // cache for release  
            }  
            return 1;  
        }  
    }  
}

#### void lockInterruptibly()

public void lockInterruptibly() throws InterruptedException {  
    sync.acquireSharedInterruptibly(1);  
}

#### boolean tryLock()

å¦‚æœå½“å‰å·±ç»æœ‰å…¶ä»–çº¿ç¨‹æŒæœ‰å†™é”åˆ™è¯¥æ–¹æ³•ç›´æ¥è¿”å› falseï¼Œä½†å½“å‰çº¿ç¨‹å¹¶ä¸ä¼šè¢«é˜»å¡ã€‚å¦‚æœå½“å‰çº¿ç¨‹å·±ç»æŒæœ‰äº†è¯¥è¯»é”åˆ™ç®€å•å¢åŠ  AQS çš„çŠ¶æ€å€¼é«˜ 16 ä½åç›´æ¥è¿”å› trueã€‚

public boolean tryLock() {  
    return sync.tryReadLock();  
}

#### boolean tryLock(long timeout, TimeUnit unit)

é™¤äº†æœ‰è¶…æ—¶ä¹‹å¤–ï¼Œè¯¥æ–¹æ³•ä¼šå¯¹ä¸­æ–­è¿›è¡Œå“åº”ï¼Œä¹Ÿå°±æ˜¯å½“å…¶ä»–çº¿ç¨‹è°ƒç”¨äº†è¯¥çº¿ç¨‹çš„ interrupt() æ–¹æ³•ä¸­æ–­äº†å½“å‰çº¿ç¨‹æ—¶ï¼Œå½“å‰çº¿ç¨‹ä¼šæŠ›å‡º InterruptedException å¼‚å¸¸ã€‚

// ReadLock    
public boolean tryLock(long timeout, TimeUnit unit)  
    	throws InterruptedException {  
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));  
}

#### void unlock()

// ReadLock  
public void unlock() {  
    sync.releaseShared(1);  
}  
  
// AQS  
public final boolean releaseShared(int arg) {  
    if (tryReleaseShared(arg)) { // å¦‚æœè¿”å› trueï¼Œé€šè¿‡ doReleaseShared  
        doReleaseShared();		 // é‡Šæ”¾ä¸€ä¸ªå› å†™é”é˜»å¡çš„çº¿ç¨‹  
        return true;  
    }  
    return false;  
}  
  
// Sync  
protected final boolean tryReleaseShared(int unused) {  
    Thread current = Thread.currentThread();  
    if (firstReader == current) {  
        // assert firstReaderHoldCount > 0;  
        if (firstReaderHoldCount == 1)  
            firstReader = null;  
        else  
            firstReaderHoldCount--;  
    } else {  
        HoldCounter rh = cachedHoldCounter;  
        if (rh == null || rh.tid != getThreadId(current))  
            rh = readHolds.get();  
        int count = rh.count;  
        if (count <= 1) {  
            readHolds.remove();  
            if (count <= 0)  
                throw unmatchedUnlockException();  
        }  
        --rh.count;  
    }  
    // å¾ªç¯ç›´åˆ°å¯ä»¥è®©è‡ªå·±çš„è¯»è®¡æ•° -1  
    for (;;) {  
        int c = getState();  
        int nextc = c - SHARED_UNIT;  
        if (compareAndSetState(c, nextc))  
            return nextc == 0;  
    }  
}

### æ¡ˆä¾‹

public class ReentrantLockList {  
    private ArrayList<String> array = new ArrayList<>();  
    private volatile ReentrantReadWriteLock lock = new ReentrantReadWriteLock();  
    private final Lock readLock = lock.readLock();  
    private final Lock writeLock = lock.writeLock();  
  
    public void add(String e) {  
        writeLock.lock();  
        try { array.add(e); }   
        finally { writeLock.unlock(); }  
    }  
  
    public void remove(String e) {  
        writeLock.lock();  
        try { array.remove(e); }   
        finally { writeLock.unlock(); }  
    }  
  
    public String get(int index) {  
        readLock.lock();  
        try { return array.get(index); }   
        finally { readLock.unlock(); }  
    }  
}

![image-20210612204041143](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612204041143.png)

## 6.5 StampedLock

### æ¦‚è¿°

StampedLock æ˜¯ JDK8 æ–°å¢çš„ï¼Œæä¾›äº†ä¸‰ç§æ¨¡å¼çš„è¯»å†™æ§åˆ¶ï¼Œå½“è°ƒç”¨è·å–é”çš„ç³»åˆ—å‡½æ•°æ—¶ï¼Œä¼šè¿”å›ä¸€ä¸ª long å‹çš„å˜é‡ï¼Œç§°ä¹‹ä¸ºæˆ³è®°ï¼ˆstampï¼‰ï¼Œè¿™ä¸ªæˆ³è®°ä»£è¡¨äº†é”çš„çŠ¶æ€ã€‚å…¶ä¸­ try ç³»åˆ—è·å–é”çš„å‡½æ•°ï¼Œå½“è·å–é”å¤±è´¥åä¼šè¿”å›ä¸º 0 çš„ stamp å€¼ã€‚å½“è°ƒç”¨é‡Šæ”¾é”å’Œè½¬æ¢é”çš„æ–¹æ³•æ—¶éœ€è¦ä¼ å…¥è·å–é”æ—¶è¿”å›çš„ stamp å€¼ã€‚

#### å†™é” writeLock

æ˜¯ä¸€ä¸ª**ä¸å¯é‡å…¥ç‹¬å é”**ï¼ŒæŸæ—¶åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥è·å–è¯¥é”ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹è·å–è¯¥é”åï¼Œå…¶ä»–è¯·æ±‚è¯»é”å’Œå†™é”çš„çº¿ç¨‹å¿…é¡»ç­‰å¾…ã€‚è¯·æ±‚è¯¥é”æˆåŠŸåä¼šè¿”å›ä¸€ä¸ª `stamp` å˜é‡ç”¨æ¥è¡¨ç¤ºè¯¥é”çš„ç‰ˆæœ¬ï¼Œå½“é‡Šæ”¾è¯¥é”æ—¶éœ€è¦è°ƒç”¨ `unlockWrite` æ–¹æ³•å¹¶ä¼ é€’è·å–é”æ—¶çš„ `stamp` å‚æ•°ã€‚å¹¶ä¸”å®ƒæä¾›äº†éé˜»å¡çš„ `tryWriteLock` æ–¹æ³•ã€‚

#### æ‚²è§‚è¯»é” reaLock

æ˜¯ä¸€ä¸ªä¸å¯é‡å…¥å…±äº«é”ï¼Œåœ¨æ²¡æœ‰çº¿ç¨‹è·å–ç‹¬å å†™é”çš„æƒ…å†µä¸‹ï¼Œå¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è·å–è¯¥é”ã€‚å¦‚æœå·²ç»æœ‰çº¿ç¨‹æŒæœ‰å†™é”ï¼Œåˆ™å…¶ä»–çº¿ç¨‹è¯·æ±‚è·å–è¯¥è¯»é”ä¼šè¢«é˜»å¡ã€‚æ‚²è§‚æ˜¯æŒ‡åœ¨å…·ä½“æ“ä½œæ•°æ®å‰å…¶ä¼šæ‚²è§‚åœ°è®¤ä¸ºå…¶ä»–çº¿ç¨‹å¯èƒ½è¦å¯¹è‡ªå·±æ“ä½œçš„æ•°æ®è¿›è¡Œä¿®æ”¹ï¼Œæ‰€ä»¥éœ€è¦å…ˆå¯¹æ•°æ®åŠ é”ï¼Œè¿™æ˜¯åœ¨**è¯»å°‘å†™å¤š**çš„æƒ…å†µä¸‹çš„ä¸€ç§è€ƒè™‘ã€‚è¯·æ±‚è¯¥é”æˆåŠŸåä¼šè¿”å›ä¸€ä¸ª `stamp` å˜é‡ç”¨æ¥è¡¨ç¤ºè¯¥é”çš„ç‰ˆæœ¬ï¼Œå½“é‡Šæ”¾è¯¥é”æ—¶éœ€è¦è°ƒç”¨ `unlockRead` æ–¹æ³•å¹¶ä¼ é€’ `stamp` å‚æ•°ã€‚å¹¶ä¸”å®ƒæä¾›äº†éé˜»å¡çš„ `tryReadLock` æ–¹æ³•ã€‚

#### ä¹è§‚è¯»é” tryOptimisticRead

å®ƒæ˜¯ç›¸å¯¹äºæ‚²è§‚é”æ¥è¯´çš„ï¼Œåœ¨æ“ä½œæ•°æ®å‰å¹¶æ²¡æœ‰é€šè¿‡ CAS è®¾ç½®é”çš„çŠ¶æ€ï¼Œä»…ä»…é€šè¿‡ä½è¿ç®—æµ‹è¯•ã€‚å¦‚æœå½“å‰æ²¡æœ‰çº¿ç¨‹æŒæœ‰å†™é”ï¼Œåˆ™ç®€å•åœ°è¿”å›ä¸€ä¸ªé 0 çš„ `stamp` ç‰ˆæœ¬ä¿¡æ¯ã€‚è·å–è¯¥ `stamp` ååœ¨å…·ä½“æ“ä½œæ•°æ®å‰è¿˜éœ€è¦è°ƒç”¨ `validate` æ–¹æ³•éªŒè¯è¯¥ stamp æ˜¯å¦å·²ç»ä¸å¯ç”¨ï¼Œä¹Ÿå°±æ˜¯çœ‹å½“è°ƒç”¨ `trÎ³OptimisticRead` è¿”å› `stamp` ååˆ°å½“å‰æ—¶é—´æœŸé—´æ˜¯å¦æœ‰å…¶ä»–çº¿ç¨‹æŒæœ‰äº†å†™é”ï¼Œå¦‚æœæ˜¯åˆ™ `validate` ä¼šè¿”å› 0, å¦åˆ™å°±å¯ä»¥ä½¿ç”¨è¯¥ `stamp` ç‰ˆæœ¬çš„é”å¯¹æ•°æ®è¿›è¡Œæ“ä½œã€‚ç”±äº `tryOptimisticRead` å¹¶æ²¡æœ‰ä½¿ç”¨ CAS è®¾ç½®é”çŠ¶æ€ï¼Œæ‰€ä»¥**ä¸éœ€è¦æ˜¾å¼åœ°é‡Šæ”¾è¯¥é”**ã€‚ è¯¥é”çš„ä¸€ä¸ªç‰¹ç‚¹æ˜¯é€‚ç”¨äº**è¯»å¤šå†™å°‘**çš„åœºæ™¯ï¼Œå› ä¸ºè·å–è¯»é”åªæ˜¯ä½¿ç”¨ä½æ“ä½œè¿›è¡Œæ£€éªŒï¼Œä¸æ¶‰åŠ CAS æ“ä½œï¼Œæ‰€ä»¥æ•ˆç‡ä¼šé«˜å¾ˆå¤šï¼Œä½†æ˜¯åŒæ—¶ç”±äºæ²¡æœ‰ä½¿ç”¨çœŸæ­£çš„é”ï¼Œåœ¨ä¿è¯æ•°æ®ä¸€è‡´æ€§ä¸Šéœ€è¦å¤åˆ¶ä¸€ä»½è¦æ“ä½œçš„å˜é‡åˆ°æ–¹æ³•æ ˆï¼Œå¹¶ä¸”åœ¨æ“ä½œæ•°æ®æ—¶å¯èƒ½å…¶ä»–å†™çº¿ç¨‹å·±ç»ä¿®æ”¹äº†æ•°æ®ï¼Œè€Œæˆ‘ä»¬æ“ä½œçš„æ˜¯æ–¹æ³•æ ˆé‡Œé¢çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªå¿«ç…§ï¼Œæ‰€ä»¥æœ€å¤šè¿”å›çš„ä¸æ˜¯æœ€æ–°çš„æ•°æ®ï¼Œä½†æ˜¯ä¸€è‡´æ€§è¿˜æ˜¯å¾—åˆ°ä¿éšœçš„ã€‚

#### ä¸‰ç§é”çš„è½¬æ¢

StampedLock è¿˜æ”¯æŒè¿™ä¸‰ç§é”åœ¨ä¸€å®šæ¡ä»¶ä¸‹è¿›è¡Œç›¸äº’è½¬æ¢ã€‚ä¾‹å¦‚ `long tryConvertToWriteLock(long stamp)` æœŸæœ›æŠŠ `stamp` æ ‡ç¤ºçš„é”å‡çº§ä¸ºå†™é”ï¼Œè¿™ä¸ªå‡½æ•°ä¼šåœ¨ä¸‹é¢å‡ ç§æƒ…å†µä¸‹è¿”å›ä¸€ä¸ªæœ‰æ•ˆçš„ `stamp`ï¼ˆä¹Ÿå°±æ˜¯æ™‹å‡å†™é”æˆåŠŸï¼‰ï¼š

-   å½“å‰é”å·²ç»æ˜¯å†™é”äº†ï¼›
    
-   å½“å‰é”å¤„äºè¯»é”æ¨¡å¼ï¼Œå¹¶ä¸”æ²¡æœ‰å…¶ä»–çº¿ç¨‹æ˜¯è¯»é”æ¨¡å¼ï¼ˆä¹Ÿå¯èƒ½æœ‰å¤šä¸ªè¯»é”éƒ½åœ¨å‡çº§ä¸ºå†™é”ï¼Œåªæœ‰ä¸€ä¸ªä¼šæˆåŠŸï¼‰ï¼›
    
-   å½“å‰å¤„äºä¹è§‚è¯»æ¨¡å¼ï¼Œå¹¶ä¸”å½“å‰å†™é”å¯ç”¨ã€‚
    

StampedLock ä¸‰ç§é”éƒ½æ˜¯ä¸å¯é‡å…¥é”ï¼›å¤šä¸ªçº¿ç¨‹åŒæ—¶äº‰å¤ºè¯»é”å’Œå†™é”æ—¶ï¼Œç»“æœæ˜¯éšæœºçš„ï¼›è¯¥é”æ²¡æœ‰ç›´æ¥å®ç° `Lock` æˆ– `ReadWriteLock`ï¼Œè€Œæ˜¯åœ¨å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªåŒå‘é˜»å¡é˜Ÿåˆ—ã€‚

### æ¡ˆä¾‹

public class Point {  
    private double x, y;  
    private final StampedLock sl = new StampedLock();  
  
    void move(double deltaX, double deltaY) {  
        long stamp = sl.writeLock();  
        try {  
            x += deltaX;  
            y += deltaY;  
        } finally {  
            sl.unlockWrite(stamp);  
        }  
    }  
  
    // ä¹è§‚è¯»é”  
    double distanceFromOrigin() {  
        long stamp = sl.tryOptimisticRead();  
        // å°†å˜é‡å¤åˆ¶åˆ°æ–¹æ³•ä½“æ ˆå†…  
        double currentX = x, currentY = y;  
        // æ£€æŸ¥è·å–åˆ° stamp åï¼Œé”æœ‰æ²¡æœ‰è¢«å…¶ä»–å†™çº¿ç¨‹æ’å®ƒæ€§æŠ¢å   
        // ä¸èƒ½å’Œä¸Šä¸€è¡Œä»£ç æ¢ä½ç½®ï¼Œé˜²æ­¢åœ¨ validate é€šè¿‡åï¼Œå¤åˆ¶å˜é‡ä¹‹å‰è¢«å†™é”æŠ¢å   
        if (!sl.validate(stamp)) {  
            // å¦‚æœè¢«æŠ¢å åˆ™è·å–ä¸€ä¸ªæ‚²è§‚è¯»é”  
            stamp = sl.readLock();  
            try {  
                // å°†å…¨é‡å¤åˆ¶åˆ°æ–¹æ³•ä½“æ ˆå†…  
                currentX = x;  
                currentY = y;  
            } finally {  
                // é‡Šæ”¾æ‚²è§‚è¯»é”ï¼ˆä¹è§‚è¯»é”ä¸éœ€è¦é‡Šæ”¾ï¼‰  
                sl.unlockRead(stamp);  
            }  
        }  
        return Math.sqrt(currentX * currentX + currentY * currentY);  
    }  
  
    // ä½¿ç”¨æ‚²è§‚é”è·å–è¯»é”ï¼Œå¹¶å°è¯•è½¬æ¢ä¸ºå†™é”  
    void moveIfAtOrigin(double newX, double newY) {  
        // è¿™é‡Œå¯ä»¥ç”¨ä¹è§‚è¯»é”æ›¿æ¢  
        long stamp = sl.readLock();  
        try {  
            // å¦‚æœå½“å‰ç‚¹åœ¨åŸç‚¹åˆ™æ˜“æ‡‚  
            while (x == 0.0 && y == 0.0) {  
                // å°è¯•å°†è·å–çš„è¯»é”å‡çº§ä¸ºå†™é”  
                long ws = sl.tryConvertToWriteLock(stamp);  
                // å‡çº§æˆåŠŸï¼Œæ›´æ–° stampï¼Œå¹¶è®¾ç½®æ–°åæ ‡ï¼Œç„¶åé€€å‡ºå¾ªç¯  
                if (ws != 0L) {  
                    stamp = ws;  
                    x = newX;  
                    y = newY;  
                    break;  
                } else {  
                    // å‡çº§å†™é”å¤±è´¥ï¼Œé‡Šæ”¾è¯»é”ï¼Œæ˜¾å¼è·å–ç‹¬å å†™é”ï¼Œç„¶åè¿›è¡Œå¾ªç¯  
                    sl.unlockRead(stamp);  
                    stamp = sl.writeLock();  
                }  
            }  
        } finally {  
            sl.unlock(stamp);  
        }  
    }  
}

1.  readLock å’Œ writeLock éƒ½ä¼šé˜»å¡ï¼Œä½† tryOptimisticRead ä¸ä¼šï¼›
    
2.  åœ¨ tryOptimisticRead ä¹‹åï¼Œvalidate ä¹‹å‰ï¼Œå°†å˜é‡å¤åˆ¶åˆ°æœ¬åœ°æ–¹æ³•æ ˆé‡Œï¼›
    
3.  å³ä½¿åœ¨ validate é€šè¿‡ä¹‹åï¼Œæ‹¿åˆ°çš„æ•°æ®ä¹Ÿå¯èƒ½ä¼šå˜æˆä¸æ˜¯æœ€æ–°çš„ï¼›
    
4.  å˜é‡ä¸éœ€è¦ volatieï¼ŒåŠ é”çš„è¯­ä¹‰ä¿è¯äº†å†…å­˜çš„å¯è§æ€§ã€‚
    

ä¹è§‚è¯»é”çš„ä¸€èˆ¬ä½¿ç”¨é¡ºåºï¼š

long stamp = lock.tryOptimisticRead();  
copyVariable2ThreadMemory();  
if (!sl.validate(stamp)) {  
    stamp = lock.readLock();  
    try {  
        copyVariable2ThreadMemory();  
    } finally {  
        lock.unlockRead(stamp);  
    }  
}  
useThreadMemoryVarables();

### æ€»ç»“

StampedLock æä¾›çš„è¯»å†™é”ä¸ ReentrantReadWriteLock ç±»ä¼¼ï¼Œåªæ˜¯å‰è€…æä¾›çš„æ˜¯ä¸å¯é‡å…¥é”ã€‚ä½†æ˜¯å‰è€…é€šè¿‡æä¾›ä¹è§‚è¯»é”åœ¨å¤šçº¿ç¨‹å¤šè¯»çš„æƒ…å†µä¸‹æä¾›äº†æ›´å¥½çš„æ€§èƒ½ï¼Œè¿™æ˜¯å› ä¸ºè·å–ä¹è§‚è¯»é”æ—¶ä¸éœ€è¦è¿›è¡Œ CAS æ“ä½œè®¾ç½®é”çš„çŠ¶æ€ï¼Œè€Œåªæ˜¯ç®€å•åœ°æµ‹è¯•çŠ¶æ€ã€‚

![image-20210612211814101](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/image-20210612211814101.png)

# 7. å¹¶å‘é˜Ÿåˆ—åŸç†

## 7.1 ConcurrentLinkedQueue

`ConcurrentLinkedQueue` æ˜¯çº¿ç¨‹å®‰å…¨çš„æ— ç•Œéé˜»å¡é˜Ÿåˆ—ï¼Œå…¶åº•å±‚æ•°æ®ç»“æ„ä½¿ç”¨å•å‘é“¾è¡¨å®ç°ï¼Œå¯¹äºå…¥é˜Ÿå’Œå‡ºé˜Ÿæ“ä½œä½¿ç”¨ CAS æ¥å®ç°çº¿ç¨‹å®‰å…¨ã€‚

### 7.1.1 ç±»å›¾

![Screen Shot 2021-06-28 at 21.53.52](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-06-28%20at%2021.53.52.png)

`ConcurrentLinkedQueue` å†…éƒ¨çš„é˜Ÿåˆ—ä½¿ç”¨å•å‘é“¾è¡¨æ–¹å¼å®ç°ï¼Œå…¶ä¸­æœ‰ä¸¤ä¸ª `volatile` ç±»å‹çš„ `Node` èŠ‚ç‚¹åˆ†åˆ«ç”¨æ¥å­˜æ”¾é˜Ÿåˆ—çš„é¦–ã€å°¾èŠ‚ç‚¹ã€‚ä»ä¸‹é¢çš„æ— å‚æ„é€ å‡½æ•°å¯çŸ¥ï¼Œé»˜è®¤å¤´ã€å°¾èŠ‚ç‚¹éƒ½æ˜¯æŒ‡å‘ `item` ä¸º null çš„**å“¨å…µèŠ‚ç‚¹**ã€‚æ–°å…ƒç´ ä¼šè¢«æ’å…¥é˜Ÿåˆ—æœ«å°¾ï¼Œå‡ºé˜Ÿæ—¶ä»é˜Ÿåˆ—å¤´éƒ¨è·å–ä¸€ä¸ªå…ƒç´ ã€‚

public ConcurrentLinkedQueue() {  
    head = tail = new Node<E>(null);  
}

åœ¨ `Node` èŠ‚ç‚¹å†…éƒ¨åˆ™ç»´æŠ¤ä¸€ä¸ªä½¿ç”¨ volatile ä¿®é¥°çš„å˜é‡ `item`ï¼Œç”¨æ¥å­˜æ”¾èŠ‚ç‚¹çš„å€¼ï¼›`next` ç”¨æ¥å­˜æ”¾é“¾è¡¨çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä»è€Œé“¾æ¥ä¸ºä¸€ä¸ªå•å‘æ— ç•Œé“¾è¡¨ã€‚å…¶å†…éƒ¨åˆ™ä½¿ç”¨ `UnSafe` å·¥å…·ç±»æä¾›çš„ CAS ç®—æ³•æ¥ä¿è¯å‡ºå…¥é˜Ÿæ—¶æ“ä½œé“¾è¡¨çš„åŸå­æ€§ã€‚

### åŸç†

#### offer

`offer` æ˜¯åœ¨é˜Ÿåˆ—æœ«å°¾æ·»åŠ ä¸€ä¸ªå…ƒç´ ï¼Œé™¤éå‚æ•°æ˜¯ `null` ä¼šæŠ› NPEï¼Œå¦åˆ™ä¼šä¸€ç›´è¿”å› trueã€‚å¦å¤–ï¼Œç”±äºä½¿ç”¨äº† CAS æ— é˜»å¡ç®—æ³•ï¼Œå› æ­¤è¯¥æ–¹æ³•ä¸ä¼šé˜»å¡åˆ®èµ·çº¿ç¨‹ã€‚

public boolean offer(E e) {  
    checkNotNull(e);  
    // 2. æ„é€ NodeèŠ‚ç‚¹ï¼Œåœ¨æ„é€ å‡½æ•°å†…éƒ¨è°ƒç”¨ unsafe.putObject  
    final Node<E> newNode = new Node<E>(e);  
      
    // 3. ä»å°¾èŠ‚ç‚¹è¿›è¡Œæ’å…¥  
    for (Node<E> t = tail, p = t;;) {  
        Node<E> q = p.next;  
        // 4. å¦‚é‡‡ q==null è¯´æ˜ p æ˜¯å°¾èŠ‚ç‚¹ï¼Œåˆ™æ‰§è¡Œæ’å…¥  
        if (q == null) {  
            // 5. ä½¿ç”¨CASè®¾ç½®pèŠ‚ç‚¹çš„nextèŠ‚ç‚¹  
            if (p.casNext(null, newNode)) {  
                // 6. CASæˆåŠŸï¼Œåˆ™è¯´æ˜æ–°å¢èŠ‚ç‚¹å·²ç»è¢«æ”¾å…¥é“¾è¡¨ï¼Œç„¶åè®¾ç½®å½“å‰å°¾èŠ‚ç‚¹  
                // (åŒ…å«headï¼Œç¬¬ 1, 3, 5. . .ä¸ªèŠ‚ç‚¹ä¸ºå°¾èŠ‚ç‚¹)  
                if (p != t) // hop two nodes at a time  
                    casTail(t, newNode);  // Failure is OK.  
                return true;  
            }  
            // Lost CAS race to another thread; re-read next  
        }  
        else if (p == q)  
            // 7. å¤šçº¿ç¨‹æ“ä½œæ—¶ï¼Œç”±äºpollæ“ä½œç§»é™¤å…ƒç´ åå¯èƒ½ä¼šæŠŠheadå˜ä¸ºè‡ªå¼•ç”¨  
            // ï¼Œä¹Ÿå°±æ˜¯headçš„ nextå˜æˆäº† headï¼Œæ‰€ä»¥è¿™é‡Œéœ€è¦  
            // é‡æ–°æ‰¾æ–°çš„ head  
            p = (t != (t = tail)) ? t : head;  
        else  
            // 8. å¯»æ‰¾å°¾èŠ‚ç‚¹  
            p = (p != t && t != (t = tail)) ? t : q;  
    }  
}

##### å•çº¿ç¨‹

é¦–å…ˆæ‰§è¡Œä»£ç  2 å¹¶ä½¿ç”¨ item ä½œä¸ºæ„é€ å‡½æ•°å‚æ•°åˆ›å»ºä¸€ ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œç„¶åä»£ç  3 ä»é˜Ÿåˆ—å°¾éƒ¨èŠ‚ç‚¹å¼€å§‹å¾ªç¯ï¼Œæ‰“ç®—ä»é˜Ÿåˆ—å°¾éƒ¨æ·»åŠ å…ƒç´ ï¼Œå½“æ‰§è¡Œåˆ°ä»£ç  4 æ—¶é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.01.26](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.01.26.png)

è¿™æ—¶å€™èŠ‚ç‚¹ pã€ tã€ headã€ tail åŒæ—¶æŒ‡å‘äº† item ä¸º null çš„å“¨å…µèŠ‚ç‚¹ï¼Œç”±äºå“¨å…µèŠ‚ç‚¹çš„ next èŠ‚ç‚¹ä¸º nullï¼Œæ‰€ä»¥è¿™é‡Œ q ä¹ŸæŒ‡å‘ nullã€‚ ä»£ç  4 å‘ç° `q==null` åˆ™æ‰§è¡Œä»£ç  5ï¼Œé€šè¿‡ CAS åŸå­æ“ä½œåˆ¤æ–­ p èŠ‚ç‚¹çš„ next èŠ‚ç‚¹æ˜¯å¦ä¸º nullï¼Œå¦‚æœä¸º null åˆ™ä½¿ç”¨èŠ‚ç‚¹ `newNode` æ›¿æ¢ p çš„ next èŠ‚ç‚¹ï¼Œç„¶åæ‰§è¡Œä»£ç  6ï¼Œè¿™é‡Œç”±äº `p==t` æ‰€ä»¥æ²¡æœ‰è®¾ç½®å°¾éƒ¨èŠ‚ç‚¹ï¼Œç„¶åé€€å‡º `offer` æ–¹æ³•ï¼Œè¿™æ—¶å€™é˜Ÿåˆ—çš„çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.03.03](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.03.03.png)

##### å¤šçº¿ç¨‹

å‡è®¾çº¿ç¨‹ A è°ƒç”¨ `offer(item1)`ï¼Œçº¿ç¨‹ B è°ƒç”¨ `offer(item2)`ï¼ŒåŒæ—¶æ‰§è¡Œåˆ°ä»£ç  5ï¼Œçº¿ç¨‹ A å…ˆæ‰§è¡Œäº†æ¯”è¾ƒè®¾ç½®æ“ä½œï¼Œå‘ç°å½“å‰ p çš„ next èŠ‚ç‚¹ç¡®å®æ˜¯ nullï¼Œåˆ™ä¼šåŸå­æ€§åœ°æ›´æ–° next èŠ‚ç‚¹ä¸º item1ï¼Œè¿™æ—¶å€™çº¿ç¨‹ B ä¹Ÿä¼šåˆ¤æ–­ p çš„ next èŠ‚ç‚¹æ˜¯å¦ä¸º nullï¼Œç»“æœå‘ç°ä¸æ˜¯ nullï¼Œåˆ™è·³åˆ°ä»£ç  3ï¼Œç„¶åæ‰§è¡Œåˆ°ä»£ç  4ï¼Œè¿™æ—¶å€™çš„é˜Ÿåˆ—åˆ†å¸ƒå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.22.39](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.22.39.png)

ç„¶åçº¿ç¨‹ B æ‰§è¡Œä»£ç  8ï¼Œå› ä¸º `p == t`ï¼Œæ‰€ä»¥å°† q èµ‹ç»™ pã€‚è¿™æ—¶å€™çš„é˜Ÿåˆ—åˆ†å¸ƒå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.24.31](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.24.31.png)

ç„¶åçº¿ç¨‹ B å†æ¬¡è·³åˆ°ä»£ç  3 æ‰§è¡Œï¼Œå½“æ‰§è¡Œåˆ°ä»£ç  4 æ—¶ï¼Œé˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.25.22](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.25.22.png)

ç”±äºè¿™æ—¶å€™ `q == null`ï¼Œæ‰€ä»¥çº¿ç¨‹ B ä¼šæ‰§è¡Œä»£ç  5ï¼Œé€šè¿‡ CAS æ“ä½œåˆ¤æ–­å½“å‰ p çš„ next èŠ‚ç‚¹æ˜¯å¦æ˜¯ nullï¼Œä¸æ˜¯åˆ™å†æ¬¡å¾ªç¯å°è¯• ï¼Œ æ˜¯åˆ™ä½¿ç”¨ item2 æ›¿æ¢ã€‚ å‡è®¾ CAS æˆåŠŸäº†ï¼Œé‚£ä¹ˆæ‰§è¡Œä»£ç  6ï¼Œç”±äº `p != t`ï¼Œ æ‰€ä»¥è®¾ç½® `tail` èŠ‚ç‚¹ä¸º item2ï¼Œç„¶åé€€å‡º `offer` æ–¹æ³•ã€‚ è¿™æ—¶å€™é˜Ÿåˆ—åˆ†å¸ƒå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.26.46](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.26.46.png)

##### æ‰§è¡Œ poll å¯èƒ½å‘ç”Ÿçš„æƒ…å†µ

åˆ†æåˆ°ç°åœ¨ï¼Œå°±å·®ä»£ç  7 è¿˜æ²¡èµ°è¿‡ï¼Œå…¶å®è¿™ä¸€æ­¥è¦åœ¨æ‰§è¡Œ `poll` æ“ä½œåæ‰ä¼šæ‰§è¡Œ ã€‚è¿™é‡Œå…ˆæ¥çœ‹ä¸€ä¸‹æ‰§è¡Œ `poll` æ“ä½œåå¯èƒ½ä¼šå­˜åœ¨çš„ä¸€ç§æƒ…å†µï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.28.04.png" alt="Screen Shot 2021-07-06 at 23.28.04" style="zoom:50%;" />

æ­¤æ—¶è°ƒç”¨ `offer`ï¼Œæ‰§è¡Œåˆ°ä»£ç  4 æ—¶çš„çŠ¶æ€å›¾å¦‚ä¸‹ã€‚

![Screen Shot 2021-07-06 at 23.28.49](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.28.49.png)

è¿™é‡Œç”±äº q èŠ‚ç‚¹ä¸ä¸ºç©ºå¹¶ä¸” `p == q` æ‰€ä»¥æ‰§è¡Œä»£ç  7ï¼Œç”±äº `t == tail` æ‰€ä»¥ p è¢«èµ‹å€¼ä¸º headï¼Œç„¶åé‡æ–°å¾ªç¯ï¼Œå¾ªç¯åæ‰§è¡Œåˆ°ä»£ç  4ï¼Œè¿™æ—¶å€™é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-06 at 23.30.29](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-06%20at%2023.30.29.png)

è¿™æ—¶å€™ç”±äº `q == null`ï¼Œæ‰€ä»¥æ‰§è¡Œä»£ç  5 è¿›è¡Œ CAS æ“ä½œï¼Œå¦‚æœå½“å‰æ²¡æœ‰å…¶ä»–çº¿ç¨‹æ‰§è¡Œ `offer` æ“ä½œï¼Œåˆ™ CAS æ“ä½œä¼šæˆåŠŸï¼Œ pçš„nextèŠ‚ç‚¹è¢«è®¾ç½®ä¸ºæ–°å¢èŠ‚ç‚¹ã€‚ ç„¶åæ‰§è¡Œä»£ç  (6)' ç”±äº p!=t æ‰€ä»¥è®¾ç½®æ–°èŠ‚ç‚¹ä¸ºé˜Ÿåˆ—çš„å°¾éƒ¨èŠ‚ç‚¹ï¼Œç°åœ¨é˜Ÿåˆ—çŠ¶æ€å¦‚å›¾ 7-11 æ‰€ç¤ºã€‚

#### add

`add` å°±æ˜¯åœ¨å†…éƒ¨è°ƒç”¨ `offer`ã€‚

public boolean add(E e) {  
    return offer(e);  
}

#### poll

`poll` æ“ä½œæ˜¯åœ¨é˜Ÿåˆ—å¤´éƒ¨è·å–å¹¶ç§»é™¤ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœé˜Ÿåˆ—ä¸ºç©ºåˆ™è¿”å› nullã€‚

public E poll() {  
    // 1. goto æ ‡è®°  
    restartFromHead:  
      
    // 2. æ— é™å¾ªç¯  
    for (;;) {  
        for (Node<E> h = head, p = h, q;;) {  
            // 3. ä¿å­˜å½“å‰èŠ‚ç‚¹å€¼  
            E item = p.item;  
              
            // 4. å½“å‰èŠ‚ç‚¹æœ‰å€¼åˆ™ CAS å˜ä¸º null  
            if (item != null && p.casItem(item, null)) {  
                // 5. CAS æˆåŠŸåˆ™æ ‡è®°å½“å‰èŠ‚ç‚¹å¹¶ä»é“¾è¡¨ä¸­ç§»é™¤  
                if (p != h) // hop two nodes at a time  
                    updateHead(h, ((q = p.next) != null) ? q : p);  
                return item;  
            }  
            // 6. å½“å‰é˜Ÿåˆ—ä¸ºç©ºåˆ™è¿”å› null  
            else if ((q = p.next) == null) {  
                updateHead(h, p);   
                return null;  
            }  
            // 7. å¦‚é‡‡å½“å‰èŠ‚ç‚¹è¢«è‡ªå¼•ç”¨äº†ï¼Œ åˆ™é‡æ–°å¯»æ‰¾æ–°çš„é˜Ÿåˆ—å¤´èŠ‚ç‚¹  
            else if (p == q)  
                continue restartFromHead;  
            else   
                p = q;  
        }  
    }  
}  
    
final void updateHead(Node<E> h, Node<E> p) {  
    if (h != p && casHead(h, p))  
        h.lazySetNext(h);  
}

(1). é˜Ÿåˆ—ä¸€å¼€å§‹ä¸ºç©ºæ—¶é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-07 at 21.26.09](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.26.09.png)

ç”±äº `head` èŠ‚ç‚¹æŒ‡å‘çš„æ˜¯ item ä¸º null çš„å“¨å…µèŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¼šæ‰§è¡Œåˆ°ä»£ç  6ï¼Œå‡è®¾è¿™ä¸ªè¿‡ç¨‹ä¸­æ²¡æœ‰çº¿ç¨‹è°ƒç”¨ offeræ–¹æ³•ï¼Œåˆ™æ­¤æ—¶ q ç­‰äº nullï¼Œè¿™æ—¶å€™é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.27.59.png" alt="Screen Shot 2021-07-07 at 21.27.59" style="zoom:50%;" />

æ‰€ä»¥ä¼šæ‰§è¡Œ `updateHead` æ–¹æ³•ï¼Œç”±äº `h` ç­‰äº `p` æ‰€ä»¥æ²¡æœ‰è®¾ç½®å¤´èŠ‚ç‚¹ï¼Œ`poll` æ–¹æ³•ç›´æ¥è¿”å› nullã€‚

(2). å‡è®¾æ‰§è¡Œåˆ°ä»£ç  6 æ—¶å·²ç»æœ‰å…¶ä»–çº¿ç¨‹è°ƒç”¨äº† offer æ–¹æ³•å¹¶æˆåŠŸæ·»åŠ ä¸€ä¸ªå…ƒç´ åˆ°é˜Ÿåˆ—ï¼Œè¿™æ—¶å€™ q æŒ‡å‘çš„æ˜¯æ–°å¢å…ƒç´ çš„èŠ‚ç‚¹ï¼Œæ­¤æ—¶é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

<img src="https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.29.58.png" alt="Screen Shot 2021-07-07 at 21.29.58" style="zoom:50%;" />

æ‰€ä»¥ä»£ç  6 åˆ¤æ–­çš„ç»“æœä¸º falseï¼Œç„¶åä¼šè½¬å‘æ‰§è¡Œä»£ç  7ï¼Œè€Œæ­¤æ—¶ p ä¸ç­‰äº qï¼Œæ‰€ä»¥è½¬å‘æ‰§è¡Œä»£ç  8ï¼Œæ­¤æ—¶é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

![Screen Shot 2021-07-07 at 21.31.24](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.31.24.png)

ç„¶åç¨‹åºè½¬å‘æ‰§è¡Œä»£ç  3ï¼Œp ç°åœ¨æŒ‡å‘çš„å…ƒç´ å€¼ä¸ä¸º nullï¼Œåˆ™æ‰§è¡Œ `p.casltem(item, null)` é€šè¿‡ CAS æ“ä½œå°è¯•è®¾ç½® p çš„ item å€¼ä¸º nullï¼Œå¦‚æœæ­¤æ—¶æ²¡æœ‰å…¶ ä»–çº¿ç¨‹è¿›è¡Œ `poll` æ“ä½œï¼Œ åˆ™ CAS æˆåŠŸä¼šæ‰§è¡Œä»£ç  5ï¼Œç”±äºæ­¤æ—¶ `p != h` æ‰€ä»¥è®¾ç½®å¤´èŠ‚ç‚¹ä¸º pï¼Œå¹¶è®¾ç½® h çš„ next èŠ‚ç‚¹ ä¸º h è‡ªå·±ï¼Œ poll ç„¶åè¿”å›è¢«ä»é˜Ÿåˆ—ç§»é™¤çš„èŠ‚ç‚¹å€¼ itemã€‚ æ­¤æ—¶é˜Ÿåˆ—çŠ¶æ€å¦‚ä¸‹å›¾æ‰€ç¤ºã€‚

# 8. ThreadPoolExecutor

## 8.1 ä»‹ç»

çº¿ç¨‹æ± ä¸»è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼šä¸€æ˜¯å½“æ‰§è¡Œå¤§é‡å¼‚æ­¥ä»»åŠ¡æ—¶çº¿ç¨‹æ± èƒ½å¤Ÿæä¾›è¾ƒå¥½çš„æ€§èƒ½ã€‚åœ¨ä¸ä½¿ç”¨çº¿ç¨‹æ± æ—¶ï¼Œæ¯å½“éœ€è¦æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡æ—¶ç›´æ¥ new ä¸€ä¸ªçº¿ç¨‹æ¥è¿è¡Œï¼Œè€Œçº¿ç¨‹çš„åˆ›å»ºå’Œé”€æ¯æ˜¯éœ€è¦å¼€é”€çš„ã€‚çº¿ç¨‹æ± é‡Œé¢çš„çº¿ç¨‹æ˜¯å¯å¤ç”¨çš„ï¼Œä¸éœ€è¦æ¯æ¬¡æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡æ—¶éƒ½é‡æ–°åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹ã€‚äºŒæ˜¯çº¿ç¨‹iä¹Ÿæä¾›äº†ä¸€ç§èµ„æºé™åˆ¶å’Œç®¡ç†çš„æ‰‹æ®µï¼Œæ¯”å¦‚å¯ä»¥é™åˆ¶çº¿ç¨‹çš„ä¸ªæ•°ï¼ŒåŠ¨æ€æ–°å¢çº¿ç¨‹ç­‰ã€‚æ¯ä¸ª `ThreadPoolExecutor` ä¹Ÿä¿ç•™äº†ä¸€äº›åŸºæœ¬çš„ç»Ÿè®¡æ•°æ®ï¼Œæ¯”å¦‚å½“å‰çº¿ç¨‹æ± å®Œæˆçš„ä»»åŠ¡æ•°ç›®ç­‰ã€‚

å¦å¤–ï¼Œ çº¿ç¨‹æ± ä¹Ÿæä¾›äº†è®¸å¤šå¯è°ƒå‚æ•°å’Œå¯æ‰©å±•æ€§æ¥å£ï¼Œä»¥æ»¡è¶³ä¸åŒæƒ…å¢ƒçš„éœ€è¦ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨çš„ `Executors` çš„å·¥å‚æ–¹æ³•ï¼Œæ¯”å¦‚ `newCachedThreadPool` ï¼ˆçº¿ç¨‹æ± çº¿ç¨‹ä¸ªæ•°æœ€å¤šå¯è¾¾ `Integer.MAX_VALUE`ï¼Œçº¿ç¨‹è‡ªåŠ¨å›æ”¶)ã€`newFixedThreadPool` ï¼ˆå›ºå®šå¤§å°çš„çº¿ç¨‹æ± ï¼‰å’Œ `newSingleThreadExecutor` ï¼ˆå•ä¸ªçº¿ç¨‹ï¼‰ç­‰æ¥åˆ›å»ºçº¿ç¨‹æ± ï¼Œä¹Ÿè¿˜å¯ä»¥è‡ªå®šä¹‰ã€‚

## 8.2 ç±»å›¾

![Screen Shot 2021-07-07 at 21.55.06](https://chp-image-hosting.oss-cn-hangzhou.aliyuncs.com/uPic/Screen%20Shot%202021-07-07%20at%2021.55.06.png)

`Executors` æ˜¯ä¸ªå·¥å…·ç±»ï¼Œæä¾›äº†å¤šä¸ªé™æ€æ–¹æ³•ï¼Œæ ¹æ®ç”¨æˆ·é€‰æ‹©è¿”å›ä¸åŒçš„çº¿ç¨‹æ± å®ä¾‹ã€‚ `ThreadPoolExecutor` ç»§æ‰¿äº† `AbstractExecutorService`ï¼Œæˆå‘˜å˜é‡ `Atomic ctl`ï¼Œç”¨æ¥è®°å½•çº¿ç¨‹æ± çŠ¶æ€å’Œçº¿ç¨‹æ± ä¸­çº¿ç¨‹ä¸ªæ•°ï¼Œç±»ä¼¼äº `ReentrantReadWriteLock` ä½¿ç”¨ä¸€ä¸ªå˜é‡æ¥ä¿å­˜ä¸¤ç§ä¿¡æ¯ã€‚

è¿™é‡Œå‡è®¾ Integer ç±»å‹æ˜¯ 32 ä½äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œåˆ™å…¶ä¸­é«˜ 3 ä½ç”¨æ¥è¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€ï¼Œåé¢ 29 ä½ç”¨æ¥è®°å½•çº¿ç¨‹æ± çº¿ç¨‹ä¸ªæ•°ã€‚

// (é«˜3ä½)ç”¨æ¥è¡¨ç¤ºçº¿ç¨‹æ± çŠ¶æ€ï¼Œ (ä½29ä½)ç”¨æ¥è¡¨ç¤ºçº¿ç¨‹ä¸ªæ•°  
// é»˜è®¤æ˜¯ RUNNINGçŠ¶æ€ï¼Œçº¿ç¨‹ä¸ªæ•°ä¸º 0  
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));  
  
// çº¿ç¨‹ä¸ªæ•°æ©ç ä½æ•°ï¼Œå¹¶ä¸æ˜¯æ‰€æœ‰å¹³å°çš„ int çš„ç±»å‹éƒ½æ˜¯ 32 ä½çš„ï¼Œæ‰€ä»¥å‡†ç¡®åœ°è¯´ï¼Œ   
// æ˜¯å…·ä½“å¹³å°ä¸‹ Integer çš„äºŒè¿›åˆ¶ä½æ•° -3 åçš„å‰©ä½™ä½æ•°æ‰€è¡¨ç¤ºçš„æ•°æ‰æ˜¯çº¿ç¨‹çš„ä¸ªæ•°  
private static final int COUNT_BITS = Integer.SIZE - 3;  
  
// çº¿ç¨‹æœ€å¤§ä¸ªæ•°ï¼ˆä½29ä½ï¼‰ 00011111111111111111111111111111  
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;

çº¿ç¨‹æ± çŠ¶æ€ï¼š

// (é«˜3ä½) : 11100000000000000000000000000000  
private static final int RUNNING    = -1 << COUNT_BITS;  
  
// (é«˜3ä½) : 00000000000000000000000000000000  
private static final int SHUTDOWN   =  0 << COUNT_BITS;  
  
// (é«˜3ä½) : 00100000000000000000000000000000  
private static final int STOP       =  1 << COUNT_BITS;  
  
// (é«˜3ä½) : 01000000000000000000000000000000  
private static final int TIDYING    =  2 << COUNT_BITS;  
  
// (é«˜3ä½) : 01100000000000000000000000000000  
private static final int TERMINATED =  3 << COUNT_BITS;  
  
// è·å–é«˜3ä½(è¿è¡ŒçŠ¶æ€)  
private static int runStateOf(int c)     { return c & ~CAPACITY; }  
  
// è·å–ä½29ä½(çº¿ç¨‹ä¸ªæ•°)  
private static int workerCountOf(int c)  { return c & CAPACITY; }  
  
// è®¡ç®—ctlæ–°å€¼(çº¿ç¨‹çŠ¶æ€ä¸çº¿ç¨‹ä¸ªæ•° )  
private static int ctlOf(int rs, int wc) { return rs | wc; }

çº¿ç¨‹æ± çŠ¶æ€å«ä¹‰å¦‚ä¸‹ï¼š

-   RUNNINGï¼šæ¥å—æ–°ä»»åŠ¡å¹¶ä¸”å¤„ç†é˜»å¡é˜Ÿåˆ—é‡Œçš„ä»»åŠ¡ã€‚
    
-   SHUTDOWNï¼šæ‹’ç»æ–°ä»»åŠ¡ä½†æ˜¯å¤„ç†é˜»å¡é˜Ÿåˆ—é‡Œçš„ä»»åŠ¡ ã€‚
    
-   STOPï¼šæ‹’ç»æ–°ä»»åŠ¡å¹¶ä¸”æŠ›å¼ƒé˜»å¡é˜Ÿåˆ—é‡Œçš„ä»»åŠ¡ï¼ŒåŒæ—¶ä¼šä¸­æ–­æ­£åœ¨å¤„ç†çš„ä»»åŠ¡ã€‚
    
-   TIDYINGï¼šæ‰€æœ‰ä»»åŠ¡éƒ½æ‰§è¡Œå®Œï¼ˆåŒ…å«é˜»å¡é˜Ÿåˆ—é‡Œé¢çš„ä»»åŠ¡ï¼‰åå½“å‰çº¿ç¨‹æ± æ´»åŠ¨çº¿ç¨‹æ•°ä¸º 0ï¼Œå°†è¦è°ƒç”¨ `terminated` æ–¹æ³•ã€‚
    
-   TERMINATEDï¼šç»ˆæ­¢çŠ¶æ€ã€‚`terminated` æ–¹æ³•è°ƒç”¨å®Œæˆä»¥åçš„çŠ¶æ€ ã€‚
    

çº¿ç¨‹æ± çŠ¶æ€è½¬æ¢åˆ—ä¸¾å¦‚ä¸‹ ã€‚

-   RUNNING -> SHUTDOWNï¼šæ˜¾å¼è°ƒç”¨ `shutdown()` æ–¹æ³•ï¼Œ æˆ–è€…éšå¼è°ƒç”¨äº† `finalize()`æ–¹æ³•é‡Œé¢çš„ `shutdown()` æ–¹æ³•ã€‚
    
-   RUNNING æˆ– SHUTDOWN -> STOP : æ˜¾å¼è°ƒç”¨ `shutdownNow()` æ–¹æ³•æ—¶ã€‚
    
-   SHUTDOWN -> TIDYINGï¼šå½“çº¿ç¨‹æ± å’Œä»»åŠ¡é˜Ÿåˆ—éƒ½ä¸ºç©ºæ—¶ã€‚
    
-   STOP->TIDYINGï¼šå½“çº¿ç¨‹æ± ä¸ºç©ºæ—¶ã€‚
    
-   TIDYING -> TERMINATEDï¼šå½“ `terminated()` hook æ–¹æ³•æ‰§è¡Œå®Œæˆ æ—¶ ã€‚
    

çº¿ç¨‹æ± å‚æ•°å¦‚ä¸‹ã€‚

-   corePoolSizeï¼šçº¿ç¨‹æ± æ ¸å¿ƒçº¿ç¨‹ä¸ªæ•°ã€‚
    
-   workQueueï¼šç”¨äºä¿å­˜ç­‰å¾…æ‰§è¡Œçš„ä»»åŠ¡çš„é˜» å¡ é˜Ÿåˆ—ï¼Œæ¯”å¦‚åŸºäºæ•°ç»„çš„æœ‰ç•Œ `ArrayBlockingQueue`ã€åŸºäºé“¾è¡¨çš„æ— ç•Œ `LinkedBlockingQueue`ã€æœ€å¤šåªæœ‰ä¸€ä¸ªå…ƒç´ çš„åŒæ­¥é˜Ÿåˆ— `SynchronousQueue` åŠä¼˜å…ˆçº§é˜Ÿåˆ— `PriorityBlockingQueue` ç­‰ã€‚
    
-   maximunPoolSizeï¼šçº¿ç¨‹æ± æœ€å¤§çº¿ç¨‹æ•°é‡ã€‚
    
-   ThreadFactoryï¼šåˆ›å»ºçº¿ç¨‹çš„å·¥å‚ã€‚
    
-   RejectedExecutionHandlerï¼šé¥±å’Œç­–ç•¥ï¼Œå½“é˜Ÿåˆ—æ»¡å¹¶ä¸”çº¿ç¨‹ä¸ªæ•°è¾¾åˆ° maximunPoolSize åé‡‡å–çš„ç­–ç•¥ï¼Œæ¯”å¦‚ AbortPolicy ï¼ˆæŠ›å‡ºå¼‚å¸¸ï¼‰ã€CallerRunsPolicyï¼ˆä½¿ç”¨è°ƒç”¨è€…æ‰€åœ¨çº¿ç¨‹æ¥è¿è¡Œä»»åŠ¡ï¼‰ã€DiscardOldestPolicyï¼ˆè°ƒç”¨ poll ä¸¢å¼ƒä¸€ä¸ªä»»åŠ¡ï¼Œæ‰§è¡Œå½“å‰ä»»åŠ¡ï¼‰åŠ DiscardPolicyï¼ˆé»˜é»˜ä¸¢å¼ƒï¼Œä¸æŠ›å‡ºå¼‚å¸¸ï¼‰
    
-   keeyAliveTimeï¼šå­˜æ´»æ—¶é—´ã€‚å¦‚æœå½“å‰çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡æ¯”æ ¸å¿ƒçº¿ç¨‹æ•°é‡å¤šï¼Œå¹¶ä¸”æ˜¯é—²ç½®çŠ¶æ€ï¼Œåˆ™è¿™äº›é—²ç½®çš„çº¿ç¨‹èƒ½å­˜æ´»çš„æœ€å¤§æ—¶é—´ã€‚
    
-   TimeUnitï¼šå­˜æ´»æ—¶é—´çš„æ—¶é—´å•ä½ ã€‚
    
    çº¿ç¨‹æ± ç±»å‹å¦‚ä¸‹ ã€‚
    
    â€¢ newFixedThreadPool :åˆ›å»ºä¸€ä¸ªæ ¸å¿ƒçº¿ç¨‹ä¸ªæ•°å’Œæœ€å¤§çº¿ç¨‹ä¸ªæ•°éƒ½ä¸º nThreads çš„çº¿ç¨‹ æ± ï¼Œå¹¶ä¸”é˜» å¡ é˜Ÿåˆ— é•¿åº¦ä¸º Integer.
