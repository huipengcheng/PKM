---
tags: ğŸ“¥ï¸/ğŸ“šï¸/ğŸŸ¥ï¸
aliases:
type: book
status: ğŸŸ¥ï¸
created: 2022-05-05 15-55
updated: 2022-06-01 22-15
---

# Title: [[{ 2021-08 Java8 å‡½æ•°å¼ç¼–ç¨‹]]

## Metadata
- `Topics:` [[Java]] [[Functional]]
- `Title:` [[{ 2021-08 Java8 å‡½æ•°å¼ç¼–ç¨‹]]
- `Type:` [[{]]
- `Publish Date:` 
- `Reviewed Date:` [[2022-05-05]]

## Note

# å…¶ä»–

-   Lambda æ˜¯ä¸€ä¸ªè¡Œä¸ºã€‚
    
-   TODOï¼šLambda ä½¿ç”¨å±€éƒ¨å˜é‡æ—¶ä¸ºä»€ä¹ˆè¦ finalã€‚
    
-   for éå†é›†åˆæ˜¯å¤–éƒ¨è¿­ä»£ï¼Œå› ä¸ºè¦æŠŠé›†åˆå…ƒç´ å–å‡ºæ¥ï¼›è€Œ Iterator å’Œ Stream æ˜¯å†…éƒ¨è¿­ä»£ã€‚
    
-   æœ‰ä¸€è¿ä¸²çš„ä¸­é—´æ“ä½œçš„ Streamï¼Œä½†åªä¼šåœ¨é›†åˆå†…éƒ¨æ‰§è¡Œä¸€æ¬¡è¿­ä»£ã€‚
    
-   æ¥å£å¯ä»¥è¿”å› Streamï¼Œè€Œä¸æ˜¯ List ç­‰ã€‚é€šè¿‡ Stream æš´éœ²é›†åˆçš„æœ€å¤§ä¼˜ç‚¹åœ¨äºï¼Œå®ƒå¾ˆå¥½åœ°å°è£…äº†å†…éƒ¨å®ç°çš„æ•°æ®ç»“æ„ã€‚ä»…æš´éœ²ä¸€ä¸ª Stream æ¥å£ï¼Œç”¨æˆ·åœ¨å®é™…æ“ä½œä¸­æ— è®ºå¦‚ä½•ä½¿ç”¨ï¼Œ**éƒ½ä¸ä¼šå½±å“å†…éƒ¨çš„ List æˆ– Set**ã€‚
    
-   Â String name = getUserName();  
    Â button.addActionListener(event -> System.out.println("hi " + name));
    
    name åœ¨ lambad è¡¨è¾¾å¼ä¹‹å‰æ²¡æœ‰è¢«ä¿®æ”¹è¿‡ï¼Œæ‰€ä»¥å®ƒå¯ä»¥è¢«è®¤ä¸ºæ˜¯ final çš„ã€‚è¿™ç§å˜é‡å« â€œæ—¢æˆäº‹å®ä¸Šçš„ finalâ€œï¼Œä¹Ÿå°±æ˜¯åªç»™è¯¥å˜é‡èµ‹å€¼ä¸€æ¬¡ã€‚ å¦‚æœåœ¨ lambda è¡¨è¾¾å¼ä¹‹å‰å¤šæ¬¡ç»™ name èµ‹å€¼ï¼Œé‚£ä¹ˆç¼–è¯‘å°±ä¸ä¼šé€šè¿‡ã€‚
    
-   Â ActionEvent localEvent = null;  
    Â button.addActionListener(event -> {  
    Â  Â  Â localEvent = event;  
    Â });
    
    è¿™æ®µä»£ç è¯•å›¾å°† event èµ‹ç»™ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œå®ƒæ— æ³•é€šè¿‡ç¼–è¯‘ï¼Œä½†ç»éç¼–å†™é”™è¯¯ã€‚è¿™å®é™…ä¸Šæ˜¯è¯­è¨€çš„è®¾è®¡è€…æœ‰æ„ä¸ºä¹‹ï¼Œç”¨ä»¥é¼“åŠ±ç”¨æˆ·ä½¿ç”¨ Lambda è¡¨è¾¾å¼è·å–å€¼è€Œä¸æ˜¯å˜é‡ã€‚è·å–å€¼ä½¿ç”¨æˆ·æ›´å®¹æ˜“å†™å‡ºæ²¡æœ‰å‰¯ä½œç”¨çš„ä»£ç ã€‚
    
-   Â public interface Jukebox {  
    Â  Â  Â public default String rock() {   
    Â  Â  Â  Â  Â return "... all over the world!";  
    Â  Â   }   
    Â }  
    Â â€‹  
    Â public interface Carriage {  
    Â  Â  Â public default String rock() {   
    Â  Â  Â  Â  Â return "... from side to side";  
    Â  Â   }   
    Â }  
    Â â€‹  
    Â public class MusicalCarriage implements Carriage, Jukebox { }
    
    æ­¤æ—¶ä¼šç¼–è¯‘å™¨ä¼šæŠ¥é”™ï¼Œå› ä¸ºä¸æ˜ç¡®åº”è¯¥ç»§æ‰¿å“ªä¸ªæ¥å£ä¸­çš„æ–¹æ³•ï¼Œåº”è¯¥åƒä¸‹é¢è¿™æ ·ï¼š
    
    Â public class MusicalCarriage implements Carriage, Jukebox {  
    Â  Â  Â @Override  
    Â  Â  Â public String rock() {  
    Â  Â  Â  Â  Â return Carriage.super.rock(); Â   
    Â  Â   }  
    Â }
    
    > ä½¿ç”¨å¢å¼ºçš„ super è¯­æ³•ï¼šInterfaceName.super æŒ‡å®šç»§æ‰¿è‡ªçˆ¶æ¥å£çš„æ–¹æ³•ã€‚
    

# é«˜çº§é›†åˆç±»å’Œæ”¶é›†å™¨

-   å¦‚æœåŸé›†åˆæ˜¯æœ‰åºçš„ï¼Œå¦‚ Listï¼Œé‚£ä¹ˆå¯¹åº”çš„ Stream ä¹Ÿæ˜¯æœ‰åºçš„ï¼›å¦‚æœæ˜¯æ— åºçš„ï¼Œå¦‚ Setï¼Œé‚£ä¹ˆå¯¹åº”çš„ Stream ä¹Ÿæ˜¯æ— åºçš„ã€‚
    
-   å¦‚æœä¸€äº›æ“ä½œåœ¨æœ‰åºçš„æµä¸Šå¼€é”€æ›´å¤§ï¼Œè°ƒç”¨ `unordered` æ–¹æ³•æ¶ˆé™¤è¿™ç§é¡ºåºå°±èƒ½è§£å†³è¯¥é—®é¢˜ã€‚å¤§å¤šæ•°æ“ä½œéƒ½æ˜¯åœ¨æœ‰åºæµä¸Šæ•ˆç‡æ›´é«˜ï¼Œæ¯”å¦‚ filterã€map å’Œ reduce ç­‰ã€‚
    
-   ä½¿ç”¨ toCollectionï¼Œç”¨å®šåˆ¶çš„é›†åˆæ”¶é›†å…ƒç´ ã€‚
    
-   `SummaryStatistics`ï¼Œ`IntStream`ã€‚
    
-   Collectors ä¸‹çš„ averagingIntã€summingInt ç­‰ã€‚
    
-   Collectors.mapping
    
    Â public Map<Artist, List<String>> nameOfAlbums(Stream<Album> albums) { return   
    Â  Â  Â albums.collect(groupingBy(Album::getMainMusician,  
    Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â mapping(Album::getName, toList())));  
    Â }
    
    ç¬¬äºŒä¸ªæ”¶é›†å™¨ç”¨ä»¥æ”¶é›†æœ€ç»ˆç»“æœçš„ä¸€ä¸ªå­é›†ï¼Œè¿™äº›æ”¶é›†å™¨å«ä½œä¸‹æ¸¸æ”¶é›†å™¨ã€‚
    
-   Map.compute
    

## è‡ªå®šä¹‰æ”¶é›†å™¨

æ ¼å¼åŒ–è‰ºæœ¯å®¶çš„å§“å

Â StringBuilder builder = new StringBuilder("[");   
Â for (Artist artist : artists) {  
Â  Â  Â if (builder.length() > 1)   
Â  Â  Â  Â  Â builder.append(", ");  
Â  Â  Â String name = artist.getName();  
Â  Â  Â builder.append(name);  
Â }  
Â builder.append("]");  
Â String result = builder.toString();

å…ˆä½¿ç”¨ reduce æ”¹é€ 

StringBuilder reduced =  
    artists.stream()  
    .map(Artist::getName)  
    .reduce(new StringBuilder(), (builder, name) -> {  
        if (builder.length() > 0)  
            builder.append(", ");  
        builder.append(name);  
        return builder;  
    }, (left, right) -> left.append(right));  
reduced.insert(0, "[");  
reduced.append("]");  
String result = reduced.toString();

å®ç° StringCombinerï¼ˆå†…éƒ¨å°†æ“ä½œä»£ç†ç»™ä¸€ä¸ª StringBuilder å¯¹è±¡ï¼‰

Â String result =  
Â  Â  Â artists.stream()  
Â  Â   .map(Artist::getName)  
Â  Â   .reduce(new StringCombiner(", ", "[", "]"),  
Â  Â  Â  Â  Â  Â  Â StringCombiner::add,  
Â  Â  Â  Â  Â  Â  Â StringCombiner::merge);  
Â     .toString();  
Â â€‹  
Â â€‹  
Â public StringCombiner add(String element) {   
Â  Â  Â if (areAtStart()) {  
Â  Â  Â  Â  Â builder.append(prefix); }  
Â  Â  Â else{  
Â  Â  Â  Â  Â builder.append(delim);  
Â  Â   }  
Â  Â  Â builder.append(element);  
Â  Â  Â return this;  
Â }  
Â â€‹  
Â public StringCombiner merge(StringCombiner other) {   
Â  Â  Â builder.append(other.builder);  
Â  Â  Â return this;  
Â }

è‡ªå®šä¹‰æ”¶é›†å™¨

Â  String result =  
Â  Â  Â  Â  Â  artists.stream()  
Â  Â  Â  Â  Â  Â  Â  Â   .map(Artist::getName)  
Â  Â  Â  Â  Â  Â  Â  Â   .collect(new StringCollector(", ", "[", "]"));

ä¸€ä¸ªæ”¶é›†å™¨ç”±å››éƒ¨åˆ†ç»„æˆã€‚é¦–å…ˆæ˜¯ä¸€ä¸ª Supplierï¼Œè¿™æ˜¯ä¸€ä¸ªå·¥å‚æ–¹æ³•ï¼Œç”¨æ¥åˆ›å»ºå®¹å™¨ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå°±æ˜¯ StringCombinerã€‚å’Œ reduce æ“ä½œä¸­çš„ç¬¬ä¸€ä¸ªå‚æ•°ç±»ä¼¼ï¼Œå®ƒæ˜¯åç»­æ“ä½œçš„åˆå€¼ã€‚

æ”¶é›†å™¨çš„ accumulator çš„ä½œç”¨å’Œ reduce æ“ä½œçš„ç¬¬äºŒä¸ªå‚æ•°ä¸€æ ·ï¼Œå®ƒç»“åˆä¹‹å‰æ“ä½œçš„ç»“æœ å’Œå½“å‰å€¼ï¼Œç”Ÿæˆå¹¶è¿”å›æ–°çš„å€¼ã€‚è¿™ä¸€é€»è¾‘å·²ç»åœ¨ StringCombiners çš„ add æ–¹æ³•ä¸­å¾—ä»¥å®ç°ï¼Œ ç›´æ¥å¼•ç”¨å°±å¥½äº†

combiner æ–¹æ³•å¾ˆåƒ reduce æ“ä½œçš„ç¬¬ä¸‰ä¸ªæ–¹æ³•ã€‚å¦‚æœæœ‰ä¸¤ä¸ªå®¹å™¨ï¼Œæˆ‘ä»¬éœ€è¦å°†å…¶åˆå¹¶ã€‚åŒæ ·ï¼Œåœ¨å‰é¢çš„é‡æ„ä¸­æˆ‘ä»¬å·²ç»å®ç°äº†è¯¥åŠŸèƒ½ï¼Œç›´æ¥ä½¿ç”¨ StringCombiner.merge æ–¹æ³•å°±è¡Œäº†ã€‚

é›†å™¨çš„ finisher æ–¹æ³•ä½œç”¨ç›¸åŒã€‚æˆ‘ä»¬å·²ç»å°†æµä¸­çš„å€¼å åŠ å…¥ä¸€ä¸ªå¯å˜å®¹å™¨ä¸­ï¼Œä½†è¿™è¿˜ä¸ æ˜¯æˆ‘ä»¬æƒ³è¦çš„æœ€ç»ˆç»“æœã€‚è¿™é‡Œè°ƒç”¨äº† finisher æ–¹æ³•ï¼Œä»¥ä¾¿è¿›è¡Œè½¬æ¢ã€‚åœ¨æˆ‘ä»¬æƒ³åˆ›å»ºå­—ç¬¦ä¸² ç­‰ä¸å¯å˜çš„å€¼æ—¶ç‰¹åˆ«æœ‰ç”¨ï¼Œè¿™é‡Œå®¹å™¨æ˜¯å¯å˜çš„ã€‚

ä¸ºäº†å®ç° finisher æ–¹æ³•ï¼Œåªéœ€å°†è¯¥æ“ä½œä»£ç†ç»™å·²ç»å®ç°çš„ toString æ–¹æ³•å³å¯

Â public class StringCollector implements Collector<String, StringCombiner, String> {  
Â  Â  Â public Supplier<StringCombiner> supplier() {  
Â  Â  Â  Â  Â return () -> new StringCombiner(delim, prefix, suffix);  
Â  Â   }  
Â  Â  Â   
Â  Â  Â public BiConsumer<StringCombiner, String> accumulator() {   
Â  Â  Â  Â  Â return StringCombiner::add;  
Â â€‹  
Â  Â   }  
Â  Â  Â   
Â  Â  Â public BinaryOperator<StringCombiner> combiner() {   
Â  Â  Â  Â  Â return StringCombiner::merge;  
Â  Â   }  
Â â€‹  
Â  Â  Â public Function<StringCombiner, String> finisher() {   
Â  Â  Â  Â  Â return StringCombiner::toString;  
Â  Â   }  
Â }

æ”¶é›†å™¨ï¼Œè¿˜æœ‰ä¸€ç‚¹ä¸€ç›´æ²¡æœ‰æåŠï¼Œé‚£å°±æ˜¯ç‰¹å¾ã€‚ç‰¹å¾æ˜¯ä¸€ç»„æè¿°æ”¶é›†å™¨çš„å¯¹è±¡ï¼Œæ¡†æ¶å¯ä»¥å¯¹å…¶é€‚å½“ä¼˜åŒ–ã€‚characteristics æ–¹æ³•å®šä¹‰äº†ç‰¹å¾ã€‚

Â  Â  Â enum Characteristics {  
Â  Â  Â  Â  Â /**  
Â  Â  Â  Â  Â  * Indicates that this collector is <em>concurrent</em>, meaning that  
Â  Â  Â  Â  Â  * the result container can support the accumulator function being  
Â  Â  Â  Â  Â  * called concurrently with the same result container from multiple  
Â  Â  Â  Â  Â  * threads.  
Â  Â  Â  Â  Â  *  
Â  Â  Â  Â  Â  * <p>If a {@code CONCURRENT} collector is not also {@code UNORDERED},  
Â  Â  Â  Â  Â  * then it should only be evaluated concurrently if applied to an  
Â  Â  Â  Â  Â  * unordered data source.  
Â  Â  Â  Â  Â  */  
Â  Â  Â  Â  Â CONCURRENT,  
Â â€‹  
Â  Â  Â  Â  Â /**  
Â  Â  Â  Â  Â  * Indicates that the collection operation does not commit to preserving  
Â  Â  Â  Â  Â  * the encounter order of input elements.  (This might be true if the  
Â  Â  Â  Â  Â  * result container has no intrinsic order, such as a {@link Set}.)  
Â  Â  Â  Â  Â  */  
Â  Â  Â  Â  Â UNORDERED,  
Â â€‹  
Â  Â  Â  Â  Â /**  
Â  Â  Â  Â  Â  * Indicates that the finisher function is the identity function and  
Â  Â  Â  Â  Â  * can be elided.  If set, it must be the case that an unchecked cast  
Â  Â  Â  Â  Â  * from A to R will succeed.  
Â  Â  Â  Â  Â  */  
Â  Â  Â  Â  Â IDENTITY_FINISH  
Â  Â   }

# æ•°æ®å¹¶è¡ŒåŒ–

## ä»‹ç»

å®ç°è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿæ³•ï¼Œæ·ä¸¤ä¸ªéª°å­ï¼Œç»Ÿè®¡æ¯ä¸ªç§å€¼å‡ºç°çš„å¯èƒ½æ€§ã€‚æ¨¡æ‹ŸæŠ•æ·éª°å­çš„æ¬¡æ•°è¶Šå¤šï¼Œå¾—åˆ°çš„ç»“æœè¶Šå‡†ç¡®ã€‚

Â public Map<Integer, Double> parallelDiceRolls() {  
Â â€‹  
Â  Â  Â double fraction = 1.0 / N;  
Â â€‹  
Â  Â  Â return IntStream.range(0, N)   
Â  Â  Â  Â   .parallel()  
Â  Â  Â  Â   .mapToObj(twoDiceThrows())  
Â  Â  Â  Â   .collect(groupingBy(side -> side, summingDouble(n -> fraction)));  
Â }

collect å¤„ä½¿ç”¨ groupingBy å°†ç‚¹æ•°ä¸€æ ·çš„ç»“æœåˆå¹¶ã€‚

å¦‚æœæ‰‹åŠ¨å®ç°å¹¶è¡ŒåŒ–è’™ç‰¹å¡æ´›æ¨¡æ‹Ÿæ³•ï¼Œå¤§å¤šæ•°ä»£ç éƒ½åœ¨å¤„ç†è°ƒåº¦å’Œç­‰å¾…çº¿ç¨‹æ± ä¸­çš„æŸé¡¹ä»»åŠ¡å®Œæˆï¼š

Â public class ManualDiceRolls {  
Â â€‹  
Â  Â  Â private static final int N = 100000000;  
Â  Â  Â private final double fraction;  
Â  Â  Â private final Map<Integer, Double> results;   
Â  Â  Â private final int numberOfThreads;  
Â  Â  Â private final ExecutorService executor;   
Â  Â  Â private final int workPerThread;  
Â â€‹  
Â  Â  Â public static void main(String[] args) {   
Â  Â  Â  Â  Â ManualDiceRolls roles = new ManualDiceRolls();   
Â  Â  Â  Â  Â roles.simulateDiceRoles();  
Â  Â   }  
Â â€‹  
Â  Â  Â public ManualDiceRolls() {  
Â  Â  Â  Â  Â fraction = 1.0 / N;  
Â  Â  Â  Â  Â results = new ConcurrentHashMap<>();  
Â  Â  Â  Â  Â numberOfThreads = Runtime.getRuntime().availableProcessors();  
Â  Â  Â  Â  Â executor = Executors.newFixedThreadPool(numberOfThreads);   
Â  Â  Â  Â  Â workPerThread = N / numberOfThreads;  
Â  Â   }  
Â â€‹  
Â  Â  Â public void simulateDiceRoles() {   
Â  Â  Â  Â  Â List<Future<?>> futures = submitJobs();   
Â  Â  Â  Â  Â awaitCompletion(futures);   
Â  Â  Â  Â  Â printResults();  
Â  Â   }  
Â â€‹  
Â  Â  Â private void printResults() {   
Â  Â  Â  Â  Â results.entrySet()  
Â  Â  Â  Â  Â  Â  .forEach(System.out::println);  
Â  Â   }  
Â â€‹  
Â  Â  Â private List<Future<?>> submitJobs() {   
Â  Â  Â  Â  Â List<Future<?>> futures = new ArrayList<>();   
Â  Â  Â  Â  Â for (int i = 0; i < numberOfThreads; i++) {  
Â  Â  Â  Â  Â  Â  Â futures.add(executor.submit(makeJob()));  
Â  Â  Â  Â   }  
Â  Â  Â  Â  Â return futures;   
Â  Â   }  
Â â€‹  
Â  Â    
Â  Â  Â private Runnable makeJob() {   
Â  Â  Â  Â  Â return () -> {  
Â  Â  Â  Â  Â  Â  Â ThreadLocalRandom random = ThreadLocalRandom.current();   
Â  Â  Â  Â  Â  Â  Â for (int i = 0; i < workPerThread; i++) {  
Â  Â  Â  Â  Â  Â  Â  Â  Â int entry = twoDiceThrows(random);  
Â  Â  Â  Â  Â  Â  Â  Â  Â accumulateResult(entry);  
Â  Â  Â  Â  Â  Â   }  
Â  Â  Â  Â   };   
Â  Â   }  
Â â€‹  
Â  Â  Â private void accumulateResult(int entry) {   
Â  Â  Â  Â  Â results.compute(entry, (key, previous) ->  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â previous == null ? fraction  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â   : previous + fraction  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  );   
Â  Â   }  
Â â€‹  
Â  Â  Â private int twoDiceThrows(ThreadLocalRandom random) {   
Â  Â  Â  Â  Â int firstThrow = random.nextInt(1, 7);  
Â  Â  Â  Â  Â int secondThrow = random.nextInt(1, 7);  
Â  Â  Â  Â  Â return firstThrow + secondThrow;  
Â  Â   }  
Â â€‹  
Â  Â  Â private void awaitCompletion(List<Future<?>> futures) {   
Â  Â  Â  Â  Â futures.forEach((future) -> {  
Â  Â  Â  Â  Â  Â  Â try { future.get();  
Â  Â  Â  Â  Â  Â  Â  Â   } catch (InterruptedException | ExecutionException e) {  
Â  Â  Â  Â  Â  Â  Â  Â  Â e.printStackTrace();  
Â  Â  Â  Â  Â  Â   }  
Â  Â  Â  Â   });  
Â  Â  Â  Â  Â executor.shutdown();  
Â  Â   }  
Â }

## é™åˆ¶

-   å¹¶è¡Œ reduce çš„æ—¶å€™ï¼Œå¿…é¡»ä¿è¯åˆå§‹å€¼ä¸ºç»„åˆå‡½æ•°çš„æ’ç­‰å€¼ã€‚æ‹¿æ’ç­‰å€¼å’Œå…¶ä»–å€¼åš reduce æ“ä½œæ—¶ï¼Œå…¶ä»–å€¼ä¿æŒä¸å˜ã€‚æ¯”å¦‚ï¼Œä½¿ç”¨ reduce æ“ä½œæ±‚å’Œï¼Œç»„åˆå‡½æ•°ä¸º `(acc, element) -> acc + element`ï¼Œåˆ™å…¶åˆå€¼å¿…é¡»ä¸º0ï¼Œå› ä¸ºä»»ä½•æ•°å­—åŠ  0ï¼Œå€¼ä¸å˜ã€‚
    
-   reduce æ“ä½œçš„å¦ä¸€ä¸ªé™åˆ¶æ˜¯ç»„åˆæ“ä½œå¿…é¡»ç¬¦åˆç»“åˆå¾‹ã€‚è¿™æ„å‘³ç€åªè¦åºåˆ—çš„å€¼ä¸å˜ï¼Œç»„åˆæ“ä½œçš„é¡ºåºä¸é‡è¦ã€‚
    
-   å¹¶è¡Œæ—¶ï¼Œè¿˜è¦é¿å…æ‰‹åŠ¨ä¸ºæ•°æ®ç»“æ„åŠ é”ã€‚å› ä¸ºæµæ¡†æ¶åœ¨éœ€è¦çš„æ—¶å€™ï¼Œè‡ªå·±å¤„ç†åŒæ­¥æ“ä½œã€‚
    
-   `sequential` å°†å¹¶è¡Œæµè½¬ä¸ºä¸²è¡Œã€‚
    

## æ€§èƒ½

-   æ•°æ®å¤§å°ã€‚å°†é—®é¢˜åˆ†è§£ä¹‹åå¹¶è¡ŒåŒ–å¤„ç†ï¼Œå†å°†ç»“æœåˆå¹¶ä¼šå¸¦æ¥é¢å¤–çš„å¼€é”€ã€‚å› æ­¤åªæœ‰æ•°æ®è¶³å¤Ÿå¤§ã€æ¯ä¸ªæ•°æ®å¤„ç†ç®¡é“èŠ±è´¹çš„æ—¶é—´è¶³å¤Ÿå¤šæ—¶ï¼Œå¹¶è¡ŒåŒ–å¤„ç†æ‰æœ‰æ„ä¹‰ã€‚
    
-   æºæ•°æ®ç»“æ„ã€‚æ¯ä¸ªç®¡é“çš„æ“ä½œéƒ½åŸºäºä¸€äº›åˆå§‹æ•°æ®æºï¼Œé€šå¸¸æ˜¯é›†åˆã€‚å°†ä¸åŒçš„æ•°æ®æºåˆ†å‰²ç›¸å¯¹å®¹æ˜“ï¼Œè¿™é‡Œçš„å¼€é”€å½±å“äº†åœ¨ç®¡é“ä¸­å¹¶è¡Œå¤„ç†æ•°æ®æ—¶åˆ°åº•èƒ½å¸¦æ¥å¤šå°‘æ€§èƒ½ä¸Šçš„æå‡ã€‚
    
-   è£…ç®±ã€‚å¤„ç†åŸºæœ¬ç±»å‹æ¯”å¤„ç†è£…ç®±ç±»å‹è¦å¿«ã€‚
    
-   æ ¸çš„æ•°é‡ã€‚åªæœ‰ä¸€ä¸ªæ ¸å°±å®Œå…¨æ²¡å¿…è¦å¹¶è¡ŒåŒ–ã€‚æ˜¾ç„¶ï¼Œæ‹¥æœ‰çš„æ ¸è¶Šå¤šï¼Œè·å¾—æ½œåœ¨æ€§èƒ½æå‡çš„å¹…åº¦å°±è¶Šå¤§ã€‚åœ¨å®è·µä¸­ï¼Œæ ¸çš„æ•°é‡ä¸å•æŒ‡ä½ çš„æœºå™¨ä¸Šæœ‰å¤šå°‘æ ¸ï¼Œæ›´æ˜¯æŒ‡**è¿è¡Œæ—¶**ä½ çš„æœºå™¨èƒ½ä½¿ç”¨å¤šå°‘æ ¸ã€‚è¿™ä¹Ÿå°±æ˜¯è¯´åŒæ—¶è¿è¡Œçš„å…¶ä»–è¿›ç¨‹ï¼Œæˆ–è€…çº¿ç¨‹å…³è”æ€§ï¼ˆå¼ºåˆ¶çº¿ç¨‹åœ¨æŸäº›æ ¸æˆ– CPU ä¸Šè¿è¡Œï¼‰ä¼šå½±å“æ€§èƒ½ã€‚
    
-   å•å…ƒå¤„ç†å¼€é”€ã€‚æ¯”å¦‚æ•°æ®å¤§å°ï¼Œè¿™æ˜¯ä¸€åœºå¹¶è¡Œæ‰§è¡ŒèŠ±è´¹æ—¶é—´å’Œåˆ†è§£åˆå¹¶æ“ä½œå¼€é”€ä¹‹é—´çš„æˆ˜äº‰ã€‚èŠ±åœ¨æµä¸­æ¯ä¸ªå…ƒç´ èº«ä¸Šçš„æ—¶é—´è¶Šé•¿ï¼Œå¹¶è¡Œæ“ä½œå¸¦æ¥çš„æ€§èƒ½æå‡è¶Šæ˜æ˜¾ã€‚
    

å¹¶å‘æµä½¿ç”¨çš„æ•°æ®ç»“æ„æ€§èƒ½æ’è¡Œï¼š

-   æ€§èƒ½å¥½ ArrayListã€æ•°ç»„æˆ– IntStream.rangeã€‚è¿™äº›æ•°æ®ç»“æ„æ”¯æŒéšæœºè¯»å–ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä»¬èƒ½è½»è€Œæ˜“ä¸¾åœ°è¢«ä»»æ„åˆ†è§£ã€‚
    
-   æ€§èƒ½ä¸€èˆ¬ã€‚HashSetã€TreeSetï¼Œè¿™äº›æ•°æ®ç»“æ„ä¸æ˜“å…¬å¹³åœ°è¢«åˆ†è§£ï¼Œä½†æ˜¯å¤§å¤šæ•°æ—¶å€™åˆ†è§£æ˜¯å¯èƒ½çš„ã€‚
    
-   æ€§èƒ½å·®ã€‚æœ‰äº›æ•°æ®ç»“æ„éš¾äºåˆ†è§£ï¼Œæ¯”å¦‚ï¼Œå¯èƒ½è¦èŠ± _O_(_N_) çš„æ—¶é—´å¤æ‚åº¦æ¥åˆ†è§£é—®é¢˜ã€‚å…¶ä¸­åŒ…æ‹¬ LinkedListï¼Œå¯¹åŠåˆ†è§£å¤ªéš¾äº†ã€‚è¿˜æœ‰ Streams.iterate å’Œ BufferedReader.linesï¼Œå®ƒä»¬ é•¿åº¦æœªçŸ¥ï¼Œå› æ­¤å¾ˆéš¾é¢„æµ‹è¯¥åœ¨å“ªé‡Œåˆ†è§£ã€‚
    

åœ¨å°†æµåˆ†å‰²æˆå¤šä¸ªä»»åŠ¡æ—¶ï¼Œå¯ä»¥åˆ†æˆä¸¤ç§ä¸åŒçš„æ“ä½œï¼šæ— çŠ¶æ€çš„å’Œæœ‰çŠ¶æ€çš„ã€‚æ— çŠ¶æ€æ“ä½œæ•´ä¸ªè¿‡ç¨‹ä¸­ä¸å¿…ç»´æŠ¤çŠ¶æ€ï¼Œæœ‰çŠ¶æ€æ“ä½œåˆ™æœ‰ç»´æŠ¤çŠ¶æ€æ‰€éœ€çš„å¼€é”€å’Œé™åˆ¶ã€‚æ— çŠ¶æ€æ“ä½œæœ‰æ›´å¥½çš„å¹¶è¡Œæ€§èƒ½ï¼ŒåŒ…æ‹¬ mapã€ filter å’Œ flatMapï¼Œæœ‰çŠ¶æ€æ“ä½œåŒ…æ‹¬ sortedã€distinct å’Œ limitã€‚

## å¹¶è¡ŒåŒ–æ•°ç»„

`Arrays` ç±»ä¸­ï¼š

-   parallelPrefixï¼šä»»æ„ç»™å®šä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®—æ•°ç»„çš„å’Œ
    
-   parallelSetAllï¼šæ›´æ–°æ•°ç»„å…ƒç´ 
    
-   parallelSortï¼šå¹¶è¡ŒåŒ–å¯¹æ•°ç»„å…ƒç´ æ’åº
    

åˆå§‹åŒ–æ•°ç»„ï¼š

Â public static double[] parallelInitialize(int size) {   
Â  Â  Â double[] values = new double[size];   
Â  Â  Â Arrays.parallelSetAll(values, i -> i);  
Â  Â  Â return values;  
Â }

è®¡ç®—æ»‘åŠ¨çª—å£å¹³å‡æ•°

Â public static double[] simpleMovingAverage(double[] values, int n) {   
Â  Â  Â double[] sums = Arrays.copyOf(values, values.length);   
Â  Â  Â Arrays.parallelPrefix(sums, Double::sum);  
Â     int start = n - 1;  
Â     return IntStream.range(start, sums.length)  
Â  Â  Â  Â   .mapToDouble(i -> {  
Â  Â  Â  Â  Â  Â  Â double prefix = i == start ? 0 : sums[i - n];  
Â  Â  Â  Â  Â  Â  Â return (sums[i] - prefix) / n;  
Â  Â  Â  Â   })  
Â  Â  Â  Â   .toArray();   
Â }

# é‡æ„

Â ThreadLocal<Album> thisAlbum = new ThreadLocal<Album> () {   
Â  Â  Â @Override protected Album initialValue() {  
Â  Â  Â  Â  Â return database.lookupCurrentAlbum();   
Â  Â   }  
Â };  
Â â€‹  
Â ThreadLocal<Album> thisAlbum = ThreadLocal.withInitial(() -> database.lookupCurrentAlbum());

å®ç°å‡ ä¸ªæ–¹æ³•æ¥ç»Ÿè®¡ä¸“è¾‘å†…çš„ä¸€äº›ä¿¡æ¯ï¼š

Â public long countRunningTime() {   
Â  Â  Â long count = 0;  
Â  Â  Â for (Album album : albums) {  
Â  Â  Â  Â  Â for (Track track : album.getTrackList()) {  
Â  Â  Â  Â  Â  Â  Â count += track.getLength();  
Â  Â  Â  Â   }  
Â  Â   }  
Â  Â  Â return count;  
Â }  
Â â€‹  
Â public long countMusicians() {   
Â  Â  Â long count = 0;  
Â  Â  Â for (Album album : albums) {  
Â  Â  Â  Â  Â count += album.getMusicianList().size();  
Â  Â   }  
Â  Â  Â return count;   
Â }  
Â â€‹  
Â public long countTracks() {   
Â  Â  Â long count = 0;  
Â  Â  Â for (Album album : albums) {  
Â  Â  Â  Â  Â count += album.getTrackList().size();  
Â  Â   }  
Â  Â  Â return count;   
Â }

ä½¿ç”¨ stream ç¬¬ä¸€æ¬¡é‡æ„

Â public long countRunningTime() {   
Â  Â  Â return albums.stream()  
Â  Â  Â  Â   .mapToLong(album -> album.getTracks()  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .mapToLong(track -> track.getLength())  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .sum())  
Â  Â  Â  Â   .sum();  
Â }  
Â â€‹  
Â public long countMusicians() {   
Â  Â  Â return albums.stream()  
Â  Â  Â  Â   .mapToLong(album -> album.getMusicians().count())  
Â  Â  Â  Â   .sum();  
Â }  
Â â€‹  
Â public long countTracks() {   
Â  Â  Â return albums.stream()  
Â  Â  Â  Â   .mapToLong(album -> album.getTracks().count())  
Â  Â  Â  Â   .sum();  
Â }

ç»§ç»­é‡æ„

Â public long countFeature(ToLongFunction<Album> function) { return albums.stream()  
Â  Â   .mapToLong(function)  
Â  Â   .sum();  
Â }  
Â â€‹  
Â public long countTracks() {  
Â  Â  Â return countFeature(album -> album.getTracks().count());  
Â }  
Â â€‹  
Â public long countRunningTime() {  
Â  Â  Â return countFeature(album -> album.getTracks()  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â   .mapToLong(track -> track.getLength())  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â   .sum());  
Â }  
Â public long countMusicians() {  
Â  Â  Â return countFeature(album -> album.getMusicians().count());  
Â }

# è°ƒè¯•æµ

`peek` æ–¹æ³•å¯ä»¥æŸ¥çœ‹æ¯ä¸ªå€¼ï¼ŒåŒæ—¶èƒ½ç»§ç»­æ“ä½œæµã€‚peek å¯ä»¥è¾“å‡ºå€¼ï¼Œä¹Ÿå¯ä»¥æ‰“æ—¥å¿—ã€‚ä¹Ÿå¯ä»¥åœ¨å†™ä¸€ä¸ªç©ºæ–¹ä½“çš„ peakï¼Œå¹¶æ‰“ä¸Šæ–­ç‚¹æ¥é€ä¸ªè°ƒè¯•æµä¸­çš„å…ƒç´ ã€‚å¦‚æœ debugger ä¸æ”¯æŒç©ºæ–¹æ³•ä½“ï¼Œé‚£ä¹ˆå°±ç®€å•å°†å€¼æ˜ å°„ä¸ºæœ¬èº«ã€‚

# ä½¿ç”¨ lambda çš„è®¾è®¡æ¨¡å¼

## å‘½ä»¤æ¨¡å¼

### ä»¥å‰

Â public interface Editor {  
Â  Â  Â public void save();   
Â  Â  Â public void open();   
Â  Â  Â public void close();  
Â }  
Â â€‹  
Â public interface Action {  
Â  Â  Â public void perform();   
Â }  
Â â€‹  
Â public class Save implements Action {  
Â  Â  Â private final Editor editor;   
Â  Â  Â public Save(Editor editor) {  
Â  Â  Â  Â  Â this.editor = editor;  
Â  Â   }  
Â â€‹  
Â  Â  Â @Override  
Â  Â  Â public void perform() {  
Â  Â  Â  Â  Â editor.save();  
Â  Â   }  
Â }  
Â â€‹  
Â public class Open implements Action {  
Â  Â  Â private final Editor editor;  
Â  Â  Â public Open(Editor editor) {   
Â  Â  Â  Â  Â this.editor = editor;  
Â  Â   }  
Â â€‹  
Â  Â  Â @Override  
Â  Â  Â public void perform() {  
Â  Â  Â  Â  Â editor.open();  
Â  Â   }  
Â }

Â public class Macro {  
Â  Â  Â private final List<Action> actions;  
Â â€‹  
Â  Â  Â public Macro() {  
Â  Â  Â  Â  Â actions = new ArrayList<>();  
Â  Â   }  
Â â€‹  
Â  Â  Â public void record(Action action) {   
Â  Â  Â  Â  Â actions.add(action);  
Â  Â   }  
Â â€‹  
Â  Â  Â public void run() {   
Â  Â  Â  Â  Â actions.forEach(Action::perform);  
Â  Â   }  
Â }

Â Macro macro = new Macro();  
Â macro.record(new Open(editor));   
Â macro.record(new Save(editor));   
Â macro.record(new Close(editor));   
Â macro.run();

### ä½¿ç”¨ Lambda

Â Macro macro = new Macro();   
Â macro.record(() -> editor.open());   
Â macro.record(() -> editor.save());   
Â macro.record(() -> editor.close());   
Â macro.run();

Â Macro macro = new Macro();   
Â macro.record(editor::open);   
Â macro.record(editor::save);   
Â macro.record(editor::close); macro.run();

ä¸å†éœ€è¦ç¼–å†™ Saveã€Open ç­‰å…·ä½“å‘½ä»¤ç±»ã€‚

## ç­–ç•¥æ¨¡å¼

### ä»¥å‰

Â public interface CompressionStrategy {  
Â  Â  Â public OutputStream compress(OutputStream data) throws IOException;  
Â }  
Â â€‹  
Â public class GzipCompressionStrategy implements CompressionStrategy {  
Â  Â  Â @Override  
Â  Â  Â public OutputStream compress(OutputStream data) throws IOException {  
Â  Â  Â  Â  Â return new GZIPOutputStream(data);   
Â  Â   }  
Â }  
Â â€‹  
Â public class ZipCompressionStrategy implements CompressionStrategy {  
Â  Â  Â @Override  
Â  Â  Â public OutputStream compress(OutputStream data) throws IOException {  
Â  Â  Â  Â  Â return new ZipOutputStream(data);   
Â  Â   }  
Â }  
Â â€‹  
Â public class Compressor {  
Â  Â  Â private final CompressionStrategy strategy;  
Â â€‹  
Â  Â  Â public Compressor(CompressionStrategy strategy) {   
Â  Â  Â  Â  Â this.strategy = strategy;  
Â  Â   }  
Â â€‹  
Â  Â  Â public void compress(Path inFile, File outFile) throws IOException {   
Â  Â  Â  Â  Â try (OutputStream outStream = new FileOutputStream(outFile)) {  
Â  Â  Â  Â  Â  Â  Â Files.copy(inFile, strategy.compress(outStream));  
Â  Â  Â  Â   }  
Â  Â   }   
Â }

Â Compressor gzipCompressor = new Compressor(new GzipCompressionStrategy());  
Â gzipCompressor.compress(inFile, outFile);  
Â â€‹  
Â Compressor zipCompressor = new Compressor(new ZipCompressionStrategy()); zipCompressor.compress(inFile, outFile);

### ä½¿ç”¨ Lambda

å»æ‰å…·ä½“çš„ç­–ç•¥å®ç°ï¼Œä½¿ç”¨ä¸€ä¸ªæ–¹æ³•å®ç°ç®—æ³•ã€‚

Compressor gzipCompressor = new Compressor(GZIPOutputStream::new);  
gzipCompressor.compress(inFile, outFile);  
  
Compressor zipCompressor = new Compressor(ZipOutputStream::new);   
zipCompressor.compress(inFile, outFile);

## è§‚å¯Ÿè€…æ¨¡å¼

### ä»¥å‰

public interface LandingObserver {  
    public void observeLanding(String name);   
}  
  
public class Moon {  
    private final List<LandingObserver> observers = new ArrayList<>();  
    public void land(String name) {  
        for (LandingObserver observer : observers) {  
            observer.observeLanding(name);  
        }  
    }  
  
    public void startSpying(LandingObserver observer) {   
        observers.add(observer);  
    }   
}  
  
public class Aliens implements LandingObserver {  
    @Override  
    public void observeLanding(String name) {  
        if (name.contains("Apollo")) {  
            System.out.println("They're distracted, lets invade earth!");  
        }   
    }  
}  
  
  
public class Nasa implements LandingObserver {   
    @Override  
  
    public void observeLanding(String name) {   
        if (name.contains("Apollo")) {  
            System.out.println("We made it!");  
        }  
    }   
}

Moon moon = new Moon(); moon.startSpying(new Nasa());   
moon.startSpying(new Aliens());  
     
moon.land("An asteroid");  
moon.land("Apollo 11");

### ä½¿ç”¨ Lambda

Moon moon = new Moon();  
moon.startSpying(name -> {  
    if (name.contains("Apollo"))  
        System.out.println("We made it!");  
});  
  
moon.startSpying(name -> {  
    if (name.contains("Apollo"))  
        System.out.println("They're distracted, lets invade earth!");  
});  
  
moon.land("An asteroid");  
moon.land("Apollo 11");

## ä¾‹å¤–

æ— è®ºä½¿ç”¨è§‚å¯Ÿè€…æ¨¡å¼æˆ–ç­–ç•¥æ¨¡å¼ï¼Œå®ç°æ—¶é‡‡ç”¨ Lambda è¡¨è¾¾å¼è¿˜æ˜¯ä¼ ç»Ÿçš„ç±»ï¼Œå–å†³äºç­–ç•¥å’Œè§‚å¯Ÿè€…ä»£ç çš„å¤æ‚åº¦ã€‚å¦‚æœè¿‡äºå¤æ‚ï¼Œé‡‡ç”¨ Lambda åè€Œä¼šå¤§å¤§é™ä½ä»£ç çš„å¯è¯»æ€§ã€‚

# ä½¿ç”¨ Lambda çš„ SOLID åŸåˆ™

Single responsibilityã€Open/closedã€Liskov substitutionã€Interface segregation å’Œ Dependency inversionã€‚

## å•ä¸€æŒ‡è´£åŸåˆ™

Â public long countPrimes(int upTo) {   
Â  Â  Â long tally = 0;  
Â  Â  Â for(int i = 1; i < upTo; i++){   
Â  Â  Â  Â  Â boolean isPrime = true;   
Â  Â  Â  Â  Â for(int j = 2; j < i; j++){  
Â  Â  Â  Â  Â  Â  Â if(i%j==0){   
Â  Â  Â  Â  Â  Â  Â  Â  Â isPrime = false;  
Â  Â  Â  Â  Â  Â   }   
Â  Â  Â  Â   }  
Â  Â  Â  Â  Â if (isPrime) {  
Â  Â  Â  Â  Â  Â  Â tally++;   
Â  Â  Â  Â   }  
Â  Â   }  
Â  Â  Â return tally;   
Â }

Â public long countPrimes(int upTo) {   
Â  Â  Â long tally = 0;  
Â  Â  Â for(int i = 1; i < upTo; i++){   
Â  Â  Â  Â  Â if (isPrime(i)) {  
Â  Â  Â  Â  Â  Â  Â tally++;   
Â  Â  Â  Â   }  
Â  Â   }  
Â  Â  Â return tally;   
Â }  
Â â€‹  
Â private boolean isPrime(int number) {   
Â  Â  Â for(int i = 2; i < number; i++){  
Â  Â  Â  Â  Â if(number % i == 0){   
Â  Â  Â  Â  Â  Â  Â return false;  
Â  Â  Â  Â   }   
Â  Â   }  
Â  Â  Â return true;   
Â }

public long countPrimes(int upTo) {   
    return IntStream.range(1, upTo)  
        // .parallel()  
        .filter(this::isPrime) .count();  
}  
  
private boolean isPrime(int number) {   
    return IntStream.range(2, number)  
        .allMatch(x -> (number % x) != 0);  
}

## å¼€é—­åŸåˆ™

Â class MetricDataGraph {  
Â  Â  Â public void updateUserTime(int value);   
Â  Â  Â public void updateSystemTime(int value);   
Â  Â  Â public void updateIoTime(int value);  
Â }

ä¸Šé¢çš„ç±»ç”¨æ¥è®°å½•å„é¡¹ç³»ç»Ÿæ—¶é—´ï¼Œä½†å¦‚æœè¦æ·»åŠ æ–°çš„æ—¶é—´ç‚¹ï¼Œå°±è¦ä¿®æ”¹è¯¥ç±»ã€‚

å¼•å…¥æŠ½è±¡è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

Â class MetricDataGraph {  
Â  Â  Â public void addTimeSeries(TimeSeries values);   
Â }

æ¯é¡¹å…·ä½“æŒ‡æ ‡ç°åœ¨å¯ä»¥å®ç° TimeSeries æ¥å£ï¼Œåœ¨éœ€è¦æ—¶èƒ½ç›´æ¥æ’å…¥ã€‚æ¯”å¦‚ï¼Œç°åœ¨æœ‰ï¼šUserTimeSeriesã€SystemTimeSeries å’Œ IoTimeSeriesã€‚å¦‚æœè¦æ·»åŠ æ–°çš„ï¼Œåˆ™å¯å¢åŠ ä¸€ä¸ªæ–°çš„å®ç°äº† TimeSeries æ¥å£çš„ç±»ã€‚è¿™æ ·ï¼Œå°±æ‰©å±•äº† MetricDataGraph ç±»ï¼Œä½†å¹¶æ²¡æœ‰ä¿®æ”¹å®ƒã€‚

> Â class MetricDataGraph {  
> Â  public void updateTimeSerie(TimeSerieEnum timeSerie,int values);   
> Â â€‹  
> Â  enum TimeSerieEnum {  
> Â  Â  Â  USER_TIME,  
> Â  Â  Â  ...  
> Â  }  
> Â }
> 
> è¿™æ ·ä¹Ÿç¬¦åˆå¼€é—­åŸåˆ™å§ï¼Ÿ

ThreadLocal ä¹Ÿç¬¦åˆå¼€é—­åŸåˆ™ï¼š

Â ThreadLocal<DateFormat> localFormatter = ThreadLocal.withInitial(() -> new SimpleDateFormat());   
Â â€‹  
Â DateFormat formatter = localFormatter.get();

## ä¾èµ–åè½¬åŸåˆ™

è§£ææ–‡ä»¶ä¸­çš„æ ‡é¢˜ï¼š

Â public List<String> findHeadings(Reader input) {  
Â  Â  Â try (BufferedReader reader = new BufferedReader(input)) {  
Â  Â  Â  Â  Â return reader.lines()  
Â  Â  Â  Â  Â  Â   .filter(line -> line.endsWith(":"))  
Â  Â  Â  Â  Â  Â   .map(line -> line.substring(0, line.length() - 1))  
Â  Â  Â  Â  Â  Â   .collect(toList());   
Â  Â   }   
Â  Â  Â catch (IOException e) {  
Â  Â  Â  Â  Â throw new HeadingLookupException(e);   
Â  Â   }  
Â }

å‰¥ç¦»äº†æ–‡ä»¶å¤„ç†åŠŸèƒ½ï¼Œè®©è§£ææ ‡é¢˜ä¾èµ– Stream<String>ã€‚

Â public List<String> findHeadings(Reader input) {   
Â  Â  Â return withLinesOf(input,  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lines -> lines.filter(line -> line.endsWith(":"))  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .map(line -> line.substring(0, line.length()-1))  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .collect(toList()),  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  HeadingLookupException::new);  
Â }  
Â â€‹  
Â private <T> T withLinesOf(Reader input, Function<Stream<String>, T> handler,  
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Function<IOException, RuntimeException> error) {  
Â  Â  Â try (BufferedReader reader = new BufferedReader(input)) {   
Â  Â  Â  Â  Â return handler.apply(reader.lines());  
Â  Â   } catch (IOException e) {   
Â  Â  Â  Â  Â throw error.apply(e);  
Â  Â   }   
Â }

# ç¬¬å…«ã€ä¹ç« è¦çœ‹ä¸€ä¸‹
